{"meta":{"title":"墨镜猫","subtitle":null,"description":"求知若渴，大智若愚","author":"Jacky","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-01-26T03:45:19.000Z","updated":"2017-04-22T09:02:28.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 从事Android开发四年左右，自认为是一名技术极客。热爱开源，乐于分享。前乐视架构师。 小成就 CSDN博客专家 Github星榜中国区前20 Facebook、微软面试邀请 社交信息 CSDN：http://blog.csdn.net/rain_butterfly Github：https://github.com/JackyAndroid 掘金：https://gold.xitu.io/user/562dc7cc60b20fc9817962a2 微博：http://weibo.com/u/5885816355 微信：sunglasses_cat"},{"title":"虽然假期过去了，但一定不要再次辜负你的新年愿望","date":"2017-02-04T08:40:56.000Z","updated":"2017-05-31T02:57:21.000Z","comments":true,"path":"plan/index.html","permalink":"http://yoursite.com/plan/index.html","excerpt":"","text":"我们每个人在过去 12 个月都有大把机会去反省自己的缺点，但鲜少有人能努力提前完成理想转变。 近期计划 [ ] JVM 原理 [ ] Dalvik 原理 [ ] RxJava 源码解析 [ ] OkHttp 源码解析 [ ] Glide 源码解析 [ ] DroidPlugin 源码解析 [ ] Dynamic-load-apk 源码解析 [ ] Tinker 源码解析 [ ] Atlas 源码解析 书单 Android源码设计模式解析与实战 Android源代码情景分析 简明python教程 失控 科技想要什么 必然 幽默沟通 健康 每周2-3次锻炼 不加班 自我成长 参加付费课程 学会与他人高效充分的沟通，锻炼自己演讲能力 锻炼商业分析能力 旅行2-3次"}],"posts":[{"title":"Too many classes in --main-dex-list, main dex capacity exceeded | 主Dex引用太多怎么办？","slug":"Too-many-classes-in-main-dex-list-main-dex-capacity-exceeded-主Dex引用太多怎么办？","date":"2017-06-14T10:27:59.000Z","updated":"2017-06-14T12:32:05.000Z","comments":true,"path":"2017/06/14/Too-many-classes-in-main-dex-list-main-dex-capacity-exceeded-主Dex引用太多怎么办？/","link":"","permalink":"http://yoursite.com/2017/06/14/Too-many-classes-in-main-dex-list-main-dex-capacity-exceeded-主Dex引用太多怎么办？/","excerpt":"主 dex 里面会有 Application、Activity、Service、Receiver、Provider、Instrumentation、BackupAgent 和 Annotation。当这些类以及直接引用类比较多的时候，都要塞进主 dex ，就会引发 main dex capacity exceeded build error 。","text":"主 dex 里面会有 Application、Activity、Service、Receiver、Provider、Instrumentation、BackupAgent 和 Annotation。当这些类以及直接引用类比较多的时候，都要塞进主 dex ，就会引发 main dex capacity exceeded build error 。 在Lollipop之前的设备上，主Dex仅仅被Framework加载。为了支持multi-dex，应用必须明确的让类加载器去加载二级Dex文件（这就是为什么要调用MultiDex#install） 那就是说应用的主Dex应该包含所有的即将被加载器访问的类，如果你的应用的代码试着在类加载器加载之前，去引用二级Dex里面的class就会抛出Class Not Found异常。 那什么样的类会被包含在主Dex里面？ 会有三个顺序执行的任务将会决定哪个类应该被包含在主Dex里。 collect{variant}MultiDexComponents task，这个任务会根据manifest把所有应用组件（application, activities, services, receivers, providers）的名字写到一个文本文件。因此，如果你没有把其中的组件注册到manifest，那就不会被包含到主Dex里，也会有一些不注册的class也会被包含进去，比如注解。查看下CreateManifestKeepList.groovy 的源码就可以看到完整的包含列表。这个任务输出的文件是 manifest_keep.txt，路径为：app/build/intermediates/multi-dex。 shrink{variant}MultiDexComponents task，这个任务会掉起ProGuard程序创建一个压缩过的Jar文件，这个文件里只包含manifest_keep.txt里的class，这个任务输出的文件是componentClasses.jar create{variant}MainDexClassList task，这个任务会解析componentClasses.jar文件，为每一个类文件计算直接的引用层级，具体实现请查看链接。因此，如果你应用有一个注册的组件包含类X的变量，类X也会被包含进主Dex里面。这个任务输出的文件为：maindexlist.txt，包含主Dex里面所有的类。 如果最低版本是21会发生什么？如果最低版本是21上面所有的任务都不会执行，也不会有主Dex列表的计算。这是因为在应用安装期间所有的dex文件都会被ART转换为一个.oat文件。 所以如果这些类的引用超过了65536，构建的时候就会抛出这个Too many classes in --main-dex-list, main dex capacity exceeded 错误 那到底解决方案是什么？升级Gradle plugin的版本到2.2.0-alpha4以上，例：classpath &#39;com.android.tools.build:gradle:2.2.0&#39;，可以查看关于这个问题的Google Issue Tracker 参考：Too many classes in –main-dex-list, main dex capacity exceeded","categories":[],"tags":[]},{"title":"Hello Kotlin","slug":"Hello Kotlin","date":"2017-06-12T06:16:18.000Z","updated":"2017-06-23T01:43:40.000Z","comments":true,"path":"2017/06/12/Hello Kotlin/","link":"","permalink":"http://yoursite.com/2017/06/12/Hello Kotlin/","excerpt":"前世今生有什么样的语法？语法是怎么实现的？如何编译的？迁移成本为我们带来什么改变？","text":"前世今生有什么样的语法？语法是怎么实现的？如何编译的？迁移成本为我们带来什么改变？ 前世今生设计出发点 Concise — 简洁 Safe — 安全 Interoperable — 协作 目标Statically typed programming language for modern multiplatform applications静态类型编程语言用于现代多平台应用 有什么样的语法？语法对比 Kotlin vs Java kotlin Java 函数 fun sum(a: Int, b: Int): Int { return a + b } public int sum(int a, int b) {return a + b;} 变量 var a: Int = 1 int a = 1; 非空判断 text?.let { val length = text.length } if (text != null) { int length = text.length(); } 开关 var grade = when (score) {1, 2 -&gt; “Excellent” } String grade; switch (score) { case 1: case 2: grade = “Excellent”; break; } 基础数字 数字没有隐式拓宽转换，如 Java 中 int可以隐式转换为long 使数字常量更易，val oneMillion = 1_000_000 对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如:val x = (1 shl 2) and 0x000FF000，shl:有符号左移 and:位与 字符 字符用 Char 类型表示，它们不能直接当作数字，但可以显示转换 模板：val i = 10 val s = “i = $i” // 求值结果为 “i = 10” 控制流 If：是一个表达式，即它会返回一个值，没有三元运算符，使用if表达：val max = if (a &gt; b) a else b When：取代了类 C 语言的 switch 操作符，简单形式如下： 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; // 注意这个块 print(\"x is neither 1 nor 2\") &#125;&#125; when 既可以被当做表达式使用也可以被当做语句使用。可以用任意表达式（而不只是常量）作为分支条件： 1234when (x) &#123; parseInt(s) -&gt; print(\"s encodes x\") else -&gt; print(\"s does not encode x\")&#125; 返回和跳转 跳转表达式都可以用作更大表达式的一部分：val s = person.name ?: return 标签：我们可以用标签限制 break 或者continue： 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125; 类和对象类 类声明：Kotlin 中所有的类默认都是 final，由类名、类头（指定其类型参数、主 构造函数等）和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。通常如下： 12class Invoice &#123;&#125; 实例：val invoice = Invoice()，Kotlin 并没有 new 关键字。 覆盖：Kotlin力求清晰显式。与 Java 不同，Kotlin 需要显式 标注可覆盖的成员。如：override、open 静态方法：Kotlin 中类没有静态方法。建议简单地使用包级函数。 属性和字段 声明一个属性的完整语法是： 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 例： 12345var stringRepresentation: String get() = this.toString() set(value) &#123; setDataFromString(value) // 解析字符串并赋值给其他属性 &#125; 接口 Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有 属性但必须声明为抽象或提供访问器实现。 使用关键字 interface 来定义接口 123456interface MyInterface &#123; fun bar() fun foo() &#123; // 可选的方法体 &#125;&#125; 可见性修饰符 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public， 默认可见性是 public。 可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件： 一个 IntelliJ IDEA 模块； 一个 Maven 或者 Gradle 项目； 一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。 扩展 Kotlin 同 C# 和 Gosu 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。 这通过叫做 扩展 的特殊声明完成。Kotlin 支持 扩展函数 和 扩展属性。 声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面代码为 MutableList 添加一个swap 函数： 12345fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // “this”对应该列表 this[index1] = this[index2] this[index2] = tmp&#125; 数据类 我们经常创建一些只保存数据的类。在这些类中，一些标准函数往往是从 数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为data：data class User(val name: String, val age: Int) 语法实现原理Null Safe Operator实现原理示例函数如下： 123fun testNullSafeOperator(string: String?) &#123; System.out.println(string?.toCharArray())&#125; 生成的字节码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final testNullSafeOperator(Ljava/lang/String;)V @Lorg/jetbrains/annotations/Nullable;() // invisible, parameter 0 L0 LINENUMBER 15 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 1 DUP IFNULL L1 ASTORE 2 ASTORE 3 L2 ALOAD 2 DUP IFNONNULL L3 //非空判断 NEW kotlin/TypeCastException DUP LDC &quot;null cannot be cast to non-null type java.lang.String&quot; INVOKESPECIAL kotlin/TypeCastException.&lt;init&gt; (Ljava/lang/String;)V ATHROW L3 INVOKEVIRTUAL java/lang/String.toCharArray ()[C DUP LDC &quot;(this as java.lang.String).toCharArray()&quot; INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkExpressionValueIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V L4 ASTORE 4 ALOAD 3 ALOAD 4 L5 LINENUMBER 15 L5 GOTO L6 L1 POP ACONST_NULL L6 INVOKEVIRTUAL java/io/PrintStream.println ([C)V L7 LINENUMBER 16 L7 RETURN L8 LOCALVARIABLE this Ltech/jackywang/kotlindemo/Test; L0 L8 0 LOCALVARIABLE string Ljava/lang/String; L0 L8 1 MAXSTACK = 5 MAXLOCALS = 5 反编译为Java代码如下： 1234567891011121314151617181920public final void testNullSafeOperator(@Nullable String string) &#123; PrintStream var10000 = System.out; char[] var10001; if(string != null) &#123; PrintStream var3 = var10000; if(string == null) &#123; throw new TypeCastException(\"null cannot be cast to non-null type java.lang.String\"); &#125; char[] var5 = string.toCharArray(); Intrinsics.checkExpressionValueIsNotNull(var5, \"(this as java.lang.String).toCharArray()\"); char[] var4 = var5; var10000 = var3; var10001 = var4; &#125; else &#123; var10001 = null; &#125; var10000.println(var10001); &#125; 由此可见kotlin实现的非空 ？ 语法，内部就是利用非空判断实现。 与Java互操作Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以很顺利地调用 Kotlin 代码。 空安全和平台类型Java 中的任何引用都可能是 null，这使得 Kotlin 对来自 Java 的对象要求严格空安全是不现实的。 Java 声明的类型在 Kotlin 中会被特别对待并称为平台类型。对这种类型的空检查会放宽， 因此它们的安全保证与在 Java 中相同 12345val list = ArrayList&lt;String&gt;() // 非空（构造函数结果）list.add(\"Item\")val size = list.size() // 非空（原生 int）val item = list[0] // 推断为平台类型（普通 Java 对象）item.substring(1) // 允许，如果 item == null 可能会抛出异常 受检异常在 Kotlin 中，所有异常都是非受检的，这意味着编译器不会强迫你捕获其中的任何一个。 因此，当你调用一个声明受检异常的 Java 方法时，Kotlin 不会强迫你做任何事情： 12345fun render(list: List&lt;*&gt;, to: Appendable) &#123; for (item in list) &#123; to.append(item.toString()) // Java 会要求我们在这里捕获 IOException &#125;&#125; 如何编译？编译入口从kotlinc Hello.kt 开始分析 12345678910111213141516171819202122cygwin=false;case &quot;`uname`&quot; in CYGWIN*) cygwin=true ;;esac...declare -a kotlin_app//运行入口if [ -n &quot;$KOTLIN_RUNNER&quot; ];then java_args=(&quot;$&#123;java_args[@]&#125;&quot; &quot;-Dkotlin.home=$&#123;KOTLIN_HOME&#125;&quot;) kotlin_app=(&quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-runner.jar&quot; &quot;org.jetbrains.kotlin.runner.Main&quot;)else//编译入口 [ -n &quot;$KOTLIN_COMPILER&quot; ] || KOTLIN_COMPILER=org.jetbrains.kotlin.cli.jvm.K2JVMCompiler java_args=(&quot;$&#123;java_args[@]&#125;&quot; &quot;-noverify&quot;) kotlin_app=(&quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-preloader.jar&quot; &quot;org.jetbrains.kotlin.preloading.Preloader&quot; &quot;-cp&quot; &quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-compiler.jar&quot; $KOTLIN_COMPILER)fi&quot;$&#123;JAVACMD:=java&#125;&quot; $JAVA_OPTS &quot;$&#123;java_args[@]&#125;&quot; -cp &quot;$&#123;kotlin_app[@]&#125;&quot; &quot;$&#123;kotlin_args[@]&#125;&quot; 12345678910111213141516171819202122232425fun compileBunchOfSources(environment: KotlinCoreEnvironment): Boolean &#123; val moduleVisibilityManager = ModuleVisibilityManager.SERVICE.getInstance(environment.project) val friendPaths = environment.configuration.getList(JVMConfigurationKeys.FRIEND_PATHS) for (path in friendPaths) &#123; moduleVisibilityManager.addFriendPath(path) &#125; if (!checkKotlinPackageUsage(environment, environment.getSourceFiles())) return false //词法、语法分析、语义分析、目标代码生成等过程 val generationState = analyzeAndGenerate(environment) ?: return false // 找到运行主类 val mainClass = findMainClass(generationState, environment.getSourceFiles()) try &#123; //写入文件 writeOutput(environment.configuration, generationState.factory, mainClass) return true &#125; finally &#123; generationState.destroy() &#125; &#125; 目标代码的生成在代码类生成的过程中，又包括生成类名、类体、字段、函数方法等环节，相关的生成类有ClassBodyCodegen、ClassFunctionCodegen、MemberCodegen、ExpressionCodegen、PropertyCodegen等。 12345678910111213141516171819202122232425262728public class KotlinCodegenFacade &#123; public static void doGenerateFiles( @NotNull Collection&lt;KtFile&gt; files, @NotNull GenerationState state, @NotNull CompilationErrorHandler errorHandler ) &#123; ... for (KtFile file : files) &#123; ... Set&lt;FqName&gt; obsoleteMultifileClasses = new HashSet&lt;FqName&gt;(state.getObsoleteMultifileClasses()); for (FqName multifileClassFqName : Sets.union(filesInMultifileClasses.keySet(), obsoleteMultifileClasses)) &#123; doCheckCancelled(state); //目标代码类生成 generateMultifileClass(state, multifileClassFqName, filesInMultifileClasses.get(multifileClassFqName), errorHandler); &#125; Set&lt;FqName&gt; packagesWithObsoleteParts = new HashSet&lt;FqName&gt;(state.getPackagesWithObsoleteParts()); for (FqName packageFqName : Sets.union(packagesWithObsoleteParts, filesInPackages.keySet())) &#123; doCheckCancelled(state); //目标代码类包生成 generatePackage(state, packageFqName, filesInPackages.get(packageFqName), errorHandler); &#125; doCheckCancelled(state); //生成结束 state.getFactory().done(); &#125;&#125; Kotlin在目标代码生成环节做了更多的处理，在该环节实现了自动生成Getter、Setter的代码。 12345678910111213141516171819202122public class PropertyCodegen &#123; private void gen( @Nullable KtProperty declaration, // 属性声明 @NotNull PropertyDescriptor descriptor, //描述，包括权限修饰符、注解、类型等。 @Nullable KtPropertyAccessor getter, // 决定是否生成getter @Nullable KtPropertyAccessor setter //决定是否生成setter ) &#123; assert kind == OwnerKind.PACKAGE || kind == OwnerKind.IMPLEMENTATION || kind == OwnerKind.DEFAULT_IMPLS : \"Generating property with a wrong kind (\" + kind + \"): \" + descriptor; //生成注解信息 genBackingFieldAndAnnotations(declaration, descriptor, false); //根据注解和权限修饰符等信息判断是否自动生成Getter代码 if (isAccessorNeeded(declaration, descriptor, getter)) &#123; generateGetter(declaration, descriptor, getter); &#125; //根据注解和权限修饰符等信息判断是否自动生成Setter代码 if (isAccessorNeeded(declaration, descriptor, setter)) &#123; generateSetter(declaration, descriptor, setter); &#125; &#125;&#125; Kotlin到Java的迁移成本 文件自动转换，点击菜单栏 Code | Convert Java File to Kotlin File 语法兼容性 第三方库兼容性 Kotlin为Android开发者带来什么改变？ 效率 多平台 参考：Kotlin编译过程分析、研究学习Kotlin的一些方法","categories":[],"tags":[]},{"title":"JVM 答疑解惑","slug":"JVM-答疑解惑","date":"2017-05-11T09:40:00.000Z","updated":"2017-08-08T10:18:32.000Z","comments":true,"path":"2017/05/11/JVM-答疑解惑/","link":"","permalink":"http://yoursite.com/2017/05/11/JVM-答疑解惑/","excerpt":"JVM是什么？平常接触的东西都存在哪里？类如何加载？怎么运行？清洁工怎么工作？","text":"JVM是什么？平常接触的东西都存在哪里？类如何加载？怎么运行？清洁工怎么工作？ JVM是什么？Java 虚拟机屏蔽了与具体操作系统平台相关的信息,使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码),就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时,实际上最终还是把字节码解释成具体平台上的机器指令执行。 Java 虚拟机就像一个熟悉多个国家语言的导游，你只要向他说出自己的语言，他就能带着你在多个国家无障碍的玩耍。比如说，你说“我要吃肉夹馍”，无论到了哪个国家，你只需要和导游说这句话就可以，寻找和本地人交流导游就会帮你办好，最后结果是相同的：吃的都是肉夹馍。 可以参考如下Java技术体系图： 平常接触的东西都存在哪里？先看一下Java虚拟机运行时数据区： 程序计数器程序计数器：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每个线程都有自己的独立的程序计数器。 如果线程正在执行的是Java方法，那么这个计数器的值就是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值为空（undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余的数据类型占1个。局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。如果线程请求栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；无法申请到内存抛出OutOfMemoryError异常。 本地方法栈本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地栈则为虚拟机使用到的Native方法服务。 Java堆Java堆是线程共享的，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 方法区（永久代）线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载！ 运行时常量池他是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 直接内存直接内存不是虚拟机运行时数据区的一部分。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK1.4中新加入了NIO类，引入了一种基于通道与缓存区（buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 类如何加载？在加载阶段，虚拟机需要完成以下 3 件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java. lang. Class 对象，作为方法区这个类的各种数据的访问入口。 Class文件的获取方式： 从 ZIP 包中读取，这很常见，最终成为日后 JAR、 EAR、 WAR 格式的基础。 从网络中获取，这种场景最典型的应用就是 Applet。 运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为*$Proxy 的代理类的二进制字节流。由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。 从数据库中读取。 一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的。开发人员可以通过自定义的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass方法），这里以后可以找一些比较重要的类，分析里面所有的函数，从而知道这些东西怎么用。 对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ Element Type， 指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为 C） 创建过程就遵循以下规则： 如果数组的组件类型（ Component Type， 指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，在 7. 4 节会介绍到，一个类必须与类加载器一起确定唯一性）。 如果数组的组件类型不是引用类型（例如 int[] 数组）， Java 虚拟机将会把数组 C 标记为与引导类加载器关联。 数组类的可见性与它的组件可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认设置为public 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区怎么存储由JVM自己定义。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面）。 加载阶段和连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。 怎么运行？解析解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在 Class 类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。 对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info 四种常量类型。 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 初始化初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 清洁工怎么工作？GC要完成3件事： 哪些内存需要回收？引用计数算法、根搜索算法 什么时候回收？标记—清除算法、标记—整理算法 如何回收？分代收集、垃圾收集器（不同厂商有不同实现）","categories":[],"tags":[]},{"title":"数据库到底哪家强？","slug":"数据库到底哪家强？","date":"2017-04-15T06:24:26.000Z","updated":"2017-04-19T07:18:25.000Z","comments":true,"path":"2017/04/15/数据库到底哪家强？/","link":"","permalink":"http://yoursite.com/2017/04/15/数据库到底哪家强？/","excerpt":"目前大部分开源数据库都是基于SQLite发展而来，如SQLBrite、OrmLite、DBFlow、GreenDao等等，还有一个是Realm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎。那这么多框架到底有什么区别，那种更适合自己的产品呢？","text":"目前大部分开源数据库都是基于SQLite发展而来，如SQLBrite、OrmLite、DBFlow、GreenDao等等，还有一个是Realm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎。那这么多框架到底有什么区别，那种更适合自己的产品呢？ 我们先看基于SQLite发展而来的框架，这方面主要分成两条发展路线，一条是Rx或者叫做对象映射（OM）路线，一条是对象关系映射（ORM）路线。 Rx/对象映射路线代表数据库有sqlbrite、sqldelight，这两个都是Square出品。 SqlBrite和SqlDelight都是对象映射（OM，Object Mappers）而不是对象关系映射（ORM，Object/Relational Mappers）。 ORM 其实并不是一个优秀的框架。很多平台的 ORM 实现都有性能和内存的问题。我们也不会编写ORM。 – JakeWharton 上面这句话很好的说明了这两个框架的出发点，知道这些我们就容易理解了。 SqlBrite SqlBrite是对 Android 系统的 SQLiteOpenHelper 的封装，对SQL操作引入了响应式语义 （Rx）（用来在 RxJava 中使用） 基本用法 创建一个SqlBrite对象，该对象是该库的入口：SqlBrite sqlBrite = SqlBrite.create(); 提供一个 SQLiteOpenHelper实例和一个Scheduler实例来创建一个 BriteDatabase 对象：BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper, Schedulers.io());，Scheduler 是指定执行查询的操作的线程，由于查询数据库是不建议在 UI 线程中执行的，所以一般指定 Schedulers.io() 。 BriteDatabase.createQuery方法和SQLiteDatabase.rawQuery方法相比，多了一个table(s)表参数，用于监听数据变更。当我们订阅subscribe返回的Observable的时候，立刻执行需要的查询语句。 1234567Observable users = db.createQuery(\"users\", \"SELECT * FROM users\");users.subscribe(new Action1() &#123; @Override public void call(Query query) &#123; Cursor cursor = query.run(); // TODO parse data... &#125;&#125;); 优点在保证性能和复杂扩展性的同时，利用Rxjava操作Sql在易用性上有部分提高。 缺点还需要编写Sql语句，复杂性还是较高。 SqlDelight SqlDelight通过从 SQL 语句来生成 JAVA 模型代码。这样的好处是，所有 SQL 语句都位于同一个位置，通过查看 SQL 语句可以清楚的了解需要实现的功能和数据库的结构,也便于管理以及java类访问。 基本用法需要把 SQL 语句放到对应的 .sq 文件中，默认目录为和 main 目录下的 java 代码同级，例如src/main/sqldelight/com/example/HockeyPlayer.sq ，其中 com/example/ 为对应 java 对象的包名字。 在该 .sq 文件中一般第一个语句是创建表的语句： 123456789101112CREATE TABLE hockey_player ( _id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, number INTEGER NOT NULL, name TEXT NOT NULL);-- 其他的语句通过标识符来引用。在生成的 Java 对象中会包含-- 一个该标识符的常亮引用这个语句。select_by_name:SELECT *FROM hockey_playerWHERE name = ?; 上面的 SQL 语句会生成一个 HockeyPlayerModel Java 接口。该接口内有两个嵌套类分别把 Cursor 映射为 Java 对象以及把 Java 对象转换为 ContentValues 好插入数据库 优点 所有的SQL statement都存在.sq文件中，便于管理 可以自由的使用普通SQLite的同时帮助你处理了程式化的代码 缺点需要编写原生sql 总结SqlBrite方便在 RxJava 中使用 Sql 操作，并且额外添加了对数据库表数据更新通知的机制，当你对数据表进行操作的时候，其他订阅者可以在数据发生变化的时候收到通知。然后可以用 RxJava 的方式来操作数据。只是一个 SQLiteOpenHelper 的轻量级封装，并不关心你的对象是如何实现的，也不关心你的数据库。SqlBrite也不支持对象映射和类型安全的查询，SqlBrite 不是一个 ORM 框架，也不是一个类型安全的查询框架。不会提供类似Gson中对象序列化的功能，也不会提供数据库迁移的功能。 SqlDelight 的做法是从 SQL 语句来生成 JAVA 模型代码。 这样的好处是，所有 SQL 语句都位于同一个位置。SqlDelight 添加了对 SQL 语句的编译时验证、表名字和列名字的代码自动完成功能。让编写 SQL 语句更加快捷。在编译的时候，根据 SQL 语句生成 Java 模型接口和 builder 来把数据行和 Java 对象实现转换。SqlDelight 不会做很重的功能（比如数据懒加载、缓存 、级联删除 等 ORM 框架内常见的功能）。 对象关系映射（ORM）路线这部分框架在易用性上和性能上都做了很多工作，易用性上基本达到极致，在性能上接近原生Sql，这里举几个有代表性的项目。 OrmLite OrmLite - Lightweight Object Relational Mapping (ORM) Java Package 基本原理 使用注解方式标示字段，如数据库、表等 运行时使用反射获取相应字段拼接sql去执行 优点在易用性上相比原生sql有较大提高 缺点性能上有损失 greenDAO greenDAO is an open source Android ORM making development for SQLite databases fun again. 基本原理、特点 使用注解方式标示字段 在编译期生成本地sql greenDAO 支持 protocol buffer(protobuf) 协议数据的直接存储，如果你通过 protobuf 协议与服务器交互，将不需要任何的映射。 数据加密 解析 DaoMaster保存了sqlitedatebase对象以及操作DAO classes。其提供了一些创建和删除table的静态方法，其内部类OpenHelper和DevOpenHelper实现了SQLiteOpenHelper并创建数据库的框架。 DaoMaster除了具有创建表和删除表的两个功能外，还有两个内部类，分别为OpenHelper和DevOpenHelper，而DevOpenHelper继承自OpenHelper，而OpenHelper继承自SQLiteOpenHelper，而重写的onCreate()方法中调用了createAllTables(db,false)；方法来创建数据表，而createAllTables()方法中是通过调用UserDao静态方法来创建表的UserDao.createTable(db, ifNotExists)； 123456789101112131415/** Creates the underlying database table. */ public static void createTable(SQLiteDatabase db, boolean ifNotExists) &#123; String constraint = ifNotExists? \"IF NOT EXISTS \": \"\"; db.execSQL(\"CREATE TABLE \" + constraint + \"\\\\\"NOTE\\\\\" (\" + // \"\\\\\"_id\\\\\" INTEGER PRIMARY KEY AUTOINCREMENT ,\" + // 0: id \"\\\\\"TEXT\\\\\" TEXT NOT NULL ,\" + // 1: text \"\\\\\"COMMENT\\\\\" TEXT,\" + // 2: comment \"\\\\\"DATE\\\\\" INTEGER);\"); // 3: date&#125;/** Drops the underlying database table. */public static void dropTable(SQLiteDatabase db, boolean ifExists) &#123; String sql = \"DROP TABLE \" + (ifExists ? \"IF EXISTS \" : \"\") + \"\\\\\"NOTE\\\\\"\"; db.execSQL(sql);&#125; greenDAO的增删改查方法有一些是在Android原生的操作方法上进行了封装，对于链式查询的最终执行也是调用了Android原生的查询操作。 12345public List&lt;T&gt; list() &#123; checkThread(); Cursor cursor = dao.getDatabase().rawQuery(sql, parameters); return daoAccess.loadAllAndCloseCursor(cursor);&#125; 同时还有一些方法是基于SQLiteStatement实现的，SQLiteStatement相比原生的execSQL方法还要快一些，并且最终执行时也开启了事务，性能又提升了很多。下面是插入数据的最终实现方法： 1234567891011121314151617181920212223private long executeInsert(T entity, SQLiteStatement stmt) &#123; long rowId; if (db.isDbLockedByCurrentThread()) &#123; synchronized (stmt) &#123; bindValues(stmt, entity); rowId = stmt.executeInsert(); &#125; &#125; else &#123; // Do TX to acquire a connection before locking the stmt to avoid deadlocks db.beginTransaction(); try &#123; synchronized (stmt) &#123; bindValues(stmt, entity); rowId = stmt.executeInsert(); &#125; db.setTransactionSuccessful(); &#125; finally &#123; db.endTransaction(); &#125; &#125; updateKeyAfterInsertAndAttach(entity, rowId, true); return rowId;&#125; 可以看到先执行bindValues方法，该方法是一个抽象方法，需要业务方在DAO文件中实现，跟踪至NoteDao文件查看该方法代码如下： 1234567891011121314151617181920@Overrideprotected void bindValues(SQLiteStatement stmt, Note entity) &#123; stmt.clearBindings(); Long id = entity.getId(); if (id != null) &#123; stmt.bindLong(1, id); // 1为索引值，id为入库的值 &#125; stmt.bindString(2, entity.getText()); String comment = entity.getComment(); if (comment != null) &#123; stmt.bindString(3, comment); &#125; java.util.Date date = entity.getDate(); if (date != null) &#123; stmt.bindLong(4, date.getTime()); &#125;&#125; 这样就将SQLiteStatement需要的数据都进行了封装，然后执行stmt.executeInsert()方法即可完成数据库的插入操作。整个数据插入流程，greenDAO借助SQLiteStatement完成了数据的插入，避免了其他框架利用反射拼装sql语句而造成的执行效率低下的问题。 其他优化： 避免使用注解和反射拼装sql语句 最终执行时开启了事务 支持异步查询和回调 查询缓存机制，使用了弱引用WeakReference，第一次查询时将数据加入SparseArray&gt;的集合中 优点在易用性和性能上做到了很好的平衡 缺点上手成本 总结ORM类型框架在易用性上面做的比原生Sql提升了很多，而且在性能上GreenDao在某些方面甚至比原生的还要出色，比较适合大部分项目的开发工作。 RealmRealm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎，在某些方面有自己独特的优势。 GreenDao vs Realm 基本用法增： 1234567Realm realm=Realm.getDefaultInstance();realm.beginTransaction();User user = realm.createObject(User.class); // Create a new objectuser.setName(\"John\");user.setEmail(\"john@corporation.com\");realm.commitTransaction(); 删： 1234567891011121314151617181920Realm mRealm=Realm.getDefaultInstance(); final RealmResults&lt;Dog&gt; dogs= mRealm.where(Dog.class).findAll(); mRealm.executeTransaction(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; Dog dog=dogs.get(5); dog.deleteFromRealm(); //删除第一个数据 dogs.deleteFirstFromRealm(); //删除最后一个数据 dogs.deleteLastFromRealm(); //删除位置为1的数据 dogs.deleteFromRealm(1); //删除所有数据 dogs.deleteAllFromRealm(); &#125; &#125;); 优点 易用 快速 跨平台 可视化 缺点 显著增加安装包大小，增加大概4、5兆 数据类型限制，必须继承RealmObject、不支持内部类、修改了部分类型、不支持键值自增长。 线程限制，如果在UI线程获取到了当前Realm对象，在异步线程中使用当前Realm对象进行操作，就会抛出异常。 总结如果数据量没有达到SQLite的性能瓶颈的话，建议选择基于SQLite的数据库，如果不喜欢编写原生Sql语句就牺牲一点性能去适应业务快速迭代。这些框架同时存在都有其道理，性能有优势兼容性和稳定性不能保证，易用性很好必然就不能做太多的定制化操作，各取所需，对于一般的业务GreenDao便是一个比较好的方案。","categories":[],"tags":[]},{"title":"Android模块化与组件化--多模块区分编译","slug":"Android模块化与组件化-多模块区分编译","date":"2017-02-03T10:28:18.000Z","updated":"2017-02-07T06:55:02.000Z","comments":true,"path":"2017/02/03/Android模块化与组件化-多模块区分编译/","link":"","permalink":"http://yoursite.com/2017/02/03/Android模块化与组件化-多模块区分编译/","excerpt":"有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？","text":"有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？ 模块化与组件化–多模块区分编译 示例地址：https://github.com/JackyAndroid/Android-Architecture-Fairy/tree/master/multi-variants-libraryAndroid-Architecture-Fairy开源项目重点分析主流技术与架构设计，欢迎star 有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？先看下官方文档如下： By default a library only publishes its release variant. This variant will be used by all projects referencing the library, no matter which variant they build themselves. This is a temporary limitation due to Gradle limitations that we are working towards removing. You can control which variant gets published:123android &#123; defaultPublishConfig \"debug\"&#125; Note that this publishing configuration name references the full variant name. Release and debug are only applicable when there are no flavors. If you wanted to change the default published variant while using flavors, you would write:123android &#123; defaultPublishConfig \"flavor1Debug\"&#125; It is also possible to publish all variants of a library. We are planning to allow this while using a normal project-to-project dependency (like shown above), but this is not possible right now due to limitations in Gradle (we are working toward fixing those as well).Publishing of all variants are not enabled by default. The snippet below enables this feature:123android &#123; publishNonDefault true&#125; It is important to realize that publishing multiple variants means publishing multiple aar files, instead of a single aar containing multiple variants. Each aar packaging contains a single variant. Publishing a variant means making this aar available as an output artifact of the Gradle project. This can then be used either when publishing to a maven repository, or when another project creates a dependency on the library project. Gradle has a concept of default” artifact. This is the one that is used when writing:123dependencies &#123; compile project(':libraries:lib2')&#125; To create a dependency on another published artifact, you need to specify which one to use:1234dependencies &#123; flavor1Compile project(path: ':lib1', configuration: 'flavor1Release') flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')&#125; Important: Note that the published configuration is a full variant, including the build type, and needs to be referenced as such.Important: When enabling publishing of non default, the Maven publishing plugin will publish these additional variants as extra packages (with classifier). This means that this is not really compatible with publishing to a maven repository. You should either publish a single variant to a repository OR enable all config publishing for inter-project dependencies. 默认Library只发布Release版本，这个是Gradle官方的限制，Google官方正在试图解决这个问题。可以使用defaultPublishConfig去设置发布的版本，通过设置publishNonDefault true可以让Library发布多个产品版本。下面的这种平常书写的方式是依赖的默认发布版本：123dependencies &#123; compile project(':libraries:lib2')&#125; 如果想要分渠道编译多种形态的Library，需要修改如下的方式：1234dependencies &#123; flavor1Compile project(path: ':lib1', configuration: 'flavor1Release') flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')&#125; 注意事项： 编译的配置是产品名称的全称加编译类型，如：flavor1Release 如果Library是Maven的公开库最好不要使用这种特性 产品名称首字母要小写，否则会有语法问题 如果Gradle里面有使用MultiDex选项会生成多个aar","categories":[],"tags":[]},{"title":"来，谷歌安卓浏览器源码就在这！","slug":"来，谷歌安卓浏览器源码就在这！","date":"2017-02-03T09:49:37.000Z","updated":"2017-02-07T06:52:29.000Z","comments":true,"path":"2017/02/03/来，谷歌安卓浏览器源码就在这！/","link":"","permalink":"http://yoursite.com/2017/02/03/来，谷歌安卓浏览器源码就在这！/","excerpt":"谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star","text":"谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star 欢迎在GitHub或者CSDN上关注我GitHub: https://github.com/JackyAndroid CSDN: http://blog.csdn.net/rain_butterfly AndroidChromium AndroidChromium源码地址如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash） 简介 谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star 效果图 以下是升级chrome内核注意事项，如不是相关人员可以忽略 准备参考官方及其他教程编译通过chromium源码，并能生成chrome.apk 目的使用AndroidStudio开发环境调试Chromium Android UI层。 构建思路 采用Android Studio作为开发环境，从Chromium for Android抽取chrome模块的源码，加入Android project。 native代码在chromium环境中build，作为so加入Android project 基础模块(base, content, net等)在chromium环境build为jar包，加入Android project content, chrome, ui等模块的资源文件加入Android library project 资源文件为什么不能直接都添加到Android project呢？因为命名空间的原因，比如content模块的资源的命名空间为org.chromium.content, chrome模块的资源的命名空间为 org.chromium.chrome，所以需要建立不同的Android library project, 指定不同的包名。 本项目和源码目录对应关系app/libs ———– chromium/src/out/Release/lib.java app/src/main/aidl ———– chromium/src/chrome/android/java/src/android/support/customtabs/*.aidl app/src/main/assets ———– chromium/src/out/Release/assets/chrome_public_apk app/src/main/java ———— chromium/src/chrome/android/java/src app/src/main/jniLibs ———– chromium/src/out/Release/chrome_public_apk/libs app/src/main/res（app module 初始化资源） libraries/androidmedia_res ———– chromium/src/third_party/android_media/java/res libraries/chrome_res ———– chromium/src/chrome/android/java/res &amp; chromium/src/chrome/android/java/res_chromium libraries/content_res ———– chromium/src/content/public/android/java/res libraries/datausagechart_res ——— chromium/src/third_party/android_data_chart/java/res libraries/ui_res ———- chromium/src/ui/android/java/res 建议&amp;注意事项 pak和dat等文件需要加入到assets目录，而且不能压缩 aidl文件加入到main/aidl下，android studio会自动处理 目前构建的chromium版本是48.0.2554.0，内核为官方版本 因为某些java文件是通过C文件编译生成，只存在chromium/src/out 目录下。如果按以上对应关系升级版本缺失文件，请到out/目录下去搜索，根据命名空间添加相应文件。还有一些临时生成的xml资源文件也需要从out/目录下去拷贝到相应的资源模块。 如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash） 感谢本项目灵感来自于365browser LicenseCopyright 2016 Jacky Wang&lt;jacky.android@foxmail.com&gt; Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","categories":[],"tags":[]},{"title":"Android Framework是怎么启动的？","slug":"Android-Framework是怎么启动的？","date":"2017-02-03T09:47:48.000Z","updated":"2017-02-07T06:56:09.000Z","comments":true,"path":"2017/02/03/Android-Framework是怎么启动的？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-Framework是怎么启动的？/","excerpt":"安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。","text":"安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。 Android Framework运行环境是怎样的？安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。 Framework运行环境如下图： 安卓系统中运行的第一个Dalvik虚拟机叫做zygote，这个的意思是“卵”，那有什么卵用呢？听这个词的意思就知道是孵化的意思，接下来所有的Dalvik虚拟机进程都是这个“卵”孵化出来的。 zygote进程中包含两个主要模块，分别如下： Socket服务端。任务是用于接收启动新的Dalvik进程的命令。 Framework共享类及共享资源。当zygote进程启动后会加载一些共享的类及资源，就像营养液一样，供其他的细胞吸收。其中共享类是在preload-classes文件中被定义的，共享资源是在preload-resources中被定义的。其他Dalvik进程是被zygote卵进程孵化出来的，所以这些类和资源加载后，新的Dalvik进程就可以直接使用这些类和资源就达到了共享目的，就像一个细胞分裂成两个，共享一些基因和营养。 zygote进程对应的程序是app_process,该程序在system/bin目录下。 zygote孵化出的第一个Dalvik进程是SystemServer，该进程对应的程序依然是app_process,因为该进程是从app_process中孵化出来的。 SystemServer中创建了一个Socket客户端（生产线经理），之后所有的Dalvik进程都将通过该Socket客户端间接被启动，Ams负责管理这个客户端。如果需要启动新的APK进程时，Ams会通过该Socket客户端向zygote进程的Socket服务端（生产线工人）发送一个启动命令，然后zygote会孵化出新的进程（产品生产成型）。 这样的架构有两个特点： 每一个进程都是一个Dalvik虚拟机，Dalvik虚拟机是一种类似于java虚拟机的程序。 zygote进程会预先装载共享类和共享资源，提供营养液和基因，这些类和资源其实就是SDK中定义的大部分类和资源。当通过zygote孵化出新进程后，新的APK只需要去加载APK自身包含的类和资源，这样多个APK就可以共享Framework资源了。 和Dalvik虚拟机关系比较好的可执行程序有哪些？1.dalvikvmjava程序运行时都是由一个虚拟机来解释java字节码，将这些字节码翻译成本地CPU指令码然后执行。dalvikvm的作用就是创建一个虚拟机并执行参数中指定的java类。 2.dvzdvz的作用是从zygote进程中孵化出一个新的进程，新进程其实就是一个Dalvik虚拟机。该进程与dalvikvm启动的虚拟机相比，区别是该进程中已经预装了Framework的大部分类和资源。 3.app_processFramework在启动时需要加载运行两个特定java类，一个是ZygoteInit.java，一个是SystemServer.java。为了方便使用，系统才提供了一个app_process进程，该进程会自动运行这两个类，app_process其实就是使用dalvikvm启动ZygoteInit.java，启动后会加载Framework中得大部分类和资源。 Zygote是如何启动的？1.在init.rc中配置Zygote启动参数2.启动Socket服务端口当Zygote服务从app_process开始启动后，会启动一个Dalvik虚拟机，虚拟机第一个执行的java类就是ZygoteInit.java，该类第一个重要的工作就是启动一个Socket服务端口，该Socket端口用于接收启动新进程的命令。 3.加载preload-classes在Zygote类的main（）函数中，创建完Socket服务端后还不能立即孵化出新的进程，因为这个“卵”还没有必须的“基因”，这个“基因”就是指预装的Framework大部分类及资源。 4.加载preload-resourcespreload-resources包含两类资源，一类是drawable资源，一类是color资源。加载这些资源是在preloadResource（）函数中完成的，该函数调用preloadDrawable（）和preloadColorStateLists（）加载这两类资源，原理就是把这些资源读出来放到一个全局变量中，只要该类对象不被销毁，这些全局变量就会一直保存。 5.使用fork启动新的进程fork是Linux系统的一个系统调用，作用就是复制当前进程产生一个新的进程，相当于生物的克隆。除了进程id不同，新进程将拥有和原始进程完全相同的进程信息。进程的信息包括该进程所打开的文件描述符列表、所分配的内存等。当新进程被创建后，两个进程将共享已经分配的内存空间，如果其中一个需要向内存中写入数据时，操作系统才复制一份目标地址空间，并将要写的数据写入到新的地址中。这种“仅当写的时候才复制”的机制可以最大限度的在多个进程中共享物理内存。 举个栗子：去乌镇见一下习大大和去乌镇吃一次丁磊的猪肉，这是两个进程，但是两个进程中的很多任务是相同的，先订机票，做地铁到机场，做几小时飞机过去。到了之后不同的就是见习大大和吃猪肉。如果可以先雇一个秘书进程让它订机票、做地铁、做飞机，到乌镇。然后秘书在复制出两个秘书，一个去见习大大，一个去吃猪肉，好处是节省了大量内存。 Zygote进程就是本例中的“秘书进程”，那些“订机票、做地铁、乘飞机”就是Zygote进程中加载的preload-classes类的功能。 这样新的进程就脱离的Zygote进程的孵化成为一个真正的应用进程。 SystemServer 进程是如何启动的？SystemServer进程是Zygote孵化出的第一个进程，然后再配置SystemServer进程的环境。 1.启动各种系统服务线程SystemServer进程在Android运行环境中扮演了“神经中枢”的作用，APK应用中能够直接交互的大部分系统服务都在该进程中运行，常见的有WindowManagerServer（Wms）、ActivityManagerService（Ams）、PackageManagerServer（Pms），这些系统服务都是以一个线程的方式存在于SystemServer进程中。 2.启动第一个Activity当以上服务线程都启动后，其中Ams服务是systemReady（）调用完成最后启动的，在Ams的systemReady（）函数的最后一段代码则发出了启动任务队列中最上面一个Activity消息。 在Ams的startHomeActivityLocked（）中，系统发出了一个category字段包含CATEGORY_HOME的intent，代码如下： 1234intent.setComponent(mTopComponent);if(mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL)&#123;intent.addCategory(Intent.CATEGORY_HOME);&#125; 只要应用声明自己能够响应该Intent，那么就可以被认为是Home程序。当系统中有多个程序能够响应该Intent时，系统会弹出一个对话框，让用户选择启动哪个程序，也允许用户记住该选择。 到此第一个Activity就启动了。 如有问题请留言，转载请注明出处。","categories":[],"tags":[]},{"title":"Android 一个窗口是怎么创建出来的？","slug":"Android-一个窗口是怎么创建出来的？","date":"2017-02-03T09:46:19.000Z","updated":"2017-02-07T06:52:58.000Z","comments":true,"path":"2017/02/03/Android-一个窗口是怎么创建出来的？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-一个窗口是怎么创建出来的？/","excerpt":"在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。","text":"在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。 前言在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。 WmS并不在意该窗口是哪个应用程序的，关心的是活跃窗口，WmS按一定得规则判断哪个窗口处于活动状态，然后把用户消息给W类，W类再把用户消息传递给内部View变量，然后再由View对象完成剩下的消息处理。 窗户有几种类型？Framework定义了三种窗口类型，三种窗口类型的定义在WindowManager类里面。 应用窗口。应用窗口一般指该窗口对应一个Activity，由于加载Activity是由Ams完成的，所以对于应用程序创建应用类窗口只能在Activity内部完成。 子窗口。子窗口是指该窗口必须要有一个父窗口，父窗口可以是一个应用类窗口也可以是任何其他的窗口。 系统窗口。系统窗口不需要对应任何Activity，也不需要有父窗口。应用程序是没有办法创建系统窗口的，只有系统进程可以创建系统窗口。 那么该怎么创建应用窗口呢？1.每个应用类窗口都对应一个Activity对象，所以创建应用类窗口需要创建Activity对象。当AmS要启动某个Activity时就会通知客户端进程，每个客户端进程都对应一个ActivityThread类，所以需要ActivityThread启动Activity。 启动某个Activity实际是构造一个Activity对象，使用ClassLoader从程序文件中装载指定的Activity对应的Class文件。 2.创建完成Activity对象后调用Activity的attach（）方法，attach（）的作用就是为刚刚创造好的Activity设置内部变量。 3.为该Activity创建Window对象。 4.给Window对象中的mWindowManager变量赋值。 5.然后就需要给该窗口添加真正的View或者ViewGroup。从performLaunchActivity（）调用callActivityOnCreate（）开始，然后经一系列调用到Activity的onCreate（）方法，在onCreate（）方法中调用setContentView（）方法实际是调用了其对应的Window对象的setContentView（）方法。 6.接着会调用到PhoneWindow的setContentView，首先调用installDecor（）为Window类添加窗口装饰，其实就是标题栏，程序中设置的layout.xml界面被包含在窗口装饰中，就是窗口内容。窗口装饰也是ViewGroup，窗口装饰和它内部的内容加起来就是我们所说的窗口，或者叫做Window界面。 7.把创建的窗口通知WmS，让WmS把窗口显示在屏幕上。当Activity准备好后会通知Ams，然后Ams经过一系列调用到Activity的makeVisible（），该方法将真正完成把窗口添加进Wms中。 8.在makeVisible方法中，首先获得该Activity内部的WindowManager对象，然后调用该对象的addView（）方法。 9.调用WindowManagerImpl的addView（）方法，流程如下： 检查添加的窗口是否已经添加过，不能重复添加。 如果添加的窗口是子窗口类型，找到父窗口并保存在临时变量panelParentView中，该变量作为后面调用ViewRoot的setView（）参数。 创建一个新的ViewRoot 调用ViewRoot的setView（）。 10.完成新建一个ViewRoot对象后，需要把新建的ViewRoot对象添加到mRoots对象中。 11.调用ViewRoot对象的setView方法。流程如下： 给ViewRoot的重要变量赋值。 调用requestLayout（），发出界面重绘请求。 调用sWindowSession.add（），通知Wms添加窗口。 创建子窗口或系统窗口过程和上面的类似。","categories":[],"tags":[]},{"title":"Android Context 到底是什么？","slug":"Android-Context-到底是什么？","date":"2017-02-03T09:44:37.000Z","updated":"2017-02-07T06:56:39.000Z","comments":true,"path":"2017/02/03/Android-Context-到底是什么？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-Context-到底是什么？/","excerpt":"一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。","text":"一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。 什么是Android Context？一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。 那么从安卓程序的角度来看，Context是什么？其实一个Activity就是一个Context，一个Service也是一个Context。 一个应用程序可以认为是一个约会环境，用户在这个环境中会切换到不同的场景，比如先去有情调的饭店吃饭，再去电影院看个电影，然后再去xxx（此处省略一万字…）。 Activity类的确是基于Context，而Service类也是基于Context。Activity除了基于Context类外，还实现了一些其他重要的接口，从架构设计的角度看，interface仅仅是某些功能，而extends才是类的本质，即Activity的本质是一个Context，其所实现的其他接口只是为了扩充Context的功能而已，扩充后的类称之为一个Activity或Service。 一个应用程序中应该有多少个Context对象我们在应用程序开发中经常会调用Context的一些方法，这些方法看起来似乎会返回一些全局的对象，而不仅仅是某个Activity，可能会有点疑问，一个应用程序到底有多少个Context对象呢？比如，Context.getResources（）返回该应用程序所对应的Resource类对象，无论从哪个Activity中调用，都会返回同一个Resource对象。 一个Activity就是一个场景（Context），一个Service也是一个场景，所以，应用程序中有多少个Activity或者Service就会有多少个Context对象，也就是有多少个场景。 getResource（）等方法返回的是同一个全局对象。 Context 继承关系是怎么样的呢？ Context类本身是一个纯abstract类。为了使用方便又定义了Context包装类-ContextWrapper，穿上了一身装备显得也比较强大，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中有attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象。 ContextThemeWrapper内部包含了与主题相关的接口，这里的主题就是指在AndroidManifest.xml中通过android：theme为Application或者Activity指定的主题。 只有Activity才需要主题，Service默默的后台工作者不需要穿的那么鲜艳，所以Service直接继承于ContextWrapper。 ContextImpl类真正实现了Context中所有的函数，真正的八块腹肌，我们所调用的各种Context类的方法其实实现均来自于该类。 什么时候创建的Context?每一个应用程序在客户端都是从ActivityThread类开始的，创建Context对象也是在该类中完成，具体创建ContextImpl类的地方一共有6处： PackageInfo.makeApplication（） performLaunchActivity（） handleCreateBackupAgent（） handleCreateService（） handleBindApplication（） attach（） 其中attach（）方法仅在Framework进程启动时调用，应用程序运行时不会调用到该方法。 Application对应的Context程序第一次启动时，会辗转调用到makeApplication（）方法。具体代码如下： 1234ContextImpl appContext = new ContextImpl();appContext.init(this,null,mActivityThread);....appContext.setOuterContext(app); Activity对应的Context启动Activity时，Ams会通过IPC调用到ActivityThread的scheduleLaunchActivity（）方法，该方法包含两种参数。一种是ActivityInfo，这是一个实现了Parcelable接口的数据类，意味着该对象是Ams创建的，并通过IPC传递到ActivityThread；另一种是其他的一些参数。 scheduleLaunchActivity（）方法中会根据以上两种参数构造一个本地ActivityRecord数据类，ActivityThread内部会为每一个Activity创建一个ActivityRecord对象，并使用这些数据对象来管理Activity。 然后会调用handleLaunchActivity（），再调用performLaunchActivity（），该方法中创建ContextImpl的代码如下： 123ContextImpl appContext = new ContextImpl();appContext.init(r.packageInfo,r.token,this);appContext.setOuterContext(activity); 在performLaunchActivity（）开始执行时，会为r.packageInfo变量赋值。r.packageInfo对象的PackageInfo对象和Application对应的packageInfo对象是同一个。 Service对应的Context启动Service时，Ams会通过IPC调用到ActivityThread的scheduleCreateService（）方法，该方法也包含两种参数。第一种是ServiceInfo，这是实现了一个Parcelable接口的数据类，该对象由AmS创建，并通过IPC传递到ActivityThread内部；第二种是其他参数。 在scheduleCreateService（）方法中，会使用以上两种参数构造一个CreateServiceData的数据对象，ActivityThread会为其所包含的每一个Service创建该数据对象，并通过这些对象来管理Service。 然后在执行handleCreateService（）方法，创建ContextImpl对象代码如下： 1234ContextImpl appContext = new ContextImpl();appContext.init(packageInfo,null,this);...appContext.setOuterContext(service); Service对应的Context对象内部的mPackageInfo与Activity、Application中是完全相同的。 这几个Context之间的关系从以上可以看出，创建Context对象的过程基本上是相同的，不同的仅仅是针对Application、Activity、Service使用了不同的数据对象。 一个应用程序包含的Context个数应该为：Context个数 = Service个数+Activity个数+1，最后的1是Application类本身也会对应一个Context对象。 应用程序中包含多个ContextImpl对象，而内部变量mPackageInfo却指向同一个PackageInfo对象，这种设计结构一般意味着ContextImpl是一种轻量级类，而PackageInfo是一个重量级类。事实上确实是这样，ContextImpl中的大多数进行包操作的重量级函数实际上都是转向了mPackageInfo对象相应的方法，也就是事实上调用了同一个PackageInfo对象。","categories":[],"tags":[]},{"title":"我眼中的Android Framework","slug":"我眼中的Android-Framework","date":"2017-02-03T09:40:58.000Z","updated":"2017-02-07T06:53:19.000Z","comments":true,"path":"2017/02/03/我眼中的Android-Framework/","link":"","permalink":"http://yoursite.com/2017/02/03/我眼中的Android-Framework/","excerpt":"在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言","text":"在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言 我眼中的Android Framework在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言 任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。Android framework包含三个小伙伴：服务端、客户端、linux驱动。 服务端 服务端主要包含两个狠重要的类：WindowManagerService（WMS）和ActivityManagerService（AMS） 客户端客户端包含以下类： ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是UI线程或者称为主线程。 Activity：ActivityThread会根据用户的操作选择让哪个Activity对象上它的船。 PhoneWindow：富二代，继承于牛气的Window类，自己屋里住着一个DecorView对象，像它老爸喜欢制定规则提供了一些通用窗口操作API。 Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作API。它不喜欢被人管所以呢，注意：WindowManagerService管理的窗口不是Window类，其实是View和ViewGroup。 DecorView：很能干的家伙，家产来自FrameLayout，比较注重外在喜欢打扮，DecorView是对FrameLayout进行了一些修饰，从名字就可以看出来。 ViewRoot：小管家继承于Handler，主要作用是把WMS的IPC调用转换为本地的一个异步调用。 W类：ViewRoot小助手，继承于binder，是ViewRoot内部类。主要帮助ViewRoot实现把WMS的IPC调用转换为本地的一个异步调用。 WindowManager：客户端如果想创建一个窗口得先告诉WindowManager一声，然后它再和WindowManagerService交流一下看看能不能创建，客户端不能直接和WMS交互。 Linux驱动 Linux驱动和Framework相关的主要是两个部分：画家SurfaceFlingger和快递员Binder。 每一个窗口都对应一个画Surface，SF主要是把各个Surface显示到同一屏幕上。Binder是提供跨进程的消息传递。 从apk程序的运行过程去看看上面各个组件在啥时候干啥活的ActivityThread从main()函数中就开始动起来，然后调用prepareMainLooper()为UI线程创建一个消息快递通道即MessageQueue。 接着创建ActivityThread对象，创建过程会创建一个消息装卸工Handler对象和一个快递员Binder对象，其中Binder负责接收远程Ams的IPC调用，接收到调用后让Handler把消息装到消息快递队列，UI线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。 然后UI线程让队列调用Looper.loop()方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。 当ActivityThread接收到Ams发送start某个Activity的快递后就会创建指定的Activity对象。Activity会先按窗户再去按玻璃和贴窗花，所以先创建PhoneWindow-&gt;DecorView-&gt;创建相应的View或ViewGroup。创建完成后就可以让大家欣赏了，调用WindowManager把界面显示到屏幕上，然后创建ViewRoot，然后调用Wms提供的远程接口添加一个窗口并显示到屏幕上。 接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用Wms中的相应函数处理该消息。 很多线程是不是很晕？ 安卓程序中都有哪些线程？ 客户端小伙伴至少包含三个线程小弟，Activity启动后会创建一个ViewRoot.W对象，同时ActivityThread会创建一个ApplicationThread对象，这两个对象继承消息总管Binder，每个Binder对应一个线程，负责接收Linux Binder驱动发送的IPC调用。还有一个是UI线程呗。 UI线程是什么？ 一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。 自定义的线程和UI线程有什么区别？ UI线程是从ActivityThread运行的，在该类的main()方法中已经使用了Looper.prepareMainLooper()为该线程添加了Looper对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在Activity中去定义Handler对象，因为创建Handler对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的Thread则没有默认创建消息队列，所以不能直接在Thread中直接定义Handler，这个就是我们不懂程序运行原理导致的困惑。","categories":[],"tags":[]},{"title":"Android 设计模式-单例模式","slug":"Android-设计模式-单例模式","date":"2017-02-03T09:35:12.000Z","updated":"2017-02-07T06:57:10.000Z","comments":true,"path":"2017/02/03/Android-设计模式-单例模式/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-设计模式-单例模式/","excerpt":"什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用","text":"什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用 Android 设计模式-单例模式什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用 设计单例模式1234567891011public class Singleton&#123;private static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123;if(mSingleton == null)&#123; mSingleton = new Singleton();\\\\A &#125; return mSingleton; &#125;&#125; 上面的做法在多线程的时候会出现问题，比如有两个线程同时调用getInstance(),这时会new两个对象出来。 单例模式改进112345678910111213public class Singleton&#123;private static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; synchronized(Singleton.class)&#123; if(mSingleton == null)&#123; mSingleton = new Singleton();\\\\A &#125; return mSingleton; &#125; &#125;&#125; 这种方式还是会有问题，就是高并发情况下多线程去抢夺锁，假如有几百个线程，其中有一个运气比较差，这个线程就会出现一直去getInstance，资源一直返回不回去，UI也不会得到更新。 单例模式改进21234567891011121314public class Singleton&#123;private volatile static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; if(mSingleton == null)&#123;\\\\A synchronized(Singleton.class)&#123;\\\\C if(mSingleton == null) mSingleton = new Singleton();\\\\B &#125; &#125; return mSingleton; &#125;&#125; 注：volatile是防止cpu进行指令重排序，防止代码顺序被更改。这种方式比较好的地方在于第一次创建实例时候就会同步所有的线程，以后再获取实例就会直接返回。 但是看代码好像还是有人会有疑问，为什么需要两次判断为null？其实这个意义在于防止多个线程同时进入第一个if内，比如说线程A执行到A行，线程B执行到B行，线程B还没有返回。当线程A执行到C行，这时线程B初始化实例完毕，如果没有里面的再一次判断就会生成两个实例！所以两次的判断null还是有意义的。","categories":[],"tags":[]},{"title":"东半球最好的TV桌面开源项目","slug":"东半球最好的TV桌面开源项目","date":"2017-02-03T09:14:46.000Z","updated":"2017-02-07T06:53:33.000Z","comments":true,"path":"2017/02/03/东半球最好的TV桌面开源项目/","link":"","permalink":"http://yoursite.com/2017/02/03/东半球最好的TV桌面开源项目/","excerpt":"这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。","text":"这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。 欢迎在GitHub或者CSDN上关注我GitHub: https://github.com/JackyAndroid CSDN: http://blog.csdn.net/rain_butterfly AndroidTVLauncher 这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。 注意CatLauncher(Leanback风格) 目前功能已基本稳定，后续会跟进官方Leanback库的进展，Compatible桌面理论上不再维护 特性 Leanback风格 图片展示 视频直播（节操播放器-基于ijkplayer） 媒体详情 第三方应用列表 桌面特殊功能 效果图 下一步的改进 跟进官方Leanback库新功能 LicenseApache License, Version 2.0","categories":[],"tags":[{"name":"AndroidTV,开源","slug":"AndroidTV-开源","permalink":"http://yoursite.com/tags/AndroidTV-开源/"}]}]}