{"meta":{"title":"墨镜猫","subtitle":null,"description":"求知若渴，大智若愚","author":"Jacky","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-01-26T03:45:19.000Z","updated":"2017-04-22T09:02:28.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 从事Android开发四年左右，自认为是一名技术极客。热爱开源，乐于分享。前乐视架构师。 小成就 CSDN博客专家 Github星榜中国区前20 Facebook、微软面试邀请 社交信息 CSDN：http://blog.csdn.net/rain_butterfly Github：https://github.com/JackyAndroid 掘金：https://gold.xitu.io/user/562dc7cc60b20fc9817962a2 微博：http://weibo.com/u/5885816355 微信：sunglasses_cat"},{"title":"虽然假期过去了，但一定不要再次辜负你的新年愿望","date":"2017-02-04T08:40:56.000Z","updated":"2017-05-31T02:57:21.000Z","comments":true,"path":"plan/index.html","permalink":"http://yoursite.com/plan/index.html","excerpt":"","text":"我们每个人在过去 12 个月都有大把机会去反省自己的缺点，但鲜少有人能努力提前完成理想转变。 近期计划 [ ] JVM 原理 [ ] Dalvik 原理 [ ] RxJava 源码解析 [ ] OkHttp 源码解析 [ ] Glide 源码解析 [ ] DroidPlugin 源码解析 [ ] Dynamic-load-apk 源码解析 [ ] Tinker 源码解析 [ ] Atlas 源码解析 书单 Android源码设计模式解析与实战 Android源代码情景分析 简明python教程 失控 科技想要什么 必然 幽默沟通 健康 每周2-3次锻炼 不加班 自我成长 参加付费课程 学会与他人高效充分的沟通，锻炼自己演讲能力 锻炼商业分析能力 旅行2-3次"}],"posts":[{"title":"关于Kotlin需要知道的一切","slug":"关于Kotlin需要知道的一切","date":"2017-06-12T06:16:18.000Z","updated":"2017-06-14T09:40:11.000Z","comments":true,"path":"2017/06/12/关于Kotlin需要知道的一切/","link":"","permalink":"http://yoursite.com/2017/06/12/关于Kotlin需要知道的一切/","excerpt":"前世今生有什么样的语法？语法是怎么实现的？如何编译的？迁移成本为我们带来什么改变？","text":"前世今生有什么样的语法？语法是怎么实现的？如何编译的？迁移成本为我们带来什么改变？ 前世今生设计出发点 Concise — 简洁 Safe — 安全 Interoperable — 协作 目标Statically typed programming language for modern multiplatform applications静态类型编程语言用于现代多平台应用 有什么样的语法？语法对比 Kotlin vs Java kotlin Java 函数 fun sum(a: Int, b: Int): Int { return a + b } public int sum(int a, int b) {return a + b;} 变量 var a: Int = 1 int a = 1; 非空判断 text?.let { val length = text.length } if (text != null) { int length = text.length(); } 开关 var grade = when (score) {1, 2 -&gt; “Excellent” } String grade; switch (score) { case 1: case 2: grade = “Excellent”; break; } 基础数字 数字没有隐式拓宽转换，如 Java 中 int可以隐式转换为long 使数字常量更易，val oneMillion = 1_000_000 对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如:val x = (1 shl 2) and 0x000FF000，shl:有符号左移 and:位与 字符 字符用 Char 类型表示，它们不能直接当作数字，但可以显示转换 模板：val i = 10 val s = “i = $i” // 求值结果为 “i = 10” 控制流 If：是一个表达式，即它会返回一个值，没有三元运算符，使用if表达：val max = if (a &gt; b) a else b When：取代了类 C 语言的 switch 操作符，简单形式如下： 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; // 注意这个块 print(\"x is neither 1 nor 2\") &#125;&#125; when 既可以被当做表达式使用也可以被当做语句使用。可以用任意表达式（而不只是常量）作为分支条件： 1234when (x) &#123; parseInt(s) -&gt; print(\"s encodes x\") else -&gt; print(\"s does not encode x\")&#125; 返回和跳转 跳转表达式都可以用作更大表达式的一部分：val s = person.name ?: return 标签：我们可以用标签限制 break 或者continue： 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125; 类和对象类 类声明：Kotlin 中所有的类默认都是 final，由类名、类头（指定其类型参数、主 构造函数等）和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。通常如下： 12class Invoice &#123;&#125; 实例：val invoice = Invoice()，Kotlin 并没有 new 关键字。 覆盖：Kotlin力求清晰显式。与 Java 不同，Kotlin 需要显式 标注可覆盖的成员。如：override、open 静态方法：Kotlin 中类没有静态方法。建议简单地使用包级函数。 属性和字段 声明一个属性的完整语法是： 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 例： 12345var stringRepresentation: String get() = this.toString() set(value) &#123; setDataFromString(value) // 解析字符串并赋值给其他属性 &#125; 接口 Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有 属性但必须声明为抽象或提供访问器实现。 使用关键字 interface 来定义接口 123456interface MyInterface &#123; fun bar() fun foo() &#123; // 可选的方法体 &#125;&#125; 可见性修饰符 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public， 默认可见性是 public。 可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件： 一个 IntelliJ IDEA 模块； 一个 Maven 或者 Gradle 项目； 一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。 扩展 Kotlin 同 C# 和 Gosu 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。 这通过叫做 扩展 的特殊声明完成。Kotlin 支持 扩展函数 和 扩展属性。 声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面代码为 MutableList 添加一个swap 函数： 12345fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // “this”对应该列表 this[index1] = this[index2] this[index2] = tmp&#125; 数据类 我们经常创建一些只保存数据的类。在这些类中，一些标准函数往往是从 数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为data：data class User(val name: String, val age: Int) 语法实现原理Null Safe Operator实现原理示例函数如下： 123fun testNullSafeOperator(string: String?) &#123; System.out.println(string?.toCharArray()?.getOrNull(10)?.hashCode())&#125; 生成的字节码如下： 12345678910111213141516171819202122232425262728293031public final static testNullSafeOperator(Ljava/lang/String;)V @Lorg/jetbrains/annotations/Nullable;() // invisible, parameter 0 L0 LINENUMBER 11 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 0 DUP IFNULL L1 //对string字符串判空 INVOKESTATIC kotlin/text/StringsKt.toCharArray (Ljava/lang/String;)[C DUP IFNULL L1 //对CharArray判空 BIPUSH 10 INVOKESTATIC kotlin/collections/ArraysKt.getOrNull ([CI)Ljava/lang/Character; DUP IFNULL L1 //对Char判空 INVOKEVIRTUAL java/lang/Object.hashCode ()I INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer; GOTO L2 L1 POP ACONST_NULL L2 INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V L3 LINENUMBER 12 L3 RETURN L4 LOCALVARIABLE string Ljava/lang/String; L0 L4 0 MAXSTACK = 3 MAXLOCALS = 1&#125; 反编译为Java代码如下： 1234567891011121314151617181920212223242526272829public static final void testNullSafeOperator(@Nullable String string) &#123; PrintStream var10000; Integer var5; label18: &#123; var10000 = System.out; if(string != null) &#123; PrintStream var2 = var10000; if(string == null) &#123; throw new TypeCastException(\"null cannot be cast to non-null type java.lang.String\"); &#125; char[] var4 = ((String)string).toCharArray(); Intrinsics.checkExpressionValueIsNotNull(var4, \"(this as java.lang.String).toCharArray()\"); char[] var3 = var4; var10000 = var2; if(var3 != null) &#123; Character var10001 = ArraysKt.getOrNull(var3, 10); if(var10001 != null) &#123; var5 = Integer.valueOf(var10001.hashCode()); break label18; &#125; &#125; &#125; var5 = null; &#125; var10000.println(var5); &#125; 由此可见kotlin实现的非空 ？ 语法，内部就是利用非空判断实现。 与Java互操作Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以很顺利地调用 Kotlin 代码。 空安全和平台类型Java 中的任何引用都可能是 null，这使得 Kotlin 对来自 Java 的对象要求严格空安全是不现实的。 Java 声明的类型在 Kotlin 中会被特别对待并称为平台类型。对这种类型的空检查会放宽， 因此它们的安全保证与在 Java 中相同 12345val list = ArrayList&lt;String&gt;() // 非空（构造函数结果）list.add(\"Item\")val size = list.size() // 非空（原生 int）val item = list[0] // 推断为平台类型（普通 Java 对象）item.substring(1) // 允许，如果 item == null 可能会抛出异常 受检异常在 Kotlin 中，所有异常都是非受检的，这意味着编译器不会强迫你捕获其中的任何一个。 因此，当你调用一个声明受检异常的 Java 方法时，Kotlin 不会强迫你做任何事情： 12345fun render(list: List&lt;*&gt;, to: Appendable) &#123; for (item in list) &#123; to.append(item.toString()) // Java 会要求我们在这里捕获 IOException &#125;&#125; 如何编译？编译入口从kotlinc Hello.kt 开始分析 12345678910111213141516171819202122cygwin=false;case &quot;`uname`&quot; in CYGWIN*) cygwin=true ;;esac...declare -a kotlin_app//运行入口if [ -n &quot;$KOTLIN_RUNNER&quot; ];then java_args=(&quot;$&#123;java_args[@]&#125;&quot; &quot;-Dkotlin.home=$&#123;KOTLIN_HOME&#125;&quot;) kotlin_app=(&quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-runner.jar&quot; &quot;org.jetbrains.kotlin.runner.Main&quot;)else//编译入口 [ -n &quot;$KOTLIN_COMPILER&quot; ] || KOTLIN_COMPILER=org.jetbrains.kotlin.cli.jvm.K2JVMCompiler java_args=(&quot;$&#123;java_args[@]&#125;&quot; &quot;-noverify&quot;) kotlin_app=(&quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-preloader.jar&quot; &quot;org.jetbrains.kotlin.preloading.Preloader&quot; &quot;-cp&quot; &quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-compiler.jar&quot; $KOTLIN_COMPILER)fi&quot;$&#123;JAVACMD:=java&#125;&quot; $JAVA_OPTS &quot;$&#123;java_args[@]&#125;&quot; -cp &quot;$&#123;kotlin_app[@]&#125;&quot; &quot;$&#123;kotlin_args[@]&#125;&quot; 12345678910111213141516171819202122232425fun compileBunchOfSources(environment: KotlinCoreEnvironment): Boolean &#123; val moduleVisibilityManager = ModuleVisibilityManager.SERVICE.getInstance(environment.project) val friendPaths = environment.configuration.getList(JVMConfigurationKeys.FRIEND_PATHS) for (path in friendPaths) &#123; moduleVisibilityManager.addFriendPath(path) &#125; if (!checkKotlinPackageUsage(environment, environment.getSourceFiles())) return false //词法、语法分析、语义分析、目标代码生成等过程 val generationState = analyzeAndGenerate(environment) ?: return false // 找到运行主类 val mainClass = findMainClass(generationState, environment.getSourceFiles()) try &#123; //写入文件 writeOutput(environment.configuration, generationState.factory, mainClass) return true &#125; finally &#123; generationState.destroy() &#125; &#125; 目标代码的生成在代码类生成的过程中，又包括生成类名、类体、字段、函数方法等环节，相关的生成类有ClassBodyCodegen、ClassFunctionCodegen、MemberCodegen、ExpressionCodegen、PropertyCodegen等。 12345678910111213141516171819202122232425262728public class KotlinCodegenFacade &#123; public static void doGenerateFiles( @NotNull Collection&lt;KtFile&gt; files, @NotNull GenerationState state, @NotNull CompilationErrorHandler errorHandler ) &#123; ... for (KtFile file : files) &#123; ... Set&lt;FqName&gt; obsoleteMultifileClasses = new HashSet&lt;FqName&gt;(state.getObsoleteMultifileClasses()); for (FqName multifileClassFqName : Sets.union(filesInMultifileClasses.keySet(), obsoleteMultifileClasses)) &#123; doCheckCancelled(state); //目标代码类生成 generateMultifileClass(state, multifileClassFqName, filesInMultifileClasses.get(multifileClassFqName), errorHandler); &#125; Set&lt;FqName&gt; packagesWithObsoleteParts = new HashSet&lt;FqName&gt;(state.getPackagesWithObsoleteParts()); for (FqName packageFqName : Sets.union(packagesWithObsoleteParts, filesInPackages.keySet())) &#123; doCheckCancelled(state); //目标代码类包生成 generatePackage(state, packageFqName, filesInPackages.get(packageFqName), errorHandler); &#125; doCheckCancelled(state); //生成结束 state.getFactory().done(); &#125;&#125; Kotlin在目标代码生成环节做了更多的处理，在该环节实现了自动生成Getter、Setter的代码。 12345678910111213141516171819202122public class PropertyCodegen &#123; private void gen( @Nullable KtProperty declaration, // 属性声明 @NotNull PropertyDescriptor descriptor, //描述，包括权限修饰符、注解、类型等。 @Nullable KtPropertyAccessor getter, // 决定是否生成getter @Nullable KtPropertyAccessor setter //决定是否生成setter ) &#123; assert kind == OwnerKind.PACKAGE || kind == OwnerKind.IMPLEMENTATION || kind == OwnerKind.DEFAULT_IMPLS : \"Generating property with a wrong kind (\" + kind + \"): \" + descriptor; //生成注解信息 genBackingFieldAndAnnotations(declaration, descriptor, false); //根据注解和权限修饰符等信息判断是否自动生成Getter代码 if (isAccessorNeeded(declaration, descriptor, getter)) &#123; generateGetter(declaration, descriptor, getter); &#125; //根据注解和权限修饰符等信息判断是否自动生成Setter代码 if (isAccessorNeeded(declaration, descriptor, setter)) &#123; generateSetter(declaration, descriptor, setter); &#125; &#125;&#125; Kotlin到Java的迁移成本 文件自动转换，点击菜单栏 Code | Convert Java File to Kotlin File 语法兼容性 第三方库兼容性 Kotlin为Android开发者带来什么改变？ 效率 多平台","categories":[],"tags":[]},{"title":"JVM 答疑解惑","slug":"JVM-答疑解惑","date":"2017-05-11T09:40:00.000Z","updated":"2017-05-13T10:20:54.000Z","comments":true,"path":"2017/05/11/JVM-答疑解惑/","link":"","permalink":"http://yoursite.com/2017/05/11/JVM-答疑解惑/","excerpt":"JVM是什么？平常接触的东西都存在哪里？类如何加载？怎么运行？清洁工怎么工作？","text":"JVM是什么？平常接触的东西都存在哪里？类如何加载？怎么运行？清洁工怎么工作？ JVM是什么？Java 虚拟机屏蔽了与具体操作系统平台相关的信息,使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码),就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时,实际上最终还是把字节码解释成具体平台上的机器指令执行。 Java 虚拟机就像一个熟悉多个国家语言的导游，你只要向他说出自己的语言，他就能带着你在多个国家无障碍的玩耍。比如说，你说“我要吃肉夹馍”，无论到了哪个国家，你只需要和导游说这句话就可以，寻找和本地人交流导游就会帮你办好，最后结果是相同的：吃的都是肉夹馍。 可以参考如下Java技术体系图： 平常接触的东西都存在哪里？先看一下Java虚拟机运行时数据区：","categories":[],"tags":[]},{"title":"数据库到底哪家强？","slug":"数据库到底哪家强？","date":"2017-04-15T06:24:26.000Z","updated":"2017-04-19T07:18:25.000Z","comments":true,"path":"2017/04/15/数据库到底哪家强？/","link":"","permalink":"http://yoursite.com/2017/04/15/数据库到底哪家强？/","excerpt":"目前大部分开源数据库都是基于SQLite发展而来，如SQLBrite、OrmLite、DBFlow、GreenDao等等，还有一个是Realm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎。那这么多框架到底有什么区别，那种更适合自己的产品呢？","text":"目前大部分开源数据库都是基于SQLite发展而来，如SQLBrite、OrmLite、DBFlow、GreenDao等等，还有一个是Realm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎。那这么多框架到底有什么区别，那种更适合自己的产品呢？ 我们先看基于SQLite发展而来的框架，这方面主要分成两条发展路线，一条是Rx或者叫做对象映射（OM）路线，一条是对象关系映射（ORM）路线。 Rx/对象映射路线代表数据库有sqlbrite、sqldelight，这两个都是Square出品。 SqlBrite和SqlDelight都是对象映射（OM，Object Mappers）而不是对象关系映射（ORM，Object/Relational Mappers）。 ORM 其实并不是一个优秀的框架。很多平台的 ORM 实现都有性能和内存的问题。我们也不会编写ORM。 – JakeWharton 上面这句话很好的说明了这两个框架的出发点，知道这些我们就容易理解了。 SqlBrite SqlBrite是对 Android 系统的 SQLiteOpenHelper 的封装，对SQL操作引入了响应式语义 （Rx）（用来在 RxJava 中使用） 基本用法 创建一个SqlBrite对象，该对象是该库的入口：SqlBrite sqlBrite = SqlBrite.create(); 提供一个 SQLiteOpenHelper实例和一个Scheduler实例来创建一个 BriteDatabase 对象：BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper, Schedulers.io());，Scheduler 是指定执行查询的操作的线程，由于查询数据库是不建议在 UI 线程中执行的，所以一般指定 Schedulers.io() 。 BriteDatabase.createQuery方法和SQLiteDatabase.rawQuery方法相比，多了一个table(s)表参数，用于监听数据变更。当我们订阅subscribe返回的Observable的时候，立刻执行需要的查询语句。 1234567Observable users = db.createQuery(\"users\", \"SELECT * FROM users\");users.subscribe(new Action1() &#123; @Override public void call(Query query) &#123; Cursor cursor = query.run(); // TODO parse data... &#125;&#125;); 优点在保证性能和复杂扩展性的同时，利用Rxjava操作Sql在易用性上有部分提高。 缺点还需要编写Sql语句，复杂性还是较高。 SqlDelight SqlDelight通过从 SQL 语句来生成 JAVA 模型代码。这样的好处是，所有 SQL 语句都位于同一个位置，通过查看 SQL 语句可以清楚的了解需要实现的功能和数据库的结构,也便于管理以及java类访问。 基本用法需要把 SQL 语句放到对应的 .sq 文件中，默认目录为和 main 目录下的 java 代码同级，例如src/main/sqldelight/com/example/HockeyPlayer.sq ，其中 com/example/ 为对应 java 对象的包名字。 在该 .sq 文件中一般第一个语句是创建表的语句： 123456789101112CREATE TABLE hockey_player ( _id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, number INTEGER NOT NULL, name TEXT NOT NULL);-- 其他的语句通过标识符来引用。在生成的 Java 对象中会包含-- 一个该标识符的常亮引用这个语句。select_by_name:SELECT *FROM hockey_playerWHERE name = ?; 上面的 SQL 语句会生成一个 HockeyPlayerModel Java 接口。该接口内有两个嵌套类分别把 Cursor 映射为 Java 对象以及把 Java 对象转换为 ContentValues 好插入数据库 优点 所有的SQL statement都存在.sq文件中，便于管理 可以自由的使用普通SQLite的同时帮助你处理了程式化的代码 缺点需要编写原生sql 总结SqlBrite方便在 RxJava 中使用 Sql 操作，并且额外添加了对数据库表数据更新通知的机制，当你对数据表进行操作的时候，其他订阅者可以在数据发生变化的时候收到通知。然后可以用 RxJava 的方式来操作数据。只是一个 SQLiteOpenHelper 的轻量级封装，并不关心你的对象是如何实现的，也不关心你的数据库。SqlBrite也不支持对象映射和类型安全的查询，SqlBrite 不是一个 ORM 框架，也不是一个类型安全的查询框架。不会提供类似Gson中对象序列化的功能，也不会提供数据库迁移的功能。 SqlDelight 的做法是从 SQL 语句来生成 JAVA 模型代码。 这样的好处是，所有 SQL 语句都位于同一个位置。SqlDelight 添加了对 SQL 语句的编译时验证、表名字和列名字的代码自动完成功能。让编写 SQL 语句更加快捷。在编译的时候，根据 SQL 语句生成 Java 模型接口和 builder 来把数据行和 Java 对象实现转换。SqlDelight 不会做很重的功能（比如数据懒加载、缓存 、级联删除 等 ORM 框架内常见的功能）。 对象关系映射（ORM）路线这部分框架在易用性上和性能上都做了很多工作，易用性上基本达到极致，在性能上接近原生Sql，这里举几个有代表性的项目。 OrmLite OrmLite - Lightweight Object Relational Mapping (ORM) Java Package 基本原理 使用注解方式标示字段，如数据库、表等 运行时使用反射获取相应字段拼接sql去执行 优点在易用性上相比原生sql有较大提高 缺点性能上有损失 greenDAO greenDAO is an open source Android ORM making development for SQLite databases fun again. 基本原理、特点 使用注解方式标示字段 在编译期生成本地sql greenDAO 支持 protocol buffer(protobuf) 协议数据的直接存储，如果你通过 protobuf 协议与服务器交互，将不需要任何的映射。 数据加密 解析 DaoMaster保存了sqlitedatebase对象以及操作DAO classes。其提供了一些创建和删除table的静态方法，其内部类OpenHelper和DevOpenHelper实现了SQLiteOpenHelper并创建数据库的框架。 DaoMaster除了具有创建表和删除表的两个功能外，还有两个内部类，分别为OpenHelper和DevOpenHelper，而DevOpenHelper继承自OpenHelper，而OpenHelper继承自SQLiteOpenHelper，而重写的onCreate()方法中调用了createAllTables(db,false)；方法来创建数据表，而createAllTables()方法中是通过调用UserDao静态方法来创建表的UserDao.createTable(db, ifNotExists)； 123456789101112131415/** Creates the underlying database table. */ public static void createTable(SQLiteDatabase db, boolean ifNotExists) &#123; String constraint = ifNotExists? \"IF NOT EXISTS \": \"\"; db.execSQL(\"CREATE TABLE \" + constraint + \"\\\\\"NOTE\\\\\" (\" + // \"\\\\\"_id\\\\\" INTEGER PRIMARY KEY AUTOINCREMENT ,\" + // 0: id \"\\\\\"TEXT\\\\\" TEXT NOT NULL ,\" + // 1: text \"\\\\\"COMMENT\\\\\" TEXT,\" + // 2: comment \"\\\\\"DATE\\\\\" INTEGER);\"); // 3: date&#125;/** Drops the underlying database table. */public static void dropTable(SQLiteDatabase db, boolean ifExists) &#123; String sql = \"DROP TABLE \" + (ifExists ? \"IF EXISTS \" : \"\") + \"\\\\\"NOTE\\\\\"\"; db.execSQL(sql);&#125; greenDAO的增删改查方法有一些是在Android原生的操作方法上进行了封装，对于链式查询的最终执行也是调用了Android原生的查询操作。 12345public List&lt;T&gt; list() &#123; checkThread(); Cursor cursor = dao.getDatabase().rawQuery(sql, parameters); return daoAccess.loadAllAndCloseCursor(cursor);&#125; 同时还有一些方法是基于SQLiteStatement实现的，SQLiteStatement相比原生的execSQL方法还要快一些，并且最终执行时也开启了事务，性能又提升了很多。下面是插入数据的最终实现方法： 1234567891011121314151617181920212223private long executeInsert(T entity, SQLiteStatement stmt) &#123; long rowId; if (db.isDbLockedByCurrentThread()) &#123; synchronized (stmt) &#123; bindValues(stmt, entity); rowId = stmt.executeInsert(); &#125; &#125; else &#123; // Do TX to acquire a connection before locking the stmt to avoid deadlocks db.beginTransaction(); try &#123; synchronized (stmt) &#123; bindValues(stmt, entity); rowId = stmt.executeInsert(); &#125; db.setTransactionSuccessful(); &#125; finally &#123; db.endTransaction(); &#125; &#125; updateKeyAfterInsertAndAttach(entity, rowId, true); return rowId;&#125; 可以看到先执行bindValues方法，该方法是一个抽象方法，需要业务方在DAO文件中实现，跟踪至NoteDao文件查看该方法代码如下： 1234567891011121314151617181920@Overrideprotected void bindValues(SQLiteStatement stmt, Note entity) &#123; stmt.clearBindings(); Long id = entity.getId(); if (id != null) &#123; stmt.bindLong(1, id); // 1为索引值，id为入库的值 &#125; stmt.bindString(2, entity.getText()); String comment = entity.getComment(); if (comment != null) &#123; stmt.bindString(3, comment); &#125; java.util.Date date = entity.getDate(); if (date != null) &#123; stmt.bindLong(4, date.getTime()); &#125;&#125; 这样就将SQLiteStatement需要的数据都进行了封装，然后执行stmt.executeInsert()方法即可完成数据库的插入操作。整个数据插入流程，greenDAO借助SQLiteStatement完成了数据的插入，避免了其他框架利用反射拼装sql语句而造成的执行效率低下的问题。 其他优化： 避免使用注解和反射拼装sql语句 最终执行时开启了事务 支持异步查询和回调 查询缓存机制，使用了弱引用WeakReference，第一次查询时将数据加入SparseArray&gt;的集合中 优点在易用性和性能上做到了很好的平衡 缺点上手成本 总结ORM类型框架在易用性上面做的比原生Sql提升了很多，而且在性能上GreenDao在某些方面甚至比原生的还要出色，比较适合大部分项目的开发工作。 RealmRealm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎，在某些方面有自己独特的优势。 GreenDao vs Realm 基本用法增： 1234567Realm realm=Realm.getDefaultInstance();realm.beginTransaction();User user = realm.createObject(User.class); // Create a new objectuser.setName(\"John\");user.setEmail(\"john@corporation.com\");realm.commitTransaction(); 删： 1234567891011121314151617181920Realm mRealm=Realm.getDefaultInstance(); final RealmResults&lt;Dog&gt; dogs= mRealm.where(Dog.class).findAll(); mRealm.executeTransaction(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; Dog dog=dogs.get(5); dog.deleteFromRealm(); //删除第一个数据 dogs.deleteFirstFromRealm(); //删除最后一个数据 dogs.deleteLastFromRealm(); //删除位置为1的数据 dogs.deleteFromRealm(1); //删除所有数据 dogs.deleteAllFromRealm(); &#125; &#125;); 优点 易用 快速 跨平台 可视化 缺点 显著增加安装包大小，增加大概4、5兆 数据类型限制，必须继承RealmObject、不支持内部类、修改了部分类型、不支持键值自增长。 线程限制，如果在UI线程获取到了当前Realm对象，在异步线程中使用当前Realm对象进行操作，就会抛出异常。 总结如果数据量没有达到SQLite的性能瓶颈的话，建议选择基于SQLite的数据库，如果不喜欢编写原生Sql语句就牺牲一点性能去适应业务快速迭代。这些框架同时存在都有其道理，性能有优势兼容性和稳定性不能保证，易用性很好必然就不能做太多的定制化操作，各取所需，对于一般的业务GreenDao便是一个比较好的方案。","categories":[],"tags":[]},{"title":"Android模块化与组件化--多模块区分编译","slug":"Android模块化与组件化-多模块区分编译","date":"2017-02-03T10:28:18.000Z","updated":"2017-02-07T06:55:02.000Z","comments":true,"path":"2017/02/03/Android模块化与组件化-多模块区分编译/","link":"","permalink":"http://yoursite.com/2017/02/03/Android模块化与组件化-多模块区分编译/","excerpt":"有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？","text":"有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？ 模块化与组件化–多模块区分编译 示例地址：https://github.com/JackyAndroid/Android-Architecture-Fairy/tree/master/multi-variants-libraryAndroid-Architecture-Fairy开源项目重点分析主流技术与架构设计，欢迎star 有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？先看下官方文档如下： By default a library only publishes its release variant. This variant will be used by all projects referencing the library, no matter which variant they build themselves. This is a temporary limitation due to Gradle limitations that we are working towards removing. You can control which variant gets published:123android &#123; defaultPublishConfig \"debug\"&#125; Note that this publishing configuration name references the full variant name. Release and debug are only applicable when there are no flavors. If you wanted to change the default published variant while using flavors, you would write:123android &#123; defaultPublishConfig \"flavor1Debug\"&#125; It is also possible to publish all variants of a library. We are planning to allow this while using a normal project-to-project dependency (like shown above), but this is not possible right now due to limitations in Gradle (we are working toward fixing those as well).Publishing of all variants are not enabled by default. The snippet below enables this feature:123android &#123; publishNonDefault true&#125; It is important to realize that publishing multiple variants means publishing multiple aar files, instead of a single aar containing multiple variants. Each aar packaging contains a single variant. Publishing a variant means making this aar available as an output artifact of the Gradle project. This can then be used either when publishing to a maven repository, or when another project creates a dependency on the library project. Gradle has a concept of default” artifact. This is the one that is used when writing:123dependencies &#123; compile project(':libraries:lib2')&#125; To create a dependency on another published artifact, you need to specify which one to use:1234dependencies &#123; flavor1Compile project(path: ':lib1', configuration: 'flavor1Release') flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')&#125; Important: Note that the published configuration is a full variant, including the build type, and needs to be referenced as such.Important: When enabling publishing of non default, the Maven publishing plugin will publish these additional variants as extra packages (with classifier). This means that this is not really compatible with publishing to a maven repository. You should either publish a single variant to a repository OR enable all config publishing for inter-project dependencies. 默认Library只发布Release版本，这个是Gradle官方的限制，Google官方正在试图解决这个问题。可以使用defaultPublishConfig去设置发布的版本，通过设置publishNonDefault true可以让Library发布多个产品版本。下面的这种平常书写的方式是依赖的默认发布版本：123dependencies &#123; compile project(':libraries:lib2')&#125; 如果想要分渠道编译多种形态的Library，需要修改如下的方式：1234dependencies &#123; flavor1Compile project(path: ':lib1', configuration: 'flavor1Release') flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')&#125; 注意事项： 编译的配置是产品名称的全称加编译类型，如：flavor1Release 如果Library是Maven的公开库最好不要使用这种特性 产品名称首字母要小写，否则会有语法问题 如果Gradle里面有使用MultiDex选项会生成多个aar","categories":[],"tags":[]},{"title":"来，谷歌安卓浏览器源码就在这！","slug":"来，谷歌安卓浏览器源码就在这！","date":"2017-02-03T09:49:37.000Z","updated":"2017-02-07T06:52:29.000Z","comments":true,"path":"2017/02/03/来，谷歌安卓浏览器源码就在这！/","link":"","permalink":"http://yoursite.com/2017/02/03/来，谷歌安卓浏览器源码就在这！/","excerpt":"谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star","text":"谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star 欢迎在GitHub或者CSDN上关注我GitHub: https://github.com/JackyAndroid CSDN: http://blog.csdn.net/rain_butterfly AndroidChromium AndroidChromium源码地址如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash） 简介 谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star 效果图 以下是升级chrome内核注意事项，如不是相关人员可以忽略 准备参考官方及其他教程编译通过chromium源码，并能生成chrome.apk 目的使用AndroidStudio开发环境调试Chromium Android UI层。 构建思路 采用Android Studio作为开发环境，从Chromium for Android抽取chrome模块的源码，加入Android project。 native代码在chromium环境中build，作为so加入Android project 基础模块(base, content, net等)在chromium环境build为jar包，加入Android project content, chrome, ui等模块的资源文件加入Android library project 资源文件为什么不能直接都添加到Android project呢？因为命名空间的原因，比如content模块的资源的命名空间为org.chromium.content, chrome模块的资源的命名空间为 org.chromium.chrome，所以需要建立不同的Android library project, 指定不同的包名。 本项目和源码目录对应关系app/libs ———– chromium/src/out/Release/lib.java app/src/main/aidl ———– chromium/src/chrome/android/java/src/android/support/customtabs/*.aidl app/src/main/assets ———– chromium/src/out/Release/assets/chrome_public_apk app/src/main/java ———— chromium/src/chrome/android/java/src app/src/main/jniLibs ———– chromium/src/out/Release/chrome_public_apk/libs app/src/main/res（app module 初始化资源） libraries/androidmedia_res ———– chromium/src/third_party/android_media/java/res libraries/chrome_res ———– chromium/src/chrome/android/java/res &amp; chromium/src/chrome/android/java/res_chromium libraries/content_res ———– chromium/src/content/public/android/java/res libraries/datausagechart_res ——— chromium/src/third_party/android_data_chart/java/res libraries/ui_res ———- chromium/src/ui/android/java/res 建议&amp;注意事项 pak和dat等文件需要加入到assets目录，而且不能压缩 aidl文件加入到main/aidl下，android studio会自动处理 目前构建的chromium版本是48.0.2554.0，内核为官方版本 因为某些java文件是通过C文件编译生成，只存在chromium/src/out 目录下。如果按以上对应关系升级版本缺失文件，请到out/目录下去搜索，根据命名空间添加相应文件。还有一些临时生成的xml资源文件也需要从out/目录下去拷贝到相应的资源模块。 如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash） 感谢本项目灵感来自于365browser LicenseCopyright 2016 Jacky Wang&lt;jacky.android@foxmail.com&gt; Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","categories":[],"tags":[]},{"title":"Android Framework是怎么启动的？","slug":"Android-Framework是怎么启动的？","date":"2017-02-03T09:47:48.000Z","updated":"2017-02-07T06:56:09.000Z","comments":true,"path":"2017/02/03/Android-Framework是怎么启动的？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-Framework是怎么启动的？/","excerpt":"安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。","text":"安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。 Android Framework运行环境是怎样的？安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。 Framework运行环境如下图： 安卓系统中运行的第一个Dalvik虚拟机叫做zygote，这个的意思是“卵”，那有什么卵用呢？听这个词的意思就知道是孵化的意思，接下来所有的Dalvik虚拟机进程都是这个“卵”孵化出来的。 zygote进程中包含两个主要模块，分别如下： Socket服务端。任务是用于接收启动新的Dalvik进程的命令。 Framework共享类及共享资源。当zygote进程启动后会加载一些共享的类及资源，就像营养液一样，供其他的细胞吸收。其中共享类是在preload-classes文件中被定义的，共享资源是在preload-resources中被定义的。其他Dalvik进程是被zygote卵进程孵化出来的，所以这些类和资源加载后，新的Dalvik进程就可以直接使用这些类和资源就达到了共享目的，就像一个细胞分裂成两个，共享一些基因和营养。 zygote进程对应的程序是app_process,该程序在system/bin目录下。 zygote孵化出的第一个Dalvik进程是SystemServer，该进程对应的程序依然是app_process,因为该进程是从app_process中孵化出来的。 SystemServer中创建了一个Socket客户端（生产线经理），之后所有的Dalvik进程都将通过该Socket客户端间接被启动，Ams负责管理这个客户端。如果需要启动新的APK进程时，Ams会通过该Socket客户端向zygote进程的Socket服务端（生产线工人）发送一个启动命令，然后zygote会孵化出新的进程（产品生产成型）。 这样的架构有两个特点： 每一个进程都是一个Dalvik虚拟机，Dalvik虚拟机是一种类似于java虚拟机的程序。 zygote进程会预先装载共享类和共享资源，提供营养液和基因，这些类和资源其实就是SDK中定义的大部分类和资源。当通过zygote孵化出新进程后，新的APK只需要去加载APK自身包含的类和资源，这样多个APK就可以共享Framework资源了。 和Dalvik虚拟机关系比较好的可执行程序有哪些？1.dalvikvmjava程序运行时都是由一个虚拟机来解释java字节码，将这些字节码翻译成本地CPU指令码然后执行。dalvikvm的作用就是创建一个虚拟机并执行参数中指定的java类。 2.dvzdvz的作用是从zygote进程中孵化出一个新的进程，新进程其实就是一个Dalvik虚拟机。该进程与dalvikvm启动的虚拟机相比，区别是该进程中已经预装了Framework的大部分类和资源。 3.app_processFramework在启动时需要加载运行两个特定java类，一个是ZygoteInit.java，一个是SystemServer.java。为了方便使用，系统才提供了一个app_process进程，该进程会自动运行这两个类，app_process其实就是使用dalvikvm启动ZygoteInit.java，启动后会加载Framework中得大部分类和资源。 Zygote是如何启动的？1.在init.rc中配置Zygote启动参数2.启动Socket服务端口当Zygote服务从app_process开始启动后，会启动一个Dalvik虚拟机，虚拟机第一个执行的java类就是ZygoteInit.java，该类第一个重要的工作就是启动一个Socket服务端口，该Socket端口用于接收启动新进程的命令。 3.加载preload-classes在Zygote类的main（）函数中，创建完Socket服务端后还不能立即孵化出新的进程，因为这个“卵”还没有必须的“基因”，这个“基因”就是指预装的Framework大部分类及资源。 4.加载preload-resourcespreload-resources包含两类资源，一类是drawable资源，一类是color资源。加载这些资源是在preloadResource（）函数中完成的，该函数调用preloadDrawable（）和preloadColorStateLists（）加载这两类资源，原理就是把这些资源读出来放到一个全局变量中，只要该类对象不被销毁，这些全局变量就会一直保存。 5.使用fork启动新的进程fork是Linux系统的一个系统调用，作用就是复制当前进程产生一个新的进程，相当于生物的克隆。除了进程id不同，新进程将拥有和原始进程完全相同的进程信息。进程的信息包括该进程所打开的文件描述符列表、所分配的内存等。当新进程被创建后，两个进程将共享已经分配的内存空间，如果其中一个需要向内存中写入数据时，操作系统才复制一份目标地址空间，并将要写的数据写入到新的地址中。这种“仅当写的时候才复制”的机制可以最大限度的在多个进程中共享物理内存。 举个栗子：去乌镇见一下习大大和去乌镇吃一次丁磊的猪肉，这是两个进程，但是两个进程中的很多任务是相同的，先订机票，做地铁到机场，做几小时飞机过去。到了之后不同的就是见习大大和吃猪肉。如果可以先雇一个秘书进程让它订机票、做地铁、做飞机，到乌镇。然后秘书在复制出两个秘书，一个去见习大大，一个去吃猪肉，好处是节省了大量内存。 Zygote进程就是本例中的“秘书进程”，那些“订机票、做地铁、乘飞机”就是Zygote进程中加载的preload-classes类的功能。 这样新的进程就脱离的Zygote进程的孵化成为一个真正的应用进程。 SystemServer 进程是如何启动的？SystemServer进程是Zygote孵化出的第一个进程，然后再配置SystemServer进程的环境。 1.启动各种系统服务线程SystemServer进程在Android运行环境中扮演了“神经中枢”的作用，APK应用中能够直接交互的大部分系统服务都在该进程中运行，常见的有WindowManagerServer（Wms）、ActivityManagerService（Ams）、PackageManagerServer（Pms），这些系统服务都是以一个线程的方式存在于SystemServer进程中。 2.启动第一个Activity当以上服务线程都启动后，其中Ams服务是systemReady（）调用完成最后启动的，在Ams的systemReady（）函数的最后一段代码则发出了启动任务队列中最上面一个Activity消息。 在Ams的startHomeActivityLocked（）中，系统发出了一个category字段包含CATEGORY_HOME的intent，代码如下： 1234intent.setComponent(mTopComponent);if(mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL)&#123;intent.addCategory(Intent.CATEGORY_HOME);&#125; 只要应用声明自己能够响应该Intent，那么就可以被认为是Home程序。当系统中有多个程序能够响应该Intent时，系统会弹出一个对话框，让用户选择启动哪个程序，也允许用户记住该选择。 到此第一个Activity就启动了。 如有问题请留言，转载请注明出处。","categories":[],"tags":[]},{"title":"Android 一个窗口是怎么创建出来的？","slug":"Android-一个窗口是怎么创建出来的？","date":"2017-02-03T09:46:19.000Z","updated":"2017-02-07T06:52:58.000Z","comments":true,"path":"2017/02/03/Android-一个窗口是怎么创建出来的？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-一个窗口是怎么创建出来的？/","excerpt":"在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。","text":"在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。 前言在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。 WmS并不在意该窗口是哪个应用程序的，关心的是活跃窗口，WmS按一定得规则判断哪个窗口处于活动状态，然后把用户消息给W类，W类再把用户消息传递给内部View变量，然后再由View对象完成剩下的消息处理。 窗户有几种类型？Framework定义了三种窗口类型，三种窗口类型的定义在WindowManager类里面。 应用窗口。应用窗口一般指该窗口对应一个Activity，由于加载Activity是由Ams完成的，所以对于应用程序创建应用类窗口只能在Activity内部完成。 子窗口。子窗口是指该窗口必须要有一个父窗口，父窗口可以是一个应用类窗口也可以是任何其他的窗口。 系统窗口。系统窗口不需要对应任何Activity，也不需要有父窗口。应用程序是没有办法创建系统窗口的，只有系统进程可以创建系统窗口。 那么该怎么创建应用窗口呢？1.每个应用类窗口都对应一个Activity对象，所以创建应用类窗口需要创建Activity对象。当AmS要启动某个Activity时就会通知客户端进程，每个客户端进程都对应一个ActivityThread类，所以需要ActivityThread启动Activity。 启动某个Activity实际是构造一个Activity对象，使用ClassLoader从程序文件中装载指定的Activity对应的Class文件。 2.创建完成Activity对象后调用Activity的attach（）方法，attach（）的作用就是为刚刚创造好的Activity设置内部变量。 3.为该Activity创建Window对象。 4.给Window对象中的mWindowManager变量赋值。 5.然后就需要给该窗口添加真正的View或者ViewGroup。从performLaunchActivity（）调用callActivityOnCreate（）开始，然后经一系列调用到Activity的onCreate（）方法，在onCreate（）方法中调用setContentView（）方法实际是调用了其对应的Window对象的setContentView（）方法。 6.接着会调用到PhoneWindow的setContentView，首先调用installDecor（）为Window类添加窗口装饰，其实就是标题栏，程序中设置的layout.xml界面被包含在窗口装饰中，就是窗口内容。窗口装饰也是ViewGroup，窗口装饰和它内部的内容加起来就是我们所说的窗口，或者叫做Window界面。 7.把创建的窗口通知WmS，让WmS把窗口显示在屏幕上。当Activity准备好后会通知Ams，然后Ams经过一系列调用到Activity的makeVisible（），该方法将真正完成把窗口添加进Wms中。 8.在makeVisible方法中，首先获得该Activity内部的WindowManager对象，然后调用该对象的addView（）方法。 9.调用WindowManagerImpl的addView（）方法，流程如下： 检查添加的窗口是否已经添加过，不能重复添加。 如果添加的窗口是子窗口类型，找到父窗口并保存在临时变量panelParentView中，该变量作为后面调用ViewRoot的setView（）参数。 创建一个新的ViewRoot 调用ViewRoot的setView（）。 10.完成新建一个ViewRoot对象后，需要把新建的ViewRoot对象添加到mRoots对象中。 11.调用ViewRoot对象的setView方法。流程如下： 给ViewRoot的重要变量赋值。 调用requestLayout（），发出界面重绘请求。 调用sWindowSession.add（），通知Wms添加窗口。 创建子窗口或系统窗口过程和上面的类似。","categories":[],"tags":[]},{"title":"Android Context 到底是什么？","slug":"Android-Context-到底是什么？","date":"2017-02-03T09:44:37.000Z","updated":"2017-02-07T06:56:39.000Z","comments":true,"path":"2017/02/03/Android-Context-到底是什么？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-Context-到底是什么？/","excerpt":"一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。","text":"一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。 什么是Android Context？一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。 那么从安卓程序的角度来看，Context是什么？其实一个Activity就是一个Context，一个Service也是一个Context。 一个应用程序可以认为是一个约会环境，用户在这个环境中会切换到不同的场景，比如先去有情调的饭店吃饭，再去电影院看个电影，然后再去xxx（此处省略一万字…）。 Activity类的确是基于Context，而Service类也是基于Context。Activity除了基于Context类外，还实现了一些其他重要的接口，从架构设计的角度看，interface仅仅是某些功能，而extends才是类的本质，即Activity的本质是一个Context，其所实现的其他接口只是为了扩充Context的功能而已，扩充后的类称之为一个Activity或Service。 一个应用程序中应该有多少个Context对象我们在应用程序开发中经常会调用Context的一些方法，这些方法看起来似乎会返回一些全局的对象，而不仅仅是某个Activity，可能会有点疑问，一个应用程序到底有多少个Context对象呢？比如，Context.getResources（）返回该应用程序所对应的Resource类对象，无论从哪个Activity中调用，都会返回同一个Resource对象。 一个Activity就是一个场景（Context），一个Service也是一个场景，所以，应用程序中有多少个Activity或者Service就会有多少个Context对象，也就是有多少个场景。 getResource（）等方法返回的是同一个全局对象。 Context 继承关系是怎么样的呢？ Context类本身是一个纯abstract类。为了使用方便又定义了Context包装类-ContextWrapper，穿上了一身装备显得也比较强大，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中有attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象。 ContextThemeWrapper内部包含了与主题相关的接口，这里的主题就是指在AndroidManifest.xml中通过android：theme为Application或者Activity指定的主题。 只有Activity才需要主题，Service默默的后台工作者不需要穿的那么鲜艳，所以Service直接继承于ContextWrapper。 ContextImpl类真正实现了Context中所有的函数，真正的八块腹肌，我们所调用的各种Context类的方法其实实现均来自于该类。 什么时候创建的Context?每一个应用程序在客户端都是从ActivityThread类开始的，创建Context对象也是在该类中完成，具体创建ContextImpl类的地方一共有6处： PackageInfo.makeApplication（） performLaunchActivity（） handleCreateBackupAgent（） handleCreateService（） handleBindApplication（） attach（） 其中attach（）方法仅在Framework进程启动时调用，应用程序运行时不会调用到该方法。 Application对应的Context程序第一次启动时，会辗转调用到makeApplication（）方法。具体代码如下： 1234ContextImpl appContext = new ContextImpl();appContext.init(this,null,mActivityThread);....appContext.setOuterContext(app); Activity对应的Context启动Activity时，Ams会通过IPC调用到ActivityThread的scheduleLaunchActivity（）方法，该方法包含两种参数。一种是ActivityInfo，这是一个实现了Parcelable接口的数据类，意味着该对象是Ams创建的，并通过IPC传递到ActivityThread；另一种是其他的一些参数。 scheduleLaunchActivity（）方法中会根据以上两种参数构造一个本地ActivityRecord数据类，ActivityThread内部会为每一个Activity创建一个ActivityRecord对象，并使用这些数据对象来管理Activity。 然后会调用handleLaunchActivity（），再调用performLaunchActivity（），该方法中创建ContextImpl的代码如下： 123ContextImpl appContext = new ContextImpl();appContext.init(r.packageInfo,r.token,this);appContext.setOuterContext(activity); 在performLaunchActivity（）开始执行时，会为r.packageInfo变量赋值。r.packageInfo对象的PackageInfo对象和Application对应的packageInfo对象是同一个。 Service对应的Context启动Service时，Ams会通过IPC调用到ActivityThread的scheduleCreateService（）方法，该方法也包含两种参数。第一种是ServiceInfo，这是实现了一个Parcelable接口的数据类，该对象由AmS创建，并通过IPC传递到ActivityThread内部；第二种是其他参数。 在scheduleCreateService（）方法中，会使用以上两种参数构造一个CreateServiceData的数据对象，ActivityThread会为其所包含的每一个Service创建该数据对象，并通过这些对象来管理Service。 然后在执行handleCreateService（）方法，创建ContextImpl对象代码如下： 1234ContextImpl appContext = new ContextImpl();appContext.init(packageInfo,null,this);...appContext.setOuterContext(service); Service对应的Context对象内部的mPackageInfo与Activity、Application中是完全相同的。 这几个Context之间的关系从以上可以看出，创建Context对象的过程基本上是相同的，不同的仅仅是针对Application、Activity、Service使用了不同的数据对象。 一个应用程序包含的Context个数应该为：Context个数 = Service个数+Activity个数+1，最后的1是Application类本身也会对应一个Context对象。 应用程序中包含多个ContextImpl对象，而内部变量mPackageInfo却指向同一个PackageInfo对象，这种设计结构一般意味着ContextImpl是一种轻量级类，而PackageInfo是一个重量级类。事实上确实是这样，ContextImpl中的大多数进行包操作的重量级函数实际上都是转向了mPackageInfo对象相应的方法，也就是事实上调用了同一个PackageInfo对象。","categories":[],"tags":[]},{"title":"我眼中的Android Framework","slug":"我眼中的Android-Framework","date":"2017-02-03T09:40:58.000Z","updated":"2017-02-07T06:53:19.000Z","comments":true,"path":"2017/02/03/我眼中的Android-Framework/","link":"","permalink":"http://yoursite.com/2017/02/03/我眼中的Android-Framework/","excerpt":"在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言","text":"在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言 我眼中的Android Framework在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言 任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。Android framework包含三个小伙伴：服务端、客户端、linux驱动。 服务端 服务端主要包含两个狠重要的类：WindowManagerService（WMS）和ActivityManagerService（AMS） 客户端客户端包含以下类： ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是UI线程或者称为主线程。 Activity：ActivityThread会根据用户的操作选择让哪个Activity对象上它的船。 PhoneWindow：富二代，继承于牛气的Window类，自己屋里住着一个DecorView对象，像它老爸喜欢制定规则提供了一些通用窗口操作API。 Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作API。它不喜欢被人管所以呢，注意：WindowManagerService管理的窗口不是Window类，其实是View和ViewGroup。 DecorView：很能干的家伙，家产来自FrameLayout，比较注重外在喜欢打扮，DecorView是对FrameLayout进行了一些修饰，从名字就可以看出来。 ViewRoot：小管家继承于Handler，主要作用是把WMS的IPC调用转换为本地的一个异步调用。 W类：ViewRoot小助手，继承于binder，是ViewRoot内部类。主要帮助ViewRoot实现把WMS的IPC调用转换为本地的一个异步调用。 WindowManager：客户端如果想创建一个窗口得先告诉WindowManager一声，然后它再和WindowManagerService交流一下看看能不能创建，客户端不能直接和WMS交互。 Linux驱动 Linux驱动和Framework相关的主要是两个部分：画家SurfaceFlingger和快递员Binder。 每一个窗口都对应一个画Surface，SF主要是把各个Surface显示到同一屏幕上。Binder是提供跨进程的消息传递。 从apk程序的运行过程去看看上面各个组件在啥时候干啥活的ActivityThread从main()函数中就开始动起来，然后调用prepareMainLooper()为UI线程创建一个消息快递通道即MessageQueue。 接着创建ActivityThread对象，创建过程会创建一个消息装卸工Handler对象和一个快递员Binder对象，其中Binder负责接收远程Ams的IPC调用，接收到调用后让Handler把消息装到消息快递队列，UI线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。 然后UI线程让队列调用Looper.loop()方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。 当ActivityThread接收到Ams发送start某个Activity的快递后就会创建指定的Activity对象。Activity会先按窗户再去按玻璃和贴窗花，所以先创建PhoneWindow-&gt;DecorView-&gt;创建相应的View或ViewGroup。创建完成后就可以让大家欣赏了，调用WindowManager把界面显示到屏幕上，然后创建ViewRoot，然后调用Wms提供的远程接口添加一个窗口并显示到屏幕上。 接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用Wms中的相应函数处理该消息。 很多线程是不是很晕？ 安卓程序中都有哪些线程？ 客户端小伙伴至少包含三个线程小弟，Activity启动后会创建一个ViewRoot.W对象，同时ActivityThread会创建一个ApplicationThread对象，这两个对象继承消息总管Binder，每个Binder对应一个线程，负责接收Linux Binder驱动发送的IPC调用。还有一个是UI线程呗。 UI线程是什么？ 一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。 自定义的线程和UI线程有什么区别？ UI线程是从ActivityThread运行的，在该类的main()方法中已经使用了Looper.prepareMainLooper()为该线程添加了Looper对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在Activity中去定义Handler对象，因为创建Handler对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的Thread则没有默认创建消息队列，所以不能直接在Thread中直接定义Handler，这个就是我们不懂程序运行原理导致的困惑。","categories":[],"tags":[]},{"title":"Android 设计模式-单例模式","slug":"Android-设计模式-单例模式","date":"2017-02-03T09:35:12.000Z","updated":"2017-02-07T06:57:10.000Z","comments":true,"path":"2017/02/03/Android-设计模式-单例模式/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-设计模式-单例模式/","excerpt":"什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用","text":"什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用 Android 设计模式-单例模式什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用 设计单例模式1234567891011public class Singleton&#123;private static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123;if(mSingleton == null)&#123; mSingleton = new Singleton();\\\\A &#125; return mSingleton; &#125;&#125; 上面的做法在多线程的时候会出现问题，比如有两个线程同时调用getInstance(),这时会new两个对象出来。 单例模式改进112345678910111213public class Singleton&#123;private static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; synchronized(Singleton.class)&#123; if(mSingleton == null)&#123; mSingleton = new Singleton();\\\\A &#125; return mSingleton; &#125; &#125;&#125; 这种方式还是会有问题，就是高并发情况下多线程去抢夺锁，假如有几百个线程，其中有一个运气比较差，这个线程就会出现一直去getInstance，资源一直返回不回去，UI也不会得到更新。 单例模式改进21234567891011121314public class Singleton&#123;private volatile static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; if(mSingleton == null)&#123;\\\\A synchronized(Singleton.class)&#123;\\\\C if(mSingleton == null) mSingleton = new Singleton();\\\\B &#125; &#125; return mSingleton; &#125;&#125; 注：volatile是防止cpu进行指令重排序，防止代码顺序被更改。这种方式比较好的地方在于第一次创建实例时候就会同步所有的线程，以后再获取实例就会直接返回。 但是看代码好像还是有人会有疑问，为什么需要两次判断为null？其实这个意义在于防止多个线程同时进入第一个if内，比如说线程A执行到A行，线程B执行到B行，线程B还没有返回。当线程A执行到C行，这时线程B初始化实例完毕，如果没有里面的再一次判断就会生成两个实例！所以两次的判断null还是有意义的。","categories":[],"tags":[]},{"title":"东半球最好的TV桌面开源项目","slug":"东半球最好的TV桌面开源项目","date":"2017-02-03T09:14:46.000Z","updated":"2017-02-07T06:53:33.000Z","comments":true,"path":"2017/02/03/东半球最好的TV桌面开源项目/","link":"","permalink":"http://yoursite.com/2017/02/03/东半球最好的TV桌面开源项目/","excerpt":"这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。","text":"这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。 欢迎在GitHub或者CSDN上关注我GitHub: https://github.com/JackyAndroid CSDN: http://blog.csdn.net/rain_butterfly AndroidTVLauncher 这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。 注意CatLauncher(Leanback风格) 目前功能已基本稳定，后续会跟进官方Leanback库的进展，Compatible桌面理论上不再维护 特性 Leanback风格 图片展示 视频直播（节操播放器-基于ijkplayer） 媒体详情 第三方应用列表 桌面特殊功能 效果图 下一步的改进 跟进官方Leanback库新功能 LicenseApache License, Version 2.0","categories":[],"tags":[{"name":"AndroidTV,开源","slug":"AndroidTV-开源","permalink":"http://yoursite.com/tags/AndroidTV-开源/"}]}]}