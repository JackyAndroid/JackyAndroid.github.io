{"meta":{"title":"墨镜猫","subtitle":null,"description":"求知若渴，大智若愚","author":"Jacky","url":"http://yoursite.com"},"pages":[{"title":"虽然假期过去了，但一定不要再次辜负你的新年愿望","date":"2017-02-04T08:40:56.000Z","updated":"2017-02-04T09:07:01.000Z","comments":true,"path":"plan/index.html","permalink":"http://yoursite.com/plan/index.html","excerpt":"","text":"我们每个人在过去 12 个月都有大把机会去反省自己的缺点，但鲜少有人能努力提前完成理想转变。 书单 Android源码设计模式解析与实战 Android源代码情景分析 失控 科技想要什么 必然 幽默沟通 健康 每周3-5次锻炼 不加班 自我成长 参加付费课程 学会与他人高效充分的沟通，锻炼自己演讲能力 锻炼商业分析能力 旅行2-3次"},{"title":"about","date":"2017-01-26T03:45:19.000Z","updated":"2017-01-26T04:00:10.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 从事Android开发四年左右，自认为是一名技术极客。热爱开源，乐于分享。现在乐视从事应用层架构工作。 小成就 CSDN博客专家 Github星榜中国区前20 社交信息 CSDN：http://blog.csdn.net/rain_butterfly Github：https://github.com/JackyAndroid 掘金：https://gold.xitu.io/user/562dc7cc60b20fc9817962a2 微博：http://weibo.com/u/5885816355 微信：sunglasses_cat"}],"posts":[{"title":"Android模块化与组件化--多模块区分编译","slug":"Android模块化与组件化-多模块区分编译","date":"2017-02-03T10:28:18.000Z","updated":"2017-02-07T06:55:02.000Z","comments":true,"path":"2017/02/03/Android模块化与组件化-多模块区分编译/","link":"","permalink":"http://yoursite.com/2017/02/03/Android模块化与组件化-多模块区分编译/","excerpt":"有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？","text":"有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？ 模块化与组件化–多模块区分编译 示例地址：https://github.com/JackyAndroid/Android-Architecture-Fairy/tree/master/multi-variants-libraryAndroid-Architecture-Fairy开源项目重点分析主流技术与架构设计，欢迎star 有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？先看下官方文档如下： By default a library only publishes its release variant. This variant will be used by all projects referencing the library, no matter which variant they build themselves. This is a temporary limitation due to Gradle limitations that we are working towards removing. You can control which variant gets published:123android &#123; defaultPublishConfig \"debug\"&#125; Note that this publishing configuration name references the full variant name. Release and debug are only applicable when there are no flavors. If you wanted to change the default published variant while using flavors, you would write:123android &#123; defaultPublishConfig \"flavor1Debug\"&#125; It is also possible to publish all variants of a library. We are planning to allow this while using a normal project-to-project dependency (like shown above), but this is not possible right now due to limitations in Gradle (we are working toward fixing those as well).Publishing of all variants are not enabled by default. The snippet below enables this feature:123android &#123; publishNonDefault true&#125; It is important to realize that publishing multiple variants means publishing multiple aar files, instead of a single aar containing multiple variants. Each aar packaging contains a single variant. Publishing a variant means making this aar available as an output artifact of the Gradle project. This can then be used either when publishing to a maven repository, or when another project creates a dependency on the library project. Gradle has a concept of default” artifact. This is the one that is used when writing:123dependencies &#123; compile project(':libraries:lib2')&#125; To create a dependency on another published artifact, you need to specify which one to use:1234dependencies &#123; flavor1Compile project(path: ':lib1', configuration: 'flavor1Release') flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')&#125; Important: Note that the published configuration is a full variant, including the build type, and needs to be referenced as such.Important: When enabling publishing of non default, the Maven publishing plugin will publish these additional variants as extra packages (with classifier). This means that this is not really compatible with publishing to a maven repository. You should either publish a single variant to a repository OR enable all config publishing for inter-project dependencies. 默认Library只发布Release版本，这个是Gradle官方的限制，Google官方正在试图解决这个问题。可以使用defaultPublishConfig去设置发布的版本，通过设置publishNonDefault true可以让Library发布多个产品版本。下面的这种平常书写的方式是依赖的默认发布版本：123dependencies &#123; compile project(':libraries:lib2')&#125; 如果想要分渠道编译多种形态的Library，需要修改如下的方式：1234dependencies &#123; flavor1Compile project(path: ':lib1', configuration: 'flavor1Release') flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')&#125; 注意事项： 编译的配置是产品名称的全称加编译类型，如：flavor1Release 如果Library是Maven的公开库最好不要使用这种特性 产品名称首字母要小写，否则会有语法问题 如果Gradle里面有使用MultiDex选项会生成多个aar","categories":[],"tags":[]},{"title":"国内一线互联网公司内部面试题库","slug":"国内一线互联网公司内部面试题库","date":"2017-02-03T10:03:01.000Z","updated":"2017-02-07T06:52:10.000Z","comments":true,"path":"2017/02/03/国内一线互联网公司内部面试题库/","link":"","permalink":"http://yoursite.com/2017/02/03/国内一线互联网公司内部面试题库/","excerpt":"以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库 熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。","text":"以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库 熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。 国内一线互联网公司内部面试题库以下面试题来自于百度、小米、乐视、美团、58、猎豹、360、新浪、搜狐内部题库 熟悉本文中列出的知识点会大大增加通过前两轮技术面试的几率。 欢迎一线公司员工提交内部面试题库，欢迎star。 目录 java基础 接口的意义-百度 抽象类的意义-乐视 内部类的作用-乐视 父类的静态方法能否被子类重写-猎豹 java排序算法-美团 列举java的集合和继承关系-百度-美团 java虚拟机的特性-百度-乐视 哪些情况下的对象会被垃圾回收机制处理掉-美团-小米 进程和线程的区别-猎豹-美团 ==和equals和hashCode的区别-乐视 常见的排序算法时间复杂度-小米 HashMap的实现原理-美团 java状态机 int-char-long各占多少字节数 int与integer的区别 string-stringbuffer-stringbuilder区别-小米-乐视-百度 java多态-乐视 什么导致线程阻塞-58-美团 抽象类接口区别-360 容器类之间的区别-乐视-美团 内部类 hashmap和hashtable的区别-乐视-小米 ArrayMap对比HashMap 安卓 如何导入外部数据库 本地广播和全局广播有什么差别 intentService作用是什么，AIDL解决了什么问题？-小米 Activity,Window,View三者的差别，fragment的特点？-360 描述一次网络请求的流程-新浪 Handler、Thread和HandlerThread的差别-小米 低版本SDK实现高版本api-小米 Ubuntu编译安卓系统-百度 launch mode应用场景-百度-小米-乐视 Touch事件传递流程-小米 view绘制流程-百度 多线程-360 线程同步-百度 什么情况导致内存泄漏-美团 ANR定位和修正 什么情况导致oom-乐视-美团 Android Service与Activity之间通信的几种方式 Android各个版本API的区别 Android代码中实现WAP方式联网-360 如何保证service在后台不被kill Requestlayout，onlayout，onDraw，DrawChild区别与联系-猎豹 invalidate()和postInvalidate() 的区别及使用-百度和postInvalidate()的区别及使用-百度) Android动画框架实现原理 Android为每个应用程序分配的内存大小是多少？-美团 Android View刷新机制-百度-美团 LinearLayout对比RelativeLayout-百度 优化自定义view百度-乐视-小米 ContentProvider-乐视 fragment生命周期 volley解析-美团-乐视 Android Glide源码解析 Android 设计模式 架构设计-搜狐 Android属性动画特性-乐视-小米 java接口的意义-百度规范、扩展、回调 抽象类的意义-乐视为其子类提供一个公共的类型封装子类中得重复内容定义抽象方法，子类虽然有不同的实现 但是定义是一致的 内部类的作用-乐视 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。 创建内部类对象的时刻并不依赖于外围类对象的创建。 内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。 内部类提供了更好的封装，除了该外围类，其他类都不能访问 父类的静态方法能否被子类重写-猎豹不能 子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现 java排序算法-美团http://blog.csdn.net/qy1387/article/details/7752973 列举java的集合和继承关系-百度-美团 java虚拟机的特性-百度-乐视Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。 哪些情况下的对象会被垃圾回收机制处理掉-美团-小米Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。 进程和线程的区别-猎豹-美团简而言之,一个程序至少有一个进程,一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。 java中==和equals和hashCode的区别-乐视http://blog.csdn.net/tiantiandjava/article/details/46988461 常见的排序算法时间复杂度-小米 HashMap的实现原理-美团 HashMap概述：HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。 状态机http://www.jdon.com/designpatterns/designpattern_State.htm int-char-long各占多少字节数byte 位数 8 字节数 1 short 16 2 int 32 4 long 64 8 float 32 4 double 64 8 char 16 2 int与integer的区别http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html string-stringbuffer-stringbuilder区别-小米-乐视-百度String 字符串常量 StringBuffer 字符串变量（线程安全） StringBuilder 字符串变量（非线程安全） 简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的： String S1 = “This is only a” + “ simple” + “ test”; StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个 String S1 = “This is only a” + “ simple” + “test”; 其实就是： String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如： String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 +S3 + S4;这时候 JVM 会规规矩矩的按照原来的方式去做 在大部分情况下 StringBuffer &gt; String StringBuffer Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。 在大部分情况下 StringBuilder &gt; StringBuffer java.lang.StringBuilder java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同 java多态-乐视Java多态性理解 Java中多态性的实现 什么是多态 面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 多态的作用：消除类型之间的耦合关系。 现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。下面是多态存在的三个必要条件，要求大家做梦时都能背出来！ 多态存在的三个必要条件一、要有继承；二、要有重写；三、父类引用指向子类对象。 多态的好处： 1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。 2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。 3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。 4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。 5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。 什么导致线程阻塞-58-美团线程的阻塞 为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持. 阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。 sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。 suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。 yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程. wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用. 初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。 上述的核心区别导致了一系列的细节上的区别。 首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。 其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。 wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。 关于 wait() 和 notify() 方法最后再说明两点： 第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。 第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。 谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。 以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。 抽象类接口区别-360 默认的方法实现抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现 实现子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 构造器抽象类可以有构造器接口不能有构造器 与正常Java类的区别除了你不能实例化抽象类之外，它和普通Java类没有任何区接口是完全不同的类型 访问修饰符抽象方法可以有public、protected和default这些修饰符接口方法默认修饰符是public。你不可以使用其它修饰符。 main方法抽象方法可以有main方法并且我们可以运行它接口没有main方法，因此我们不能运行它。 多继承抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。 速度它比接口速度要快接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 添加新方法如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。 容器类之间的区别-乐视-美团http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.htmlhttp://alexyyek.github.io/2015/04/06/Collection/http://tianmaying.com/tutorial/java_collection 内部类http://www.cnblogs.com/chenssy/p/3388487.html hashmap和hashtable的区别-乐视-小米http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html ArrayMap对比HashMaphttp://lvable.com/?p=217 ###Android 如何导入外部数据库把原数据库包括在项目源码的 res/raw android系统下数据库应该存放在 /data/data/com..（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录. 本地广播和全局广播有什么差别因广播数据在本应用范围内传播，不用担心隐私数据泄露的问题。不用担心别的应用伪造广播，造成安全隐患。相比在系统内发送全局广播，它更高效。 intentService作用是什么,AIDL解决了什么问题-小米生成一个默认的且与主线程互相独立的工作者线程来执行所有传送至onStartCommand() 方法的Intetnt。 生成一个工作队列来传送Intent对象给你的onHandleIntent()方法，同一时刻只传送一个Intent对象，这样一来，你就不必担心多线程的问题。在所有的请求(Intent)都被执行完以后会自动停止服务，所以，你不需要自己去调用stopSelf()方法来停止。 该服务提供了一个onBind()方法的默认实现，它返回null 提供了一个onStartCommand()方法的默认实现，它将Intent先传送至工作队列，然后从工作队列中每次取出一个传送至onHandleIntent()方法，在该方法中对Intent对相应的处理。 AIDL (Android Interface Definition Language) 是一种IDL 语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。AIDL IPC机制是面向接口的，像COM或Corba一样，但是更加轻量级。它是使用代理类在客户端和实现端传递数据。 Activity/Window/View三者的差别,fragment的特点-360Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。 在Activity中调用attach，创建了一个Window 创建的window是其子类PhoneWindow，在attach中创建PhoneWindow 在Activity中调用setContentView(R.layout.xxx) 其中实际上是调用的getWindow().setContentView() 调用PhoneWindow中的setContentView方法 创建ParentView：作为ViewGroup的子类，实际是创建的DecorView(作为FramLayout的子类） 将指定的R.layout.xxx进行填充通过布局填充器进行填充【其中的parent指的就是DecorView】 调用到ViewGroup 调用ViewGroup的removeAllView()，先将所有的view移除掉 添加新的view：addView() fragment 特点 Fragment可以作为Activity界面的一部分组成出现； 可以在一个Activity中同时出现多个Fragment，并且一个Fragment也可以在多个Activity中使用； 在Activity运行过程中，可以添加、移除或者替换Fragment； Fragment可以响应自己的输入事件，并且有自己的生命周期，它们的生命周期会受宿主Activity的生命周期影响。 描述一次网络请求的流程-新浪￼ Handler,Thread和HandlerThread的差别-小米http://blog.csdn.net/guolin_blog/article/details/9991569 http://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/ 从Android中Thread（java.lang.Thread -&gt; java.lang.Object）描述可以看出，Android的Thread没有对Java的Thread做任何封装，但是Android提供了一个继承自Thread的类HandlerThread（android.os.HandlerThread -&gt; java.lang.Thread），这个类对Java的Thread做了很多便利Android系统的封装。 android.os.Handler可以通过Looper对象实例化，并运行于另外的线程中，Android提供了让Handler运行于其它线程的线程实现，也是就HandlerThread。HandlerThread对象start后可以获得其Looper对象，并且使用这个Looper对象实例Handler。 低版本SDK实现高版本api-小米自己实现或@TargetApi annotation Ubuntu编译安卓系统-百度 进入源码根目录 . build/envsetup.sh lunch full(编译全部) userdebug(选择编译版本) make -j8(开启8个线程编译) LaunchMode应用场景-百度-小米-乐视standard，创建一个新的Activity。 singleTop，栈顶不是该类型的Activity，创建一个新的Activity。否则，onNewIntent。 singleTask，回退栈中没有该类型的Activity，创建Activity，否则，onNewIntent+ClearTop。 注意: 设置了”singleTask”启动模式的Activity，它在启动的时候，会先在系统中查找属性值affinity等于它的属性值taskAffinity的Task存在； 如果存在这样的Task，它就会在这个Task中启动，否则就会在新的任务栈中启动。因此， 如果我们想要设置了”singleTask”启动模式的Activity在新的任务中启动，就要为它设置一个独立的taskAffinity属性值。 如果设置了”singleTask”启动模式的Activity不是在新的任务中启动时，它会在已有的任务中查看是否已经存在相应的Activity实例， 如果存在，就会把位于这个Activity实例上面的Activity全部结束掉，即最终这个Activity 实例会位于任务的Stack顶端中。 在一个任务栈中只有一个”singleTask”启动模式的Activity存在。他的上面可以有其他的Activity。这点与singleInstance是有区别的。 singleInstance，回退栈中，只有这一个Activity，没有其他Activity。 singleTop适合接收通知启动的内容显示页面。 例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。 singleTask适合作为程序入口点。 例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance应用场景： 闹铃的响铃界面。 你以前设置了一个闹铃：上午6点。在上午5点58分，你启动了闹铃设置界面，并按 Home 键回桌面；在上午5点59分时，你在微信和朋友聊天；在6点时，闹铃响了，并且弹出了一个对话框形式的 Activity(名为 AlarmAlertActivity) 提示你到6点了(这个 Activity 就是以 SingleInstance 加载模式打开的)，你按返回键，回到的是微信的聊天界面，这是因为 AlarmAlertActivity 所在的 Task 的栈只有他一个元素， 因此退出之后这个 Task 的栈空了。如果是以 SingleTask 打开 AlarmAlertActivity，那么当闹铃响了的时候，按返回键应该进入闹铃设置界面。 Touch事件传递流程-小米http://hanhailong.com/2015/09/24/Android-%E4%B8%89%E5%BC%A0%E5%9B%BE%E6%90%9E%E5%AE%9ATouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/ View绘制流程-百度http://www.codekk.com/blogs/detail/54cfab086c4761e5001b253f 多线程-360 Activity.runOnUiThread(Runnable) View.post(Runnable),View.postDelay(Runnable,long) Handler AsyncTask 线程同步-百度http://www.itzhai.com/java-based-notebook-thread-synchronization-problem-solving-synchronization-problems-synchronized-block-synchronized-methods.html#read-more http://www.juwends.com/tech/android/android-inter-thread-comm.html 单例 1234567891011121314public class Singleton&#123;private volatile static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; if(mSingleton == null)&#123;\\\\A synchronized(Singleton.class)&#123;\\\\C if(mSingleton == null) mSingleton = new Singleton();\\\\B &#125; &#125; return mSingleton; &#125;&#125; 什么情况导致内存泄漏-美团1.资源对象没关闭造成的内存泄漏 描述：资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。 2.构造Adapter时，没有使用缓存的convertView 描述：以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：public View getView(int position, ViewconvertView, ViewGroup parent)来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的 view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用 convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。 ListView回收list item的view对象的过程可以查看:android.widget.AbsListView.java –&gt; voidaddScrapView(View scrap) 方法。示例代码： 12345public View getView(int position, ViewconvertView, ViewGroup parent) &#123;View view = new Xxx(...); ... ... return view; &#125; 修正示例代码： 123456789101112public View getView(int position, ViewconvertView, ViewGroup parent) &#123;View view = null; if (convertView != null) &#123; view = convertView; populate(view, getItem(position)); ... &#125; else &#123; view = new Xxx(...); ... &#125; return view; &#125; 3.Bitmap对象不在使用时调用recycle()释放内存 描述：有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释： /*•Free up the memory associated with thisbitmap’s pixels, and mark the•bitmap as “dead”, meaning itwill throw an exception if getPixels() or•setPixels() is called, and will drawnothing. This operation cannot be•reversed, so it should only be called ifyou are sure there are no•further uses for the bitmap. This is anadvanced call, and normally need•not be called, since the normal GCprocess will free up this memory when•there are no more references to thisbitmap. / 4.试着使用关于application的context来替代和activity相关的context 这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免Android内存泄漏。 5.注册没取消造成的内存泄漏 一些Android程序可能引用我们的Anroid程序的对象(比如注册机制)。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个 PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。但是如果在释放 LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process 进程挂掉。虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。 6.集合中对象没清理造成的内存泄漏 我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。 ANR定位和修正如果开发机器上出现问题，我们可以通过查看/data/anr/traces.txt即可，最新的ANR信息在最开始部分。 主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。 主线程中存在耗时的计算 主线程中错误的操作，比如Thread.wait或者Thread.sleep等Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框 应用在5秒内未响应用户的输入事件（如按键或者触摸） BroadcastReceiver未在10秒内完成相关的处理 Service在特定的时间内无法处理完成 20秒 使用AsyncTask处理耗时IO操作。 使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。 使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。 Activity的onCreate和onResume回调中尽量避免耗时的代码 BroadcastReceiver中onReceive代码也要尽量减少耗时，建议使用IntentService处理。 什么情况导致oom-乐视-美团http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0920/3478.html 1）使用更加轻量的数据结构2）Android里面使用Enum3）Bitmap对象的内存占用4）更大的图片5）onDraw方法里面执行对象的创建6）StringBuilder Service与Activity之间通信的几种方式 通过Binder对象 通过broadcast(广播)的形式 Android各个版本API的区别http://blog.csdn.net/lijun952048910/article/details/7980562 Android代码中实现WAP方式联网-360http://blog.csdn.net/asce1885/article/details/7844159 如何保证service在后台不被Kill一、onStartCommand方法，返回START_STICKY START_STICKY在运行onStartCommand后service进程被kill后，那将保留在开始状态，但是不保留那些传入的intent。不久后service就会再次尝试重新创建，因为保留在开始状态，在创建 service后将保证调用onstartCommand。如果没有传递任何开始命令给service，那将获取到null的intent。 START_NOT_STICKY在运行onStartCommand后service进程被kill后，并且没有新的intent传递给它。Service将移出开始状态，并且直到新的明显的方法（startService）调用才重新创建。因为如果没有传递任何未决定的intent那么service是不会启动，也就是期间onstartCommand不会接收到任何null的intent。 START_REDELIVER_INTENT在运行onStartCommand后service进程被kill后，系统将会再次启动service，并传入最后一个intent给onstartCommand。直到调用stopSelf(int)才停止传递intent。如果在被kill后还有未处理好的intent，那被kill后服务还是会自动启动。因此onstartCommand不会接收到任何null的intent。 二、提升service优先级 在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。 三、提升service进程优先级 Android中的进程是托管的，当系统进程空间紧张的时候，会依照优先级自动进行进程的回收。Android将进程分为6个等级,它们按优先级顺序由高到低依次是: 前台进程( FOREGROUND_APP) 可视进程(VISIBLE_APP ) 次要服务进程(SECONDARY_SERVER ) 后台进程 (HIDDEN_APP) 内容供应节点(CONTENT_PROVIDER) 空进程(EMPTY_APP) 当service运行在低内存的环境时，将会kill掉一些存在的进程。因此进程的优先级将会很重要，可以使用startForeground 将service放到前台状态。这样在低内存时被kill的几率会低一些。 四、onDestroy方法里重启service service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service； 五、Application加上Persistent属性 六、监听系统广播判断Service状态 通过系统的一些广播，比如：手机重启、界面唤醒、应用状态改变等等监听并捕获到，然后判断我们的Service是否还存活，别忘记加权限啊。 Requestlayout,onlayout,onDraw,DrawChild区别与联系-猎豹requestLayout()方法 ：会导致调用measure()过程 和 layout()过程 。将会根据标志位判断是否需要ondraw onLayout()方法(如果该View是ViewGroup对象，需要实现该方法，对每个子视图进行布局) 调用onDraw()方法绘制视图本身 (每个View都需要重载该方法，ViewGroup不需要实现该方法) drawChild()去重新回调每个子视图的draw()方法 invalidate()和postInvalidate()的区别及使用-百度http://blog.csdn.net/mars2639/article/details/6650876 Android动画框架实现原理Animation框架定义了透明度，旋转，缩放和位移几种常见的动画，而且控制的是整个View，实现原理是每次绘制视图时View所在的ViewGroup中的drawChild函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix())，通过矩阵运算完成动画帧，如果动画没有完成，继续调用invalidate()函数，启动下次绘制来驱动动画，动画过程中的帧之间间隙时间是绘制函数所消耗的时间，可能会导致动画消耗比较多的CPU资源，最重要的是，动画改变的只是显示，并不能相应事件。 Android为每个应用程序分配的内存大小是多少-美团android程序内存一般限制在16M，也有的是24M View刷新机制-百度-美团由ViewRoot对象的performTraversals()方法调用draw()方法发起绘制该View树，值得注意的是每次发起绘图时，并不会重新绘制每个View树的视图，而只会重新绘制那些“需要重绘”的视图，View类内部变量包含了一个标志位DRAWN，当该视图需要重绘时，就会为该View添加该标志位。 调用流程 ： mView.draw()开始绘制，draw()方法实现的功能如下： 绘制该View的背景 为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框) 调用onDraw()方法绘制视图本身 (每个View都需要重载该方法，ViewGroup不需要实现该方法) 调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法)值得说明的是，ViewGroup类已经为我们重写了dispatchDraw ()的功能实现，应用程序一般不需要重写该方法，但可以重载父类函数实现具体的功能。 LinearLayout和RelativeLayout性能对比-百度 RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。 在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。 最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。 优化自定义view百度-乐视-小米为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。 你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。 另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。 如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。 ContentProvider-乐视http://blog.csdn.net/coder_pig/article/details/47858489 Fragment生命周期 volley解析-美团-乐视http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90 Glide源码解析http://www.lightskystreet.com/2015/10/12/glide_source_analysis/http://frodoking.github.io/2015/10/10/android-glide/ Android设计模式http://blog.csdn.net/bboyfeiyu/article/details/44563871 架构设计-搜狐 http://www.tianmaying.com/tutorial/AndroidMVC Android属性动画特性-乐视-小米如果你的需求中只需要对View进行移动、缩放、旋转和淡入淡出操作，那么补间动画确实已经足够健全了。但是很显然，这些功能是不足以覆盖所有的场景的，一旦我们的需求超出了移动、缩放、旋转和淡入淡出这四种对View的操作，那么补间动画就不能再帮我们忙了，也就是说它在功能和可扩展方面都有相当大的局限性，那么下面我们就来看看补间动画所不能胜任的场景。 注意上面我在介绍补间动画的时候都有使用“对View进行操作”这样的描述，没错，补间动画是只能够作用在View上的。也就是说，我们可以对一个Button、TextView、甚至是LinearLayout、或者其它任何继承自View的组件进行动画操作，但是如果我们想要对一个非View的对象进行动画操作，抱歉，补间动画就帮不上忙了。可能有的朋友会感到不能理解，我怎么会需要对一个非View的对象进行动画操作呢？这里我举一个简单的例子，比如说我们有一个自定义的View，在这个View当中有一个Point对象用于管理坐标，然后在onDraw()方法当中就是根据这个Point对象的坐标值来进行绘制的。也就是说，如果我们可以对Point对象进行动画操作，那么整个自定义View的动画效果就有了。显然，补间动画是不具备这个功能的，这是它的第一个缺陷。 然后补间动画还有一个缺陷，就是它只能够实现移动、缩放、旋转和淡入淡出这四种动画操作，那如果我们希望可以对View的背景色进行动态地改变呢？很遗憾，我们只能靠自己去实现了。说白了，之前的补间动画机制就是使用硬编码的方式来完成的，功能限定死就是这些，基本上没有任何扩展性可言。 最后，补间动画还有一个致命的缺陷，就是它只是改变了View的显示效果而已，而不会真正去改变View的属性。什么意思呢？比如说，现在屏幕的左上角有一个按钮，然后我们通过补间动画将它移动到了屏幕的右下角，现在你可以去尝试点击一下这个按钮，点击事件是绝对不会触发的，因为实际上这个按钮还是停留在屏幕的左上角，只不过补间动画将这个按钮绘制到了屏幕的右下角而已。","categories":[],"tags":[]},{"title":"来，谷歌安卓浏览器源码就在这！","slug":"来，谷歌安卓浏览器源码就在这！","date":"2017-02-03T09:49:37.000Z","updated":"2017-02-07T06:52:29.000Z","comments":true,"path":"2017/02/03/来，谷歌安卓浏览器源码就在这！/","link":"","permalink":"http://yoursite.com/2017/02/03/来，谷歌安卓浏览器源码就在这！/","excerpt":"谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star","text":"谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star 欢迎在GitHub或者CSDN上关注我GitHub: https://github.com/JackyAndroid CSDN: http://blog.csdn.net/rain_butterfly AndroidChromium AndroidChromium源码地址如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash） 简介 谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star 效果图 以下是升级chrome内核注意事项，如不是相关人员可以忽略 准备参考官方及其他教程编译通过chromium源码，并能生成chrome.apk 目的使用AndroidStudio开发环境调试Chromium Android UI层。 构建思路 采用Android Studio作为开发环境，从Chromium for Android抽取chrome模块的源码，加入Android project。 native代码在chromium环境中build，作为so加入Android project 基础模块(base, content, net等)在chromium环境build为jar包，加入Android project content, chrome, ui等模块的资源文件加入Android library project 资源文件为什么不能直接都添加到Android project呢？因为命名空间的原因，比如content模块的资源的命名空间为org.chromium.content, chrome模块的资源的命名空间为 org.chromium.chrome，所以需要建立不同的Android library project, 指定不同的包名。 本项目和源码目录对应关系app/libs ———– chromium/src/out/Release/lib.java app/src/main/aidl ———– chromium/src/chrome/android/java/src/android/support/customtabs/*.aidl app/src/main/assets ———– chromium/src/out/Release/assets/chrome_public_apk app/src/main/java ———— chromium/src/chrome/android/java/src app/src/main/jniLibs ———– chromium/src/out/Release/chrome_public_apk/libs app/src/main/res（app module 初始化资源） libraries/androidmedia_res ———– chromium/src/third_party/android_media/java/res libraries/chrome_res ———– chromium/src/chrome/android/java/res &amp; chromium/src/chrome/android/java/res_chromium libraries/content_res ———– chromium/src/content/public/android/java/res libraries/datausagechart_res ——— chromium/src/third_party/android_data_chart/java/res libraries/ui_res ———- chromium/src/ui/android/java/res 建议&amp;注意事项 pak和dat等文件需要加入到assets目录，而且不能压缩 aidl文件加入到main/aidl下，android studio会自动处理 目前构建的chromium版本是48.0.2554.0，内核为官方版本 因为某些java文件是通过C文件编译生成，只存在chromium/src/out 目录下。如果按以上对应关系升级版本缺失文件，请到out/目录下去搜索，根据命名空间添加相应文件。还有一些临时生成的xml资源文件也需要从out/目录下去拷贝到相应的资源模块。 如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash） 感谢本项目灵感来自于365browser LicenseCopyright 2016 Jacky Wang&lt;jacky.android@foxmail.com&gt; Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","categories":[],"tags":[]},{"title":"Android Framework是怎么启动的？","slug":"Android-Framework是怎么启动的？","date":"2017-02-03T09:47:48.000Z","updated":"2017-02-07T06:56:09.000Z","comments":true,"path":"2017/02/03/Android-Framework是怎么启动的？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-Framework是怎么启动的？/","excerpt":"安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。","text":"安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。 Android Framework运行环境是怎样的？安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。 Framework运行环境如下图： 安卓系统中运行的第一个Dalvik虚拟机叫做zygote，这个的意思是“卵”，那有什么卵用呢？听这个词的意思就知道是孵化的意思，接下来所有的Dalvik虚拟机进程都是这个“卵”孵化出来的。 zygote进程中包含两个主要模块，分别如下： Socket服务端。任务是用于接收启动新的Dalvik进程的命令。 Framework共享类及共享资源。当zygote进程启动后会加载一些共享的类及资源，就像营养液一样，供其他的细胞吸收。其中共享类是在preload-classes文件中被定义的，共享资源是在preload-resources中被定义的。其他Dalvik进程是被zygote卵进程孵化出来的，所以这些类和资源加载后，新的Dalvik进程就可以直接使用这些类和资源就达到了共享目的，就像一个细胞分裂成两个，共享一些基因和营养。 zygote进程对应的程序是app_process,该程序在system/bin目录下。 zygote孵化出的第一个Dalvik进程是SystemServer，该进程对应的程序依然是app_process,因为该进程是从app_process中孵化出来的。 SystemServer中创建了一个Socket客户端（生产线经理），之后所有的Dalvik进程都将通过该Socket客户端间接被启动，Ams负责管理这个客户端。如果需要启动新的APK进程时，Ams会通过该Socket客户端向zygote进程的Socket服务端（生产线工人）发送一个启动命令，然后zygote会孵化出新的进程（产品生产成型）。 这样的架构有两个特点： 每一个进程都是一个Dalvik虚拟机，Dalvik虚拟机是一种类似于java虚拟机的程序。 zygote进程会预先装载共享类和共享资源，提供营养液和基因，这些类和资源其实就是SDK中定义的大部分类和资源。当通过zygote孵化出新进程后，新的APK只需要去加载APK自身包含的类和资源，这样多个APK就可以共享Framework资源了。 和Dalvik虚拟机关系比较好的可执行程序有哪些？1.dalvikvmjava程序运行时都是由一个虚拟机来解释java字节码，将这些字节码翻译成本地CPU指令码然后执行。dalvikvm的作用就是创建一个虚拟机并执行参数中指定的java类。 2.dvzdvz的作用是从zygote进程中孵化出一个新的进程，新进程其实就是一个Dalvik虚拟机。该进程与dalvikvm启动的虚拟机相比，区别是该进程中已经预装了Framework的大部分类和资源。 3.app_processFramework在启动时需要加载运行两个特定java类，一个是ZygoteInit.java，一个是SystemServer.java。为了方便使用，系统才提供了一个app_process进程，该进程会自动运行这两个类，app_process其实就是使用dalvikvm启动ZygoteInit.java，启动后会加载Framework中得大部分类和资源。 Zygote是如何启动的？1.在init.rc中配置Zygote启动参数2.启动Socket服务端口当Zygote服务从app_process开始启动后，会启动一个Dalvik虚拟机，虚拟机第一个执行的java类就是ZygoteInit.java，该类第一个重要的工作就是启动一个Socket服务端口，该Socket端口用于接收启动新进程的命令。 3.加载preload-classes在Zygote类的main（）函数中，创建完Socket服务端后还不能立即孵化出新的进程，因为这个“卵”还没有必须的“基因”，这个“基因”就是指预装的Framework大部分类及资源。 4.加载preload-resourcespreload-resources包含两类资源，一类是drawable资源，一类是color资源。加载这些资源是在preloadResource（）函数中完成的，该函数调用preloadDrawable（）和preloadColorStateLists（）加载这两类资源，原理就是把这些资源读出来放到一个全局变量中，只要该类对象不被销毁，这些全局变量就会一直保存。 5.使用fork启动新的进程fork是Linux系统的一个系统调用，作用就是复制当前进程产生一个新的进程，相当于生物的克隆。除了进程id不同，新进程将拥有和原始进程完全相同的进程信息。进程的信息包括该进程所打开的文件描述符列表、所分配的内存等。当新进程被创建后，两个进程将共享已经分配的内存空间，如果其中一个需要向内存中写入数据时，操作系统才复制一份目标地址空间，并将要写的数据写入到新的地址中。这种“仅当写的时候才复制”的机制可以最大限度的在多个进程中共享物理内存。 举个栗子：去乌镇见一下习大大和去乌镇吃一次丁磊的猪肉，这是两个进程，但是两个进程中的很多任务是相同的，先订机票，做地铁到机场，做几小时飞机过去。到了之后不同的就是见习大大和吃猪肉。如果可以先雇一个秘书进程让它订机票、做地铁、做飞机，到乌镇。然后秘书在复制出两个秘书，一个去见习大大，一个去吃猪肉，好处是节省了大量内存。 Zygote进程就是本例中的“秘书进程”，那些“订机票、做地铁、乘飞机”就是Zygote进程中加载的preload-classes类的功能。 这样新的进程就脱离的Zygote进程的孵化成为一个真正的应用进程。 SystemServer 进程是如何启动的？SystemServer进程是Zygote孵化出的第一个进程，然后再配置SystemServer进程的环境。 1.启动各种系统服务线程SystemServer进程在Android运行环境中扮演了“神经中枢”的作用，APK应用中能够直接交互的大部分系统服务都在该进程中运行，常见的有WindowManagerServer（Wms）、ActivityManagerService（Ams）、PackageManagerServer（Pms），这些系统服务都是以一个线程的方式存在于SystemServer进程中。 2.启动第一个Activity当以上服务线程都启动后，其中Ams服务是systemReady（）调用完成最后启动的，在Ams的systemReady（）函数的最后一段代码则发出了启动任务队列中最上面一个Activity消息。 在Ams的startHomeActivityLocked（）中，系统发出了一个category字段包含CATEGORY_HOME的intent，代码如下： 1234intent.setComponent(mTopComponent);if(mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL)&#123;intent.addCategory(Intent.CATEGORY_HOME);&#125; 只要应用声明自己能够响应该Intent，那么就可以被认为是Home程序。当系统中有多个程序能够响应该Intent时，系统会弹出一个对话框，让用户选择启动哪个程序，也允许用户记住该选择。 到此第一个Activity就启动了。 如有问题请留言，转载请注明出处。","categories":[],"tags":[]},{"title":"Android 一个窗口是怎么创建出来的？","slug":"Android-一个窗口是怎么创建出来的？","date":"2017-02-03T09:46:19.000Z","updated":"2017-02-07T06:52:58.000Z","comments":true,"path":"2017/02/03/Android-一个窗口是怎么创建出来的？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-一个窗口是怎么创建出来的？/","excerpt":"在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。","text":"在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。 前言在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。 WmS并不在意该窗口是哪个应用程序的，关心的是活跃窗口，WmS按一定得规则判断哪个窗口处于活动状态，然后把用户消息给W类，W类再把用户消息传递给内部View变量，然后再由View对象完成剩下的消息处理。 窗户有几种类型？Framework定义了三种窗口类型，三种窗口类型的定义在WindowManager类里面。 应用窗口。应用窗口一般指该窗口对应一个Activity，由于加载Activity是由Ams完成的，所以对于应用程序创建应用类窗口只能在Activity内部完成。 子窗口。子窗口是指该窗口必须要有一个父窗口，父窗口可以是一个应用类窗口也可以是任何其他的窗口。 系统窗口。系统窗口不需要对应任何Activity，也不需要有父窗口。应用程序是没有办法创建系统窗口的，只有系统进程可以创建系统窗口。 那么该怎么创建应用窗口呢？1.每个应用类窗口都对应一个Activity对象，所以创建应用类窗口需要创建Activity对象。当AmS要启动某个Activity时就会通知客户端进程，每个客户端进程都对应一个ActivityThread类，所以需要ActivityThread启动Activity。 启动某个Activity实际是构造一个Activity对象，使用ClassLoader从程序文件中装载指定的Activity对应的Class文件。 2.创建完成Activity对象后调用Activity的attach（）方法，attach（）的作用就是为刚刚创造好的Activity设置内部变量。 3.为该Activity创建Window对象。 4.给Window对象中的mWindowManager变量赋值。 5.然后就需要给该窗口添加真正的View或者ViewGroup。从performLaunchActivity（）调用callActivityOnCreate（）开始，然后经一系列调用到Activity的onCreate（）方法，在onCreate（）方法中调用setContentView（）方法实际是调用了其对应的Window对象的setContentView（）方法。 6.接着会调用到PhoneWindow的setContentView，首先调用installDecor（）为Window类添加窗口装饰，其实就是标题栏，程序中设置的layout.xml界面被包含在窗口装饰中，就是窗口内容。窗口装饰也是ViewGroup，窗口装饰和它内部的内容加起来就是我们所说的窗口，或者叫做Window界面。 7.把创建的窗口通知WmS，让WmS把窗口显示在屏幕上。当Activity准备好后会通知Ams，然后Ams经过一系列调用到Activity的makeVisible（），该方法将真正完成把窗口添加进Wms中。 8.在makeVisible方法中，首先获得该Activity内部的WindowManager对象，然后调用该对象的addView（）方法。 9.调用WindowManagerImpl的addView（）方法，流程如下： 检查添加的窗口是否已经添加过，不能重复添加。 如果添加的窗口是子窗口类型，找到父窗口并保存在临时变量panelParentView中，该变量作为后面调用ViewRoot的setView（）参数。 创建一个新的ViewRoot 调用ViewRoot的setView（）。 10.完成新建一个ViewRoot对象后，需要把新建的ViewRoot对象添加到mRoots对象中。 11.调用ViewRoot对象的setView方法。流程如下： 给ViewRoot的重要变量赋值。 调用requestLayout（），发出界面重绘请求。 调用sWindowSession.add（），通知Wms添加窗口。 创建子窗口或系统窗口过程和上面的类似。","categories":[],"tags":[]},{"title":"Android Context 到底是什么？","slug":"Android-Context-到底是什么？","date":"2017-02-03T09:44:37.000Z","updated":"2017-02-07T06:56:39.000Z","comments":true,"path":"2017/02/03/Android-Context-到底是什么？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-Context-到底是什么？/","excerpt":"一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。","text":"一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。 什么是Android Context？一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。 那么从安卓程序的角度来看，Context是什么？其实一个Activity就是一个Context，一个Service也是一个Context。 一个应用程序可以认为是一个约会环境，用户在这个环境中会切换到不同的场景，比如先去有情调的饭店吃饭，再去电影院看个电影，然后再去xxx（此处省略一万字…）。 Activity类的确是基于Context，而Service类也是基于Context。Activity除了基于Context类外，还实现了一些其他重要的接口，从架构设计的角度看，interface仅仅是某些功能，而extends才是类的本质，即Activity的本质是一个Context，其所实现的其他接口只是为了扩充Context的功能而已，扩充后的类称之为一个Activity或Service。 一个应用程序中应该有多少个Context对象我们在应用程序开发中经常会调用Context的一些方法，这些方法看起来似乎会返回一些全局的对象，而不仅仅是某个Activity，可能会有点疑问，一个应用程序到底有多少个Context对象呢？比如，Context.getResources（）返回该应用程序所对应的Resource类对象，无论从哪个Activity中调用，都会返回同一个Resource对象。 一个Activity就是一个场景（Context），一个Service也是一个场景，所以，应用程序中有多少个Activity或者Service就会有多少个Context对象，也就是有多少个场景。 getResource（）等方法返回的是同一个全局对象。 Context 继承关系是怎么样的呢？ Context类本身是一个纯abstract类。为了使用方便又定义了Context包装类-ContextWrapper，穿上了一身装备显得也比较强大，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中有attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象。 ContextThemeWrapper内部包含了与主题相关的接口，这里的主题就是指在AndroidManifest.xml中通过android：theme为Application或者Activity指定的主题。 只有Activity才需要主题，Service默默的后台工作者不需要穿的那么鲜艳，所以Service直接继承于ContextWrapper。 ContextImpl类真正实现了Context中所有的函数，真正的八块腹肌，我们所调用的各种Context类的方法其实实现均来自于该类。 什么时候创建的Context?每一个应用程序在客户端都是从ActivityThread类开始的，创建Context对象也是在该类中完成，具体创建ContextImpl类的地方一共有6处： PackageInfo.makeApplication（） performLaunchActivity（） handleCreateBackupAgent（） handleCreateService（） handleBindApplication（） attach（） 其中attach（）方法仅在Framework进程启动时调用，应用程序运行时不会调用到该方法。 Application对应的Context程序第一次启动时，会辗转调用到makeApplication（）方法。具体代码如下： 1234ContextImpl appContext = new ContextImpl();appContext.init(this,null,mActivityThread);....appContext.setOuterContext(app); Activity对应的Context启动Activity时，Ams会通过IPC调用到ActivityThread的scheduleLaunchActivity（）方法，该方法包含两种参数。一种是ActivityInfo，这是一个实现了Parcelable接口的数据类，意味着该对象是Ams创建的，并通过IPC传递到ActivityThread；另一种是其他的一些参数。 scheduleLaunchActivity（）方法中会根据以上两种参数构造一个本地ActivityRecord数据类，ActivityThread内部会为每一个Activity创建一个ActivityRecord对象，并使用这些数据对象来管理Activity。 然后会调用handleLaunchActivity（），再调用performLaunchActivity（），该方法中创建ContextImpl的代码如下： 123ContextImpl appContext = new ContextImpl();appContext.init(r.packageInfo,r.token,this);appContext.setOuterContext(activity); 在performLaunchActivity（）开始执行时，会为r.packageInfo变量赋值。r.packageInfo对象的PackageInfo对象和Application对应的packageInfo对象是同一个。 Service对应的Context启动Service时，Ams会通过IPC调用到ActivityThread的scheduleCreateService（）方法，该方法也包含两种参数。第一种是ServiceInfo，这是实现了一个Parcelable接口的数据类，该对象由AmS创建，并通过IPC传递到ActivityThread内部；第二种是其他参数。 在scheduleCreateService（）方法中，会使用以上两种参数构造一个CreateServiceData的数据对象，ActivityThread会为其所包含的每一个Service创建该数据对象，并通过这些对象来管理Service。 然后在执行handleCreateService（）方法，创建ContextImpl对象代码如下： 1234ContextImpl appContext = new ContextImpl();appContext.init(packageInfo,null,this);...appContext.setOuterContext(service); Service对应的Context对象内部的mPackageInfo与Activity、Application中是完全相同的。 这几个Context之间的关系从以上可以看出，创建Context对象的过程基本上是相同的，不同的仅仅是针对Application、Activity、Service使用了不同的数据对象。 一个应用程序包含的Context个数应该为：Context个数 = Service个数+Activity个数+1，最后的1是Application类本身也会对应一个Context对象。 应用程序中包含多个ContextImpl对象，而内部变量mPackageInfo却指向同一个PackageInfo对象，这种设计结构一般意味着ContextImpl是一种轻量级类，而PackageInfo是一个重量级类。事实上确实是这样，ContextImpl中的大多数进行包操作的重量级函数实际上都是转向了mPackageInfo对象相应的方法，也就是事实上调用了同一个PackageInfo对象。","categories":[],"tags":[]},{"title":"我眼中的Android Framework","slug":"我眼中的Android-Framework","date":"2017-02-03T09:40:58.000Z","updated":"2017-02-07T06:53:19.000Z","comments":true,"path":"2017/02/03/我眼中的Android-Framework/","link":"","permalink":"http://yoursite.com/2017/02/03/我眼中的Android-Framework/","excerpt":"在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言","text":"在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言 我眼中的Android Framework在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言 任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。Android framework包含三个小伙伴：服务端、客户端、linux驱动。 服务端 服务端主要包含两个狠重要的类：WindowManagerService（WMS）和ActivityManagerService（AMS） 客户端客户端包含以下类： ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是UI线程或者称为主线程。 Activity：ActivityThread会根据用户的操作选择让哪个Activity对象上它的船。 PhoneWindow：富二代，继承于牛气的Window类，自己屋里住着一个DecorView对象，像它老爸喜欢制定规则提供了一些通用窗口操作API。 Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作API。它不喜欢被人管所以呢，注意：WindowManagerService管理的窗口不是Window类，其实是View和ViewGroup。 DecorView：很能干的家伙，家产来自FrameLayout，比较注重外在喜欢打扮，DecorView是对FrameLayout进行了一些修饰，从名字就可以看出来。 ViewRoot：小管家继承于Handler，主要作用是把WMS的IPC调用转换为本地的一个异步调用。 W类：ViewRoot小助手，继承于binder，是ViewRoot内部类。主要帮助ViewRoot实现把WMS的IPC调用转换为本地的一个异步调用。 WindowManager：客户端如果想创建一个窗口得先告诉WindowManager一声，然后它再和WindowManagerService交流一下看看能不能创建，客户端不能直接和WMS交互。 Linux驱动 Linux驱动和Framework相关的主要是两个部分：画家SurfaceFlingger和快递员Binder。 每一个窗口都对应一个画Surface，SF主要是把各个Surface显示到同一屏幕上。Binder是提供跨进程的消息传递。 从apk程序的运行过程去看看上面各个组件在啥时候干啥活的ActivityThread从main()函数中就开始动起来，然后调用prepareMainLooper()为UI线程创建一个消息快递通道即MessageQueue。 接着创建ActivityThread对象，创建过程会创建一个消息装卸工Handler对象和一个快递员Binder对象，其中Binder负责接收远程Ams的IPC调用，接收到调用后让Handler把消息装到消息快递队列，UI线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。 然后UI线程让队列调用Looper.loop()方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。 当ActivityThread接收到Ams发送start某个Activity的快递后就会创建指定的Activity对象。Activity会先按窗户再去按玻璃和贴窗花，所以先创建PhoneWindow-&gt;DecorView-&gt;创建相应的View或ViewGroup。创建完成后就可以让大家欣赏了，调用WindowManager把界面显示到屏幕上，然后创建ViewRoot，然后调用Wms提供的远程接口添加一个窗口并显示到屏幕上。 接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用Wms中的相应函数处理该消息。 很多线程是不是很晕？ 安卓程序中都有哪些线程？ 客户端小伙伴至少包含三个线程小弟，Activity启动后会创建一个ViewRoot.W对象，同时ActivityThread会创建一个ApplicationThread对象，这两个对象继承消息总管Binder，每个Binder对应一个线程，负责接收Linux Binder驱动发送的IPC调用。还有一个是UI线程呗。 UI线程是什么？ 一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。 自定义的线程和UI线程有什么区别？ UI线程是从ActivityThread运行的，在该类的main()方法中已经使用了Looper.prepareMainLooper()为该线程添加了Looper对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在Activity中去定义Handler对象，因为创建Handler对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的Thread则没有默认创建消息队列，所以不能直接在Thread中直接定义Handler，这个就是我们不懂程序运行原理导致的困惑。","categories":[],"tags":[]},{"title":"Android 设计模式-单例模式","slug":"Android-设计模式-单例模式","date":"2017-02-03T09:35:12.000Z","updated":"2017-02-07T06:57:10.000Z","comments":true,"path":"2017/02/03/Android-设计模式-单例模式/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-设计模式-单例模式/","excerpt":"什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用","text":"什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用 Android 设计模式-单例模式什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用 设计单例模式1234567891011public class Singleton&#123;private static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123;if(mSingleton == null)&#123; mSingleton = new Singleton();\\\\A &#125; return mSingleton; &#125;&#125; 上面的做法在多线程的时候会出现问题，比如有两个线程同时调用getInstance(),这时会new两个对象出来。 单例模式改进112345678910111213public class Singleton&#123;private static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; synchronized(Singleton.class)&#123; if(mSingleton == null)&#123; mSingleton = new Singleton();\\\\A &#125; return mSingleton; &#125; &#125;&#125; 这种方式还是会有问题，就是高并发情况下多线程去抢夺锁，假如有几百个线程，其中有一个运气比较差，这个线程就会出现一直去getInstance，资源一直返回不回去，UI也不会得到更新。 单例模式改进21234567891011121314public class Singleton&#123;private volatile static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; if(mSingleton == null)&#123;\\\\A synchronized(Singleton.class)&#123;\\\\C if(mSingleton == null) mSingleton = new Singleton();\\\\B &#125; &#125; return mSingleton; &#125;&#125; 注：volatile是防止cpu进行指令重排序，防止代码顺序被更改。这种方式比较好的地方在于第一次创建实例时候就会同步所有的线程，以后再获取实例就会直接返回。 但是看代码好像还是有人会有疑问，为什么需要两次判断为null？其实这个意义在于防止多个线程同时进入第一个if内，比如说线程A执行到A行，线程B执行到B行，线程B还没有返回。当线程A执行到C行，这时线程B初始化实例完毕，如果没有里面的再一次判断就会生成两个实例！所以两次的判断null还是有意义的。","categories":[],"tags":[]},{"title":"东半球最好的TV桌面开源项目","slug":"东半球最好的TV桌面开源项目","date":"2017-02-03T09:14:46.000Z","updated":"2017-02-07T06:53:33.000Z","comments":true,"path":"2017/02/03/东半球最好的TV桌面开源项目/","link":"","permalink":"http://yoursite.com/2017/02/03/东半球最好的TV桌面开源项目/","excerpt":"这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。","text":"这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。 欢迎在GitHub或者CSDN上关注我GitHub: https://github.com/JackyAndroid CSDN: http://blog.csdn.net/rain_butterfly AndroidTVLauncher 这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。 注意CatLauncher(Leanback风格) 目前功能已基本稳定，后续会跟进官方Leanback库的进展，Compatible桌面理论上不再维护 特性 Leanback风格 图片展示 视频直播（节操播放器-基于ijkplayer） 媒体详情 第三方应用列表 桌面特殊功能 效果图 下一步的改进 跟进官方Leanback库新功能 LicenseApache License, Version 2.0","categories":[],"tags":[{"name":"AndroidTV,开源","slug":"AndroidTV-开源","permalink":"http://yoursite.com/tags/AndroidTV-开源/"}]}]}