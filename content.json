{"meta":{"title":"墨镜猫","subtitle":null,"description":"求知若渴，大智若愚","author":"Jacky","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2017-01-26T03:45:19.000Z","updated":"2020-03-08T12:41:22.531Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 崇尚技术、热爱开源，曾经在滴滴、乐视、映客工作过。 阶段成就 技术深度广度无障碍 两个以上两千星的开源项目 多语言栈 千人大会演讲经验 社交信息 Github：https://github.com/JackyAndroid 站点：http://www.jackywang.tech/ 微信：sunglasses_cat 公众号 公众号基本会和网站同步发布文章，关注公众号等待文章更新也许是个不错的选择，虽然不怎么更新。"},{"title":"标签","date":"2020-03-08T12:52:58.000Z","updated":"2020-03-08T12:54:49.874Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"虽然假期过去了，但一定不要再次辜负你的新年愿望","date":"2017-02-04T08:40:56.000Z","updated":"2020-03-08T06:13:01.478Z","comments":true,"path":"plan/index.html","permalink":"http://yoursite.com/plan/index.html","excerpt":"","text":"我们每个人在过去 12 个月都有大把机会去反省自己的缺点，但鲜少有人能努力提前完成理想转变。 计划2020 kotlin open source commiter 2019 Linux Unix 多元化 2018 依赖管理器 Pins结构 IDEA引用搜索原理 加固 Linux相关 Atlas 框架解析 2017 JVM 原理 Dalvik 原理 Python 教程 Groovy RxJava 源码解析 OkHttp 源码解析 Glide 源码解析 VirtualAPK 源码解析 Tinker 源码解析 书单2020 邓小平时代 2019 Unix编程艺术 Linux系统编程 大话设计模式 程序员必读之软件架构 中国通史纪录片 2018 原则 孤独深处 人之彼岸 Swift 教程 深入理解Java虚拟机学习笔记 2017 Android源码设计模式解析与实战 Android源代码情景分析 简明python教程 Thinking in java 失控 科技想要什么 必然 幽默沟通 健康 每周跑步锻炼 饮食营养均衡 自我成长 学会与他人高效充分的沟通，锻炼自己演讲能力及外语水平 锻炼商业分析能力 旅行2-3次"}],"posts":[{"title":"kotlin 语义语法分析原理","slug":"Kotlin-语义语法分析原理","date":"2019-08-26T12:20:37.000Z","updated":"2019-10-23T14:12:22.089Z","comments":true,"path":"2019/08/26/Kotlin-语义语法分析原理/","link":"","permalink":"http://yoursite.com/2019/08/26/Kotlin-语义语法分析原理/","excerpt":"kotlin 语义语法分析原理","text":"kotlin 语义语法分析原理 kotlin 语义语法分析原理语义相关源码路径：compiler:psi-&gt;lexer kotlin 语义分析使用的是JFlex，JFlex是Java的词法分析器。 kotlin是自定义了语义分析说明文件，利用JFlex做词法分析。 说明文件路径：lexer-&gt;Kotlin.flex，里面自定义了用户代码、参数设置、词法规则等。最后生成的文件为：_JetLexer，KotlinLexer引用了 _JetLexer ，所以具体的词法分析就是通过KotlinLexer去分析。 KotlinLexer被引用在PsiBuilder，而PsiBuilder是用在PsiParser接口中用来解析并生成语法树的，实现PsiParser接口的具体类为：KotlinParser，所以入口在这，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class KotlinParser implements PsiParser &#123; public KotlinParser(Project project) &#123; &#125; @Override @NotNull public ASTNode parse(@NotNull IElementType iElementType, @NotNull PsiBuilder psiBuilder) &#123; throw new IllegalStateException(\"use another parse\"); &#125; // we need this method because we need psiFile @NotNull public ASTNode parse(IElementType iElementType, PsiBuilder psiBuilder, PsiFile psiFile) &#123; KotlinParsing ktParsing = KotlinParsing.createForTopLevel(new SemanticWhitespaceAwarePsiBuilderImpl(psiBuilder)); String extension = FileUtilRt.getExtension(psiFile.getName()); if (extension.isEmpty() || extension.equals(KotlinFileType.EXTENSION) || (psiFile instanceof KtFile &amp;&amp; ((KtFile) psiFile).isCompiled())) &#123; ktParsing.parseFile(); &#125; else &#123; ktParsing.parseScript(); &#125; return psiBuilder.getTreeBuilt(); &#125; @NotNull public static ASTNode parseTypeCodeFragment(PsiBuilder psiBuilder) &#123; KotlinParsing ktParsing = KotlinParsing.createForTopLevel(new SemanticWhitespaceAwarePsiBuilderImpl(psiBuilder)); ktParsing.parseTypeCodeFragment(); return psiBuilder.getTreeBuilt(); &#125; @NotNull public static ASTNode parseExpressionCodeFragment(PsiBuilder psiBuilder) &#123; KotlinParsing ktParsing = KotlinParsing.createForTopLevel(new SemanticWhitespaceAwarePsiBuilderImpl(psiBuilder)); ktParsing.parseExpressionCodeFragment(); return psiBuilder.getTreeBuilt(); &#125; @NotNull public static ASTNode parseBlockCodeFragment(PsiBuilder psiBuilder) &#123; KotlinParsing ktParsing = KotlinParsing.createForTopLevel(new SemanticWhitespaceAwarePsiBuilderImpl(psiBuilder)); ktParsing.parseBlockCodeFragment(); return psiBuilder.getTreeBuilt(); &#125; @NotNull public static ASTNode parseLambdaExpression(PsiBuilder psiBuilder) &#123; KotlinParsing ktParsing = KotlinParsing.createForTopLevel(new SemanticWhitespaceAwarePsiBuilderImpl(psiBuilder)); ktParsing.parseLambdaExpression(); return psiBuilder.getTreeBuilt(); &#125; @NotNull public static ASTNode parseBlockExpression(PsiBuilder psiBuilder) &#123; KotlinParsing ktParsing = KotlinParsing.createForTopLevel(new SemanticWhitespaceAwarePsiBuilderImpl(psiBuilder)); ktParsing.parseBlockExpression(); return psiBuilder.getTreeBuilt(); &#125;&#125; 更新中…","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/tags/Kotlin/"}]},{"title":"完全公平调度器","slug":"完全公平调度器","date":"2019-08-25T12:03:12.000Z","updated":"2019-08-26T11:20:51.071Z","comments":true,"path":"2019/08/25/完全公平调度器/","link":"","permalink":"http://yoursite.com/2019/08/25/完全公平调度器/","excerpt":"读书笔记，Linux 系统编程 第六章高级进程管理","text":"读书笔记，Linux 系统编程 第六章高级进程管理 完全公平调度器Linux调度器为完全公平调度器，简称为CFS。和最近华为鸿蒙提出的确定时延调度相反。 完全公平调度器和传统的Unix调度器有很大的区别。在大多数Unix系统中，包括引入CFS之前的Linux系统，在进程调度中存在两个基本的基于进程的因素：优先级和时间片。在传统的进程调度器中，会给每个就绪进程分配一个时间片。进程可能会一直运行直到消耗完分配给它的时间片。调度器会给每个进程分配优先级。进程调度器会先调度优先级高的进程，再调度优先级低的进程。这个调度算法非常简单，而且对于早期的基于时间片共享的Unix系统效果良好。但对于交互和公平性的系统而言，如现代计算机的桌面和移动设备，该算法就有些差强人意了。 完全公平调度器引入了一种不同的算法，成为公平调度，它消除了时间片作为处理器分配单元，而是给每个进程分配了处理器的分配比例。 算法逻辑如下：CFS最初给N个进程分别分配1/N的处理器时间。然后CFS通过优先级（nice值）权衡每个进程的比例，调整分配。默认的优先级为0，权值是1，则比例不变。优先级的值设置的越小（优先级越高），权值就越高，就增加给该进程的处理器比例值；优先级的值设置的越高（优先级越低），权值越低，就减少分配给该进程的比例值。 通过这种方式，CFS就基于权值分配给了每个进程处理器比例。要确定每个进程真正的执行时间，CFS需要把比例划分为一个固定周期，这个周期叫目标延迟，表示系统的调度延迟。 举个例子：假设目标延迟设置为20ms，有两个优先级相同的进程，那每个进程分配到的时间就是10ms。这样CFS就会先执行一个进程运行10ms，再执行另一个进程运行10ms，不断反复。 如果当前有200个进程怎么办，延迟如果是20ms，那每个进程只能分配到100微秒。这样大部分时间就会浪费在切换进程的上下文，CFS引入最小粒度解决这个问题。 “最小粒度”是指任意进程运行时间的基准值。所有进程，不管分配到处理器的时间比例是多少，都会至少运行最小粒度的时间。这种机制可以保证不会大部分时间浪费在进程切换上。 通过给进程分配处理器资源比例，而不是固定的时间片，CFS可以实现公平性。CFS也支持可配置的时间延迟。CFS中，进程按配额运行，时间片是根据系统可运行的进程数动态变化的，解决了传统调度器对于交互进程和IO约束性进程所面临的很多问题。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"ApkBus开发者千人大会演讲记录","slug":"ApkBus开发者千人大会演讲记录","date":"2019-05-05T12:01:25.000Z","updated":"2019-08-25T12:07:12.263Z","comments":true,"path":"2019/05/05/ApkBus开发者千人大会演讲记录/","link":"","permalink":"http://yoursite.com/2019/05/05/ApkBus开发者千人大会演讲记录/","excerpt":"里程碑记录。","text":"里程碑记录。 4.20号被安卓巴士社区邀请做了一场千人演讲，今天把演讲内容记录下。 大家上午好，今天我分享的主题是关于Android工程效率方面的，仓库依赖管理器。 个人简介 我先简单介绍下，我常用的网络ID是墨镜猫和JackyWang，我在github的star，java方面的话有四千七百多，总的star在一万两千多，在深圳java分类排名应该可以排到前三。我之前在滴滴和乐视工作过，现在在TCL·雷鸟。 开源贡献 给大家说下我这几年对开源社区的贡献，原创的项目有7个，贡献的代码有39.4w行，和8个国家12个地区的开发者一起维护其中的3个项目，其中两个仓库在各自的类别里面排到了前三。 我是从14年开始做开源，一直到现在，中间换了一次ID，所以你们看到我的账号是从16年开始的。我14年开始做开源的时候，当时是做了一个小项目放了上去，后来就过了一年多时间，突然有一天有一个爱尔兰的程序员给我发邮件，说你做的这个开源项目还可以，正好我们这有一个可以合作的项目，后来我们就聊了聊，大概意思就是想让我根据我那个开源项目给他们做下定制，价钱大概是三千美金。这件事对我触动还是非常大的，开源社区就像你和世界上其他人沟通的一个窗口一样，可以把你和任意位置的人连接起来，并产生价值。从那之后就一直做开源到现在，收获的远比我之前想象的要多得多，认识了很多有趣的人、见识到了世界级的项目是什么样的还认识了像Facebook、微软这种级别企业的Hr，开源社区的价值还是非常大的。 仓库维护的痛点 接下来说下依赖管理器，我们先看下这张图，一个常见的依赖关系图，这个就像一个倒立的大树一样，每一个叶子都是一个仓库，树根就是主客户端，树里面每个叶子之间也有很复杂的依赖关系，如果这个时候监控这个叶子出现了问题，就像这样，依赖他的上面的十几个叶子都会受到影响。 假如你改动了一个仓库，比如这个监控仓库，受影响的有依赖他的十几个仓库，就是这个图里面红色箭头指的地方，每个受影响的仓库都得升级到修复过后的版本，去一一验证，而且这个过程非常容易反复，比如你修复了一个问题，对日志生效了，但对图像又产生了问题，再修复，再发版本，还要再把十几个仓库升级再去验证，不停的重复这个过程，浪费很多时间。 那怎么去提升仓库的维护效率，减少验证的次数？ 解决方案 那有没有更彻底更高效的方式，在主工程里面把十几个受影响的仓库一次性验证完，只验证一次行不行。 那怎么才能实现只验证一次呢？就是把受影响的线上仓库，转为本地的可修改可编辑的源码仓库。比如我现在要修复监控仓库，我把线上监控仓库转为本地源码仓库。 上面受影响的十几个仓库依赖的都是本地的源码仓库，而不是线上地址。这样有问题只需要在本地监控仓库修复，改完后对依赖监控的十几个仓库同时有效。这样就可以了，对吧？ 那关键是怎么把线上仓库转为源码仓库，最原始的方式就是把线上的地址在工程里面注释掉，把源码工程include进来。这种方式对于较复杂的项目来说，成本太高，也不可维护。 我们是希望只需要一个开关，就可以灵活的切换线上线下依赖。打开就是本地源码工程，关闭就是线上依赖。我们看下该怎么去实现。 关键点 配置语言怎么选？ 首先配置该怎么选？配置可选的方式有很多种，json、xml、dsl或者其他的配置语言。json、xml在结构化扩展方面还是挺强的，但是一旦结构变得复杂，可读性就会比较差，我们看下这个对比图，左边是DSL，右边是同样结构的JSON描述，很显然json阅读起来还是挺困难的，关于DSL有一句话挺有意思，“你以为这是一句话，其实这是一段脚本” 动态加载DSL 解析json和xml其实都比较简单，就是读文件就好了，但是对于dsl这种怎么办？ 关于dsl文件其实本质上还是一个脚本，关于dsl有句话也是这么说的，你以为这是一句话 其实这是一个脚本。所以我们首先还是去动态加载这个脚本，在groovy里面提供了groovyshell，可以加载任意的groovy脚本，调用evaluate方法就可以加载独立的groovy 脚本，evaluate方法可以接受脚本字符、文件、Uri都可以。加载脚本之后，我们还需要拿到我们在dsl里面配置的信息，就是pod里面的东西，就是在定义脚本的地方，定义一个接受闭包的函数，函数名为pod，当groovyshell去加载脚本的时候，遇到pod配置，就会被这个函数接收，然后就可以把我们在项目中配置的dsl信息拿到。 简单来讲，就是通过groovyshell去执行这个dsl脚本，每一个pod可以看成是一个函数调用，括号里面的就是传进去的参数值，调用这个函数的声明就是这样写，然后我们就可以拿到我们在项目中的配置。这样就完成了dsl的动态加载。 动态包含任意地址本地仓库 首先，包含进来的项目才能依赖，所以第一步我们需要能动态的include本地任意路径的源码模块。在gradle 初始化阶段加载settings.gradle 时候，去apply我们的插件，这个时候可以拿到settings实例，这个和配置阶段拿到的project是不一样的，settings里面有个很重要的接口include，include里面填上我们配置的项目名称就可以了，和我们直接在settings.gradle里面直接写include是一样的，不一样的是我们这个是动态的。然后需要对我们刚刚include进去的project指定路径，settings里面可以通过project拿到我们指定名称的项目描述，在这个描述里面可以配置路径，任意的本地路径。 动态去除线上、添加本地仓库 经过之前的准备，终于到了最后一步，按照我们的配置去修改这个依赖关系了。 第一步，怎么把线上的依赖去除掉？在gradle配置阶段，我们每一个project都会apply我们的插件，apply的时候我们就可以拿到当前project实例，这和上面那个初始化阶段是不一样的，那个拿的是settings实例，我们通过project里面的configuration，可以去配置我们需要去除的线上依赖信息，configuration的exclude接口接收的是一个map，在这个map里配置我们在DSL里面配置的name和group就可以了。 下一步，我们需要把我们之前include进来的project，添加到我们的项目中去，通过我们当前的project实例，拿到当前工程的依赖关系，这个依赖是一个DependencyHandler，这个handler使用来描述依赖关系的，通过handler的add接口就可以把我们的本地仓库依赖动态添加进去，add接口接收buildtype和project实例，buildtype就是我们平常依赖使用的compile api implementation这些东西。 总的来说，通过配置信息把我们需要去除的依赖填进去，通过DependencyHandler把我们本地的project依赖添加进去，这样就实现了动态替换，线上依赖切换为线下依赖。 流程 然后我们看下实现流程，大概分为两个流程，初始化阶段和配置阶段，在gradle初始化阶段会先解析dsl，然后把需要调试的模块include 进来，在这中间可以做很多事情，比如我想依赖的是问题修复的分支，那就配置下分支名称就可以，执行自定义的hook命令。在gradle配置阶段，根据我们dsl的配置信息，去在依赖树里去寻找需要替换的节点，就像一个毛毛虫一样，去反复的去查找需要替换的叶子，找到后发现需要替换，就把需要调试的线上模块替换成本地的模块。因为仓库变多后，dsl的配置变多，所以我这还有一个辅助生成dsl的任务，他会自动扫描当前哪些是我们可以调试的，比如我们内部的maven仓库，把依赖树的信息转换为dsl，这个功能目前还在测试阶段，还没开源出来。 总的来说，大致分为两个流程，初始化阶段先把工程include进来，配置阶段再把线上依赖去除，添加本地依赖。 我们回顾下，这个插件解决的是什么问题？解决的是maven仓库依赖复杂，修复的过程繁琐。那是怎么去做的？用DSL配置仓库的基本信息，在gradle初始化阶段插件动态include仓库的源码工程，在配置阶段插件动态去除线上依赖、动态添加本地依赖，这样就做到了动态替换的效果，提升我们的维护效率，对吧。 效果 我们看下效果，首先我们现在的主工程是monitor sample，在项目根目录配置一个dsl文件，内容的话就是这样，每一个仓库对应一个pod，pod里面有开关，项目的name和group就是对应一个线上地址（图里面线上地址和pod对应）然后把需要调试的模块打开，重新sync工程，这时候上面就会出现本地的源码仓库，然后线上仓库就会被转为线下源码仓库，这时候可以对需要修复的仓库编辑、调试、验证功能、发布，只需要验证一次，节省很多时间。 我在举一个实际的例子吧，比如说我们现在有一个30人的团队，这三十人分成6个业务线，每个业务线都依赖了我们底层的网络库，网络库针对每个业务线都有相应的缓存及加密策略。如果这时候需要修改网络库的缓存策略，先在网络库的源工程里面去做修改，然后再发布到内网的maven服务器，然后再升级各个业务线的网络库版本号，再去验证，如果修改的功能不能满足需求，还得重新走上面的流程，浪费很多时间。那把网络库的依赖通过插件转为本地依赖，是不是就可以一次验证完了？对各个业务线验证完成之后再发布，不会重复的去走发布-验证这个流程，节省很多时间。 今天分享基本就是这些，然后这些是我的联系方式github、个人网站和我的微信，大家如果有疑问在交流群里或微信问我都可以，谢谢大家。 花絮这张图片是上午场的讲师们的合影。 左三是gityuan，其余都是一线公司的大牛们。","categories":[],"tags":[{"name":"随记","slug":"随记","permalink":"http://yoursite.com/tags/随记/"}]},{"title":"Kotlin 实践及原理","slug":"Kotlin-实践及原理","date":"2019-01-30T02:59:25.000Z","updated":"2019-05-10T12:07:05.092Z","comments":true,"path":"2019/01/30/Kotlin-实践及原理/","link":"","permalink":"http://yoursite.com/2019/01/30/Kotlin-实践及原理/","excerpt":"关于Kotlin在项目中的实践经验，及在Android平台的编译原理","text":"关于Kotlin在项目中的实践经验，及在Android平台的编译原理 Kotlin 实践及原理语法回顾常量与变量 Java 12String name = \"Amit Shekhar\";final String name = \"Amit Shekhar\"; Kotlin 12var name = \"Amit Shekhar\"val name = \"Amit Shekhar\" 空判断 Java 123if (text != null) &#123; int length = text.length();&#125; Kotlin 1val length = text?.length() 字符串拼接 Java 123String firstName = \"Amit\";String lastName = \"Shekhar\";String message = \"My name is: \" + firstName + \" \" + lastName; Kotlin 123val firstName = \"Amit\"val lastName = \"Shekhar\"val message = \"My name is: $firstName $lastName\" 三元表达式 Java 1String text = x &gt; 5 ? \"x &gt; 5\" : \"x &lt;= 5\"; Kotlin 1val text = if (x &gt; 5) \"x &gt; 5\" else \"x &lt;= 5\" 更灵活的case语句 Java 123456789101112131415161718192021222324int score = // some score;String grade;switch (score) &#123; case 10: case 9: grade = \"Excellent\"; break; case 8: case 7: case 6: grade = \"Good\"; break; case 5: case 4: grade = \"OK\"; break; case 3: case 2: case 1: grade = \"Fail\"; break; default: grade = \"Fail\";&#125; Kotlin 12345678var score = // some scorevar grade = when (score) &#123; 9, 10 -&gt; \"Excellent\" in 6..8 -&gt; \"Good\" 4, 5 -&gt; \"OK\" in 1..3 -&gt; \"Fail\" else -&gt; \"Fail\"&#125; 方法定义 Java 1234int getScore() &#123; // logic here return score;&#125; Kotlin 12345678fun getScore(): Int &#123; // logic here return score&#125;// as a single-expression functionfun getScore(): Int = score Get Set 构造器 Java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Developer &#123; private String name; private int age; public Developer(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Developer developer = (Developer) o; if (age != developer.age) return false; return name != null ? name.equals(developer.name) : developer.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125; @Override public String toString() &#123; return \"Developer&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; Kotlin 1data class Developer(val name: String, val age: Int) 类继承、实现接口 Java 123public class Child extends Parent implements IHome &#123; &#125; kotlin 123class Child : Parent(), IHome &#123; &#125; 与Java互操作相互调用12345678910111213import java.util.*fun demo(source: List&lt;Int&gt;) &#123; val list = ArrayList&lt;Int&gt;() // “for”-循环用于 Java 集合： for (item in source) &#123; list.add(item) &#125; // 操作符约定同样有效： for (i in 0..source.size - 1) &#123; list[i] = source[i] // 调用 get 和 set &#125;&#125; 空安全与平台类型12345val list = ArrayList&lt;String&gt;() // 非空（构造函数结果）list.add(\"Item\")val size = list.size // 非空（原生 int）val item = list[0] // 推断为平台类型（普通 Java 对象）item.substring(1) // 允许，如果 item == null 可能会抛出异常 静态字段1234567891011121314151617// 文件 example.ktobject Obj &#123; const val CONST = 1&#125;class C &#123; companion object &#123; const val VERSION = 9 &#125;&#125;const val MAX = 239int c = Obj.CONST;int d = ExampleKt.MAX;int v = C.VERSION; kotlin 实践经验优点 语法简洁，能比java减少40%的代码，也能节约大量的时间 语法级别的安全 目前版本已较为稳定 缺点 可能会有额外的开销 少量的特性支持的还不健全，尤其在与Java互操作上，比如lateinit特性 坑、隐藏开销kotlin代码是很简洁，但是简洁下面有时候会隐藏较大的开销。 伴生对象 如果我们需要创建类似Java中的静态成员，需要创建伴生对象，伴生对象通过companion object 创建，如下： 12345class Test &#123; companion object &#123; val version = 0 &#125;&#125; 转换为同等的Java代码，如下： 1234567891011121314151617public final class Test &#123; private static final int version = 0; public static final Test.Companion Companion = new Test.Companion((DefaultConstructorMarker)null); public static final class Companion &#123; public final int getVersion() &#123; return Test.version; &#125; private Companion() &#123; &#125; public Companion(DefaultConstructorMarker $constructor_marker) &#123; this(); &#125; &#125;&#125; 也就是会多产生一次的函数调用开销，不过可以把val version 改为 const val version 避免这个问题 装箱拆箱 12345class Test &#123; val a: IntArray = intArrayOf(1) val b: Array&lt;Int&gt; = arrayOf(1) val c: Array&lt;Int?&gt; = arrayOf(null)&#125; 转为Java如下： 123456@NotNullprivate final int[] a = new int[]&#123;1&#125;;@NotNullprivate final Integer[] b = new Integer[]&#123;1&#125;;@NotNullprivate final Integer[] c = new Integer[]&#123;(Integer)null&#125;; 后两种产生了装箱处理，产生开销 For循环 kotlin 提供了downTo step until reversed函数简单使用循环，但这些函数组合使用也有可能产生较多的临时对象。 回滚Tools -&gt;Kotlin -&gt;Show Kotlin Bytecode -&gt; Decompile Kotlin 编译原理我们对kotlin比较大的疑问可能是kotlin是怎么和java混编的？或者说kotlin是怎么生成字节码的 kotlin整个都是开源的，可以从github clone下来，地址：https://github.com/JetBrains/kotlin 整个工程很庞大，源代码大概有四百多万行，可以使用 IntelliJ IDEA查看整个工程，具体操作可以看github 项目主页的建议。 编译流程图： kotlin的maven id 为kotlin-gradle-plugin，我们做下全局搜索，发现路径为：root/libraries/tools/kotlin-gradle-plugin 每个插件都会有入口类，我们在module配置时都会添加：apply plugin: ‘kotlin-android’，kotlin-android代表的就是配置入口类文件的名字，所以我们看下下kotlin-android.properties文件内容，如下： 1implementation-class=org.jetbrains.kotlin.gradle.plugin.KotlinAndroidPluginWrapper 我们看到插件入口类为 KotlinAndroidPluginWrapper，接下来我们就从这个入口类分析下kotlin编译过程。 KotlinAndroidPluginWrapper 源码如下： 1234567open class KotlinAndroidPluginWrapper @Inject constructor( fileResolver: FileResolver, protected val registry: ToolingModelBuilderRegistry) : KotlinBasePluginWrapper(fileResolver) &#123; override fun getPlugin(project: Project, kotlinGradleBuildServices: KotlinGradleBuildServices): Plugin&lt;Project&gt; = KotlinAndroidPlugin(kotlinPluginVersion, registry)&#125; 真正的实现是在 KotlinAndroidPlugin 中，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839internal open class KotlinAndroidPlugin( private val kotlinPluginVersion: String, private val registry: ToolingModelBuilderRegistry) : Plugin&lt;Project&gt; &#123; override fun apply(project: Project) &#123; val androidTarget = KotlinAndroidTarget(\"\", project) val tasksProvider = AndroidTasksProvider(androidTarget.targetName) applyToTarget( project, androidTarget, tasksProvider, kotlinPluginVersion ) registry.register(KotlinModelBuilder(kotlinPluginVersion, androidTarget)) &#125; companion object &#123; fun applyToTarget( project: Project, kotlinTarget: KotlinAndroidTarget, tasksProvider: KotlinTasksProvider, kotlinPluginVersion: String ) &#123; // 省略无关代码 val variantProcessor = if (compareVersionNumbers(version, legacyVersionThreshold) &lt; 0) &#123; LegacyAndroidAndroidProjectHandler(kotlinTools) &#125; else &#123; val android25ProjectHandlerClass = Class.forName(\"org.jetbrains.kotlin.gradle.plugin.Android25ProjectHandler\") val ctor = android25ProjectHandlerClass.constructors.single &#123; it.parameterTypes.contentEquals(arrayOf(kotlinTools.javaClass)) &#125; ctor.newInstance(kotlinTools) as AbstractAndroidProjectHandler&lt;*&gt; &#125; variantProcessor.handleProject(project, kotlinTarget) &#125; &#125;&#125; 插件加载首先执行的是apply函数，跟进applyToTarget函数，省略掉无关代码，重点在最后一句handleProject 12345678910fun handleProject(project: Project, kotlinAndroidTarget: KotlinAndroidTarget) &#123; // ignore .. forEachVariant(project) &#123; processVariant( it, kotlinAndroidTarget, project, ext, plugin, kotlinOptions, kotlinConfigurationTools.kotlinTasksProvider ) &#125; // ignore ..&#125; 省略掉无关代码，可以代码在processVariant，跟进去看下 123456789101112131415private fun processVariant( variantData: V, target: KotlinAndroidTarget, project: Project, androidExt: BaseExtension, androidPlugin: BasePlugin, rootKotlinOptions: KotlinJvmOptionsImpl, tasksProvider: KotlinTasksProvider) &#123; // ignore .. // 创建 kotlin 任务 val kotlinTask = tasksProvider.createKotlinJVMTask(project, kotlinTaskName, compilation) // ignore .. wireKotlinTasks(project, compilation, androidPlugin, androidExt, variantData, javaTask, kotlinTask)&#125; 其中会创建 kotlin 任务，创建任务入口先留意一下，先看下 wireKotlinTasks 实现： 12345678910111213override fun wireKotlinTasks( project: Project, compilation: KotlinJvmAndroidCompilation, androidPlugin: BasePlugin, androidExt: BaseExtension, variantData: BaseVariantData&lt;out BaseVariantOutputData&gt;, javaTask: AbstractCompile, kotlinTask: KotlinCompile) &#123; kotlinTask.dependsOn(*javaTask.dependsOn.toTypedArray()) configureJavaTask(kotlinTask, javaTask, logger)&#125; configureJavaTask 比较可疑，跟进去看下： 12345internal fun configureJavaTask(kotlinTask: KotlinCompile, javaTask: AbstractCompile, logger: Logger) &#123; // ignore .. javaTask.dependsOn(kotlinTask) // ignore ..&#125; 我们看到函数核心是定义了kotlin task在java task之前执行，ok，那我们接下来跟进kotlin task的实现，我们返回上面的创建kotlin task的地方：tasksProvider.createKotlinJVMTask(project, kotlinTaskName, compilation)，跟进去： 1234567891011open fun createKotlinJVMTask( project: Project, name: String, compilation: KotlinCompilation): KotlinCompile &#123; val properties = PropertiesProvider(project) val taskClass = taskOrWorkersTask&lt;KotlinCompile, KotlinCompileWithWorkers&gt;(properties) return project.tasks.create(name, taskClass).apply &#123; configure(this, project, properties, compilation) &#125;&#125; 大致意思就是根据任务名称创建任务，任务名称就来自泛型中定义的两个，那我们选择KotlinCompileWithWorkers，看下是如何定义的。 12345internal open class KotlinCompileWithWorkers @Inject constructor( @Suppress(\"UnstableApiUsage\") private val workerExecutor: WorkerExecutor) : KotlinCompile() &#123; override fun compilerRunner() = GradleCompilerRunnerWithWorkers(this, workerExecutor)&#125; 看来是覆写了父类的compilerRunner，我们跟进去看看GradleCompilerRunnerWithWorkers的实现： 123456789101112131415internal class GradleCompilerRunnerWithWorkers( task: Task, private val workersExecutor: WorkerExecutor) : GradleCompilerRunner(task) &#123; override fun runCompilerAsync(workArgs: GradleKotlinCompilerWorkArguments) &#123; project.logger.kotlinDebug &#123; \"Starting Kotlin compiler work from task '$&#123;task.path&#125;'\" &#125; // todo: write tests with Workers enabled; workersExecutor.submit(GradleKotlinCompilerWork::class.java) &#123; config -&gt; config.isolationMode = IsolationMode.NONE config.forkMode = ForkMode.NEVER config.params(workArgs) &#125; &#125;&#125; 核心是提交了一个 runnable，这就比较明确了，我们看下GradleKotlinCompilerWork的实现，重点看run的实现： 1234567891011121314override fun run() &#123; // ignore .. val exitCode = try &#123; compileWithDaemonOrFallbackImpl() &#125; catch (e: Throwable) &#123; clearLocalStateDirectories(log, localStateDirectories, \"exception when running compiler\") throw e &#125; finally &#123; if (buildFile != null &amp;&amp; System.getProperty(DELETE_MODULE_FILE_PROPERTY) != \"false\") &#123; buildFile.delete() &#125; &#125; // ignore ..&#125; run 里面的核心就是compileWithDaemonOrFallbackImpl函数，跟进去： 1234567private fun compileWithDaemonOrFallbackImpl(): ExitCode &#123; // ignore if (executionStrategy == DAEMON_EXECUTION_STRATEGY) &#123; val daemonExitCode = compileWithDaemon() &#125; // ignore &#125; 核心代码为：compileWithDaemon()，跟进去： 1234567891011121314151617181920212223private fun compileWithDaemon(): ExitCode? &#123; // ignore val targetPlatform = when (compilerClassName) &#123; KotlinCompilerClass.JVM -&gt; CompileService.TargetPlatform.JVM KotlinCompilerClass.JS -&gt; CompileService.TargetPlatform.JS KotlinCompilerClass.METADATA -&gt; CompileService.TargetPlatform.METADATA else -&gt; throw IllegalArgumentException(\"Unknown compiler type $compilerClassName\") &#125; val exitCode = try &#123; val res = if (isIncremental) &#123; incrementalCompilationWithDaemon(daemon, sessionId, targetPlatform) &#125; else &#123; nonIncrementalCompilationWithDaemon(daemon, sessionId, targetPlatform) &#125; exitCodeFromProcessExitCode(log, res.get()) &#125; catch (e: Throwable) &#123; log.warn(\"Compilation with Kotlin compile daemon was not successful\") e.printStackTrace() null &#125; // ignore return exitCode&#125; 选择编译平台，根据编译方式执行不同函数，我们选择nonIncrementalCompilationWithDaemon跟进去看下： 12345678private fun nonIncrementalCompilationWithDaemon( daemon: CompileService, sessionId: Int, targetPlatform: CompileService.TargetPlatform): CompileService.CallResult&lt;Int&gt; &#123; // ignore return daemon.compile(sessionId, compilerArgs, compilationOptions, servicesFacade, compilationResults = null)&#125; 继续，目前跟进到CompileServiceImpl#compile，忽略无关重点如下： 123456789doCompile(sessionId, daemonReporter, tracer = null) &#123; _, _ -&gt; val compiler = when (targetPlatform) &#123; CompileService.TargetPlatform.JVM -&gt; K2JVMCompiler() CompileService.TargetPlatform.JS -&gt; K2JSCompiler() CompileService.TargetPlatform.METADATA -&gt; K2MetadataCompiler() &#125; as CLICompiler&lt;CommonCompilerArguments&gt; compiler.exec(messageCollector, Services.EMPTY, k2PlatformArgs)&#125; 继续，忽略意义不大的跳转到K2JVMCompiler#doExecute，如下： 1234567891011121314151617181920212223242526272829override fun doExecute( arguments: K2JVMCompilerArguments, configuration: CompilerConfiguration, rootDisposable: Disposable, paths: KotlinPaths?): ExitCode &#123; // ignore try &#123; if (arguments.buildFile != null) &#123; KotlinToJVMBytecodeCompiler.configureSourceRoots(configuration, moduleChunk.modules, buildFile) KotlinToJVMBytecodeCompiler.compileModules(environment, buildFile, moduleChunk.modules) &#125; else if (arguments.script) &#123; return KotlinToJVMBytecodeCompiler.compileAndExecuteScript(environment, scriptArgs) &#125; else &#123; KotlinToJVMBytecodeCompiler.compileBunchOfSources(environment) &#125; return OK &#125; catch (e: CompilationException) &#123; messageCollector.report( EXCEPTION, OutputMessageUtil.renderException(e), MessageUtil.psiElementToMessageLocation(e.element) ) return INTERNAL_ERROR &#125;&#125; 其中的KotlinToJVMBytecodeCompiler看起来是比较重要，跟进去其中一个分支看下： 12345678910111213fun compileBunchOfSources(environment: KotlinCoreEnvironment): Boolean &#123; // 词法 语法 分析 val generationState = analyzeAndGenerate(environment) ?: return false // 查找主类 val mainClass = findMainClass(generationState, environment.getSourceFiles()) // 写入文件 try &#123; writeOutput(environment.configuration, generationState.factory, mainClass) return true &#125; finally &#123; generationState.destroy() &#125;&#125; 看来已经找到关键函数入口了，跟进去analyzeAndGenerate，转到KotlinCodegenFacade#doGenerateFiles，如下： 12345678910public static void doGenerateFiles( @NotNull Collection&lt;KtFile&gt; files, @NotNull GenerationState state, @NotNull CompilationErrorHandler errorHandler) &#123; state.getCodegenFactory().generateModule(state, files, errorHandler); CodegenFactory.Companion.doCheckCancelled(state); state.getFactory().done();&#125; 跟进去CodegenFactory，关注generate开头的函数，又经过无数跳转到，MemberCodegen#genSimpleMember： 123456789101112131415161718192021222324public void genSimpleMember(@NotNull KtDeclaration declaration) &#123; if (declaration instanceof KtNamedFunction) &#123; try &#123; functionCodegen.gen((KtNamedFunction) declaration); &#125; catch (ProcessCanceledException | CompilationException e) &#123; throw e; &#125; catch (Exception e) &#123; throw new CompilationException(\"Failed to generate function \" + declaration.getName(), e, declaration); &#125; &#125; else if (declaration instanceof KtProperty) &#123; try &#123; propertyCodegen.gen((KtProperty) declaration); &#125; catch (ProcessCanceledException | CompilationException e) &#123; throw e; &#125; catch (Exception e) &#123; throw new CompilationException(\"Failed to generate property \" + declaration.getName(), e, declaration); &#125; &#125;&#125; 具体的生成细节，如果是function就由functionCodegen生成，如果属性就由propertyCodegen生成，跟进去functionCodegen： 12345678public void gen(@NotNull KtNamedFunction function) &#123; if (owner.getContextKind() != OwnerKind.DEFAULT_IMPLS || function.hasBody()) &#123; // ignore generateMethod(JvmDeclarationOriginKt.OtherOrigin(function, functionDescriptor), functionDescriptor, strategy); &#125; // ignore&#125; 忽略无关的跳转，转到： 12345678910111213141516171819202122232425262728293031323334353637383940414243private void generateMethodBody( @NotNull JvmDeclarationOrigin origin, @NotNull FunctionDescriptor functionDescriptor, @NotNull MethodContext methodContext, @NotNull FunctionGenerationStrategy strategy, @NotNull MethodVisitor mv, @NotNull JvmMethodSignature jvmSignature, boolean staticInCompanionObject) &#123; OwnerKind contextKind = methodContext.getContextKind(); if (!state.getClassBuilderMode().generateBodies || isAbstractMethod(functionDescriptor, contextKind)) &#123; generateLocalVariableTable( mv, jvmSignature, functionDescriptor, getThisTypeForFunction(functionDescriptor, methodContext, typeMapper), new Label(), new Label(), contextKind, typeMapper, Collections.emptyList(), 0); mv.visitEnd(); return; &#125; if (!functionDescriptor.isExternal()) &#123; generateMethodBody(mv, functionDescriptor, methodContext, jvmSignature, strategy, memberCodegen, state.getJvmDefaultMode(), state.getLanguageVersionSettings().supportsFeature(LanguageFeature.ReleaseCoroutines)); &#125; else if (staticInCompanionObject) &#123; // native @JvmStatic foo() in companion object should delegate to the static native function moved to the outer class mv.visitCode(); FunctionDescriptor staticFunctionDescriptor = JvmStaticInCompanionObjectGenerator .createStaticFunctionDescriptor(functionDescriptor); Method accessorMethod = typeMapper.mapAsmMethod(memberCodegen.getContext().accessibleDescriptor(staticFunctionDescriptor, null)); Type owningType = typeMapper.mapClass((ClassifierDescriptor) staticFunctionDescriptor.getContainingDeclaration()); generateDelegateToStaticMethodBody(false, mv, accessorMethod, owningType.getInternalName(), false); &#125; endVisit(mv, null, origin.getElement());&#125; 代码中有几个地方 visitor 还有 visitEnd，我们看下具体的引用： 1234import org.jetbrains.org.objectweb.asm.*;import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter;import org.jetbrains.org.objectweb.asm.commons.Method;import org.jetbrains.org.objectweb.asm.util.TraceMethodVisitor; 看来是利用ASM框架去生成字节码，例子： 12345678910111213// 如果生成一个类使用ClassWriterClassWriter cw = new ClassWriter(0);// 定义类的方法cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_ABSTRACT, \"compareTo\", \"(Ljava/lang/Object;)I\",null, null).visitEnd();// 完成cw.visitEnd(); // 将cw转换成字节数组byte[] data = cw.toByteArray();// 写入文件File file = new File(\"/Users/test/Comparable.class\");FileOutputStream fout = new FileOutputStream(file);fout.write(data);fout.close(); ok，kotlin的编译过程基本就是，插件 - kotlin任务 - 编译器 - 生成方法、属性 - 利用ASM生成字节码 Kotlin 跨平台kotlin 在语法上是支持跨平台的，是编译期跨平台，而不是容器类跨平台，目前支持JS、iOS、Server。","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/tags/kotlin/"}]},{"title":"加固","slug":"加固","date":"2018-10-30T11:50:07.000Z","updated":"2019-02-01T09:31:48.734Z","comments":true,"path":"2018/10/30/加固/","link":"","permalink":"http://yoursite.com/2018/10/30/加固/","excerpt":"加固需要什么样的知识？","text":"加固需要什么样的知识？ 加固近期有机会研究了下加固技术，发现涉及的知识面非常广泛，专门记录下。 加固技术通常按代来分。 第一代就是我们通常可见的混淆，把代码转换为a b c d 这样的字符，这样做的目的就是增加阅读难度，看到的代码和实际的代码结构是有区别的，但是这样关键源码还是可以获取到的。 后来，想着能不能对代码进行加密，在运行时在解密，这样就有了第二代技术，就是针对Dex的加密或者变形，让破坏者得到的是坏掉的文件或者加密过的文件，相当于在第一代的时候，我们是把钱撕成几段，但是还是可以被别人拼成完好的钱的，后来我们就把钱锁到了保险柜里面，这样比第一代安全了些。 这个时候的关键就是该把保险柜的钥匙放在哪？加密算法如果放在Java层面还是容易被人反编拿到，放在C层看起来好像是安全了些，但是其他人还是可以试探性的获取相应的密钥，就像你是把钥匙放在门口的垫子下面，还是交给保姆，交给保姆也没办法保证熟人花言巧语把钥匙骗过来，对吧。但是相比把钱直接摆在外边已经安全了很多。 第二代的通用做法就是加壳，简单的理解就是打包的时候放进去的是加密的Dex文件，在运行的时候在动态解密，再用classloader动态加载，达到加密的目的。 涉及到的技术 JVM 原理 Dalvik 原理 Art 优化原理 Api 各个版本的兼容性 等等 VMP技术持续更新。。。","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"Linux I/O 多路复用","slug":"Linux-I-O-多路复用","date":"2018-09-10T12:32:57.000Z","updated":"2019-02-01T09:31:48.747Z","comments":true,"path":"2018/09/10/Linux-I-O-多路复用/","link":"","permalink":"http://yoursite.com/2018/09/10/Linux-I-O-多路复用/","excerpt":"神秘的多路复用，我们看看在系统层级是怎么实现的？","text":"神秘的多路复用，我们看看在系统层级是怎么实现的？ 读书笔记，Linux 系统编程第二章，I/O 多路复用 Linux 提供了三种I/O多路复用方案：select、poll和epoll。 select()更新中。。。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"IntelliJ IDEA 引用搜索原理","slug":"IntelliJ IDE 搜索引用如何实现？","date":"2018-05-22T02:43:56.000Z","updated":"2019-02-01T09:31:48.712Z","comments":true,"path":"2018/05/22/IntelliJ IDE 搜索引用如何实现？/","link":"","permalink":"http://yoursite.com/2018/05/22/IntelliJ IDE 搜索引用如何实现？/","excerpt":"IntelliJ IDEA 如何实现引用搜索？","text":"IntelliJ IDEA 如何实现引用搜索？ IntelliJ IDEA 我们都很熟悉，强大的开源IDE。Android Studio 就是基于IDEA社区版开发的。平常我们会经常使用到Find Usage 功能，查找一个类或者方法的引用，那我们看看它内部是如何实现的？ IDEA 在Github上是开源的，地址：https://github.com/JetBrains/intellij-community。clone 下来可以直接用它自己打开，感觉很奇妙，自己可以开发自己:-D IDEA整个源码量是非常庞大的，只是Java和Python源代码加起来就有四百多万行。从这样庞大的项目中找到某个功能的入口，寻找相应的测试用例是个比较好的方法，那我们试着搜下有没有Find Usage的测试用例，果然在com.intellij.java.psi.search包下有个类是FindUsagesTest，继续看下这个类里面有没有我们想要的入口，测试用例里面大部分都引用了一个函数：ReferencesSearch.search，看来感觉有点像，跟进去看看这个函数的定义： 1234567891011/** * Searches for references to the specified element in the scope in which such references are expected to be found, according to * dependencies and access rules. * * @param element the element (declaration) the references to which are requested. * @return the query allowing to enumerate the references. */@NotNullpublic static Query&lt;PsiReference&gt; search(@NotNull PsiElement element) &#123; return search(element, GlobalSearchScope.allScope(PsiUtilCore.getProjectInReadAction(element)), false);&#125; 大概就是根据搜索的范围，去找到这个element的引用，注意这个函数返回的是一个Query接口。 搜索引用大概就是这个函数了，继续跟进去。 123public static Query&lt;PsiReference&gt; search(@NotNull PsiElement element, @NotNull SearchScope searchScope, boolean ignoreAccessScope) &#123; return search(new SearchParameters(element, searchScope, ignoreAccessScope)); &#125; 根据上一步的参数组成搜索参数，忽略无关紧要的细节，继续。 12345678910111213141516171819/** * Searches for references to the specified element according to the specified parameters. * * @param parameters the parameters for the search (contain also the element the references to which are requested). * @return the query allowing to enumerate the references. */@NotNullpublic static Query&lt;PsiReference&gt; search(@NotNull final SearchParameters parameters) &#123; final Query&lt;PsiReference&gt; result = INSTANCE.createQuery(parameters); if (parameters.isSharedOptimizer) &#123; return uniqueResults(result); &#125; final SearchRequestCollector requests = parameters.getOptimizer(); final PsiElement element = parameters.getElementToSearch(); return uniqueResults(new MergeQuery&lt;&gt;(result, new SearchRequestQuery(PsiUtilCore.getProjectInReadAction(element), requests)));&#125; 这一步大概就是，创建了两个Query，然后进行了合并，返回UniqueResultsQuery，这里面的SearchRequestQuery感觉比较重要，先着重留意下。返回的Query，肯定是为了让上层调用查找接口，那我们看下这个Query里面的查找接口是如何实现的，如下 12345678@Override@NotNullpublic Collection&lt;T&gt; findAll() &#123; List&lt;T&gt; result = Collections.synchronizedList(new ArrayList&lt;&gt;()); Processor&lt;T&gt; processor = Processors.cancelableCollectProcessor(result); forEach(processor); return result;&#125; 这个意思就比较清楚了，把一个结果的List作为引用经过处理，最后返回给上层。Processor只是把结果List进行暂存，处理还是在forEach里面，forEach里面还是调用了myOriginal的Query的forEach，如下： 123private boolean process(@NotNull Set&lt;M&gt; processedElements, @NotNull Processor&lt;? super T&gt; consumer) &#123; return myOriginal.forEach(new MyProcessor(processedElements, consumer));&#125; myOriginal就是刚刚的MergeQuery，那看下MergeQuery里面的forEach做了什么，最后调用了processSubQuery，如下： 123private &lt;V extends T&gt; boolean processSubQuery(@NotNull Query&lt;V&gt; subQuery, @NotNull final Processor&lt;? super T&gt; consumer) &#123; return subQuery.forEach(consumer);&#125; 也就是MergeQuery最后调用了各个子Query的forEach，上面我们注意到SearchRequestQuery嫌疑比较大，先跟进去看下，forEach最后调用到了processResults，如下： 1234@Overrideprotected boolean processResults(@NotNull Processor&lt;? super PsiReference&gt; consumer) &#123; return PsiSearchHelper.getInstance(myProject).processRequests(myRequests, consumer);&#125; 里面调用到了PsiSearchHelper的processRequests，如下： 123456789101112131415161718@Overridepublic boolean processRequests(@NotNull SearchRequestCollector collector, @NotNull Processor&lt;? super PsiReference&gt; processor) &#123; ...... do &#123; ...... if (!processGlobalRequestsOptimized(globals, progress, localProcessors)) &#123; return false; &#125; for (RequestWithProcessor local : locals) &#123; progress.checkCanceled(); if (!processSingleRequest(local.request, local.refProcessor)) &#123; return false; &#125; &#125; ...... &#125; while (true);&#125; 其中省略掉了一些无关代码，注意到有个processGlobalRequestsOptimized还有个processSingleRequest，先看下processGlobalRequestsOptimized的实现，如下： 1234567891011121314private boolean processGlobalRequestsOptimized(@NotNull MultiMap&lt;Set&lt;IdIndexEntry&gt;, RequestWithProcessor&gt; singles, @NotNull ProgressIndicator progress, @NotNull final Map&lt;RequestWithProcessor, Processor&lt;PsiElement&gt;&gt; localProcessors) &#123; ...... if (singles.size() == 1) &#123; final Collection&lt;? extends RequestWithProcessor&gt; requests = singles.values(); if (requests.size() == 1) &#123; final RequestWithProcessor theOnly = requests.iterator().next(); return processSingleRequest(theOnly.request, theOnly.refProcessor); &#125; &#125; ...... return result;&#125; 忽略掉无关代码，发现当请求为1的时候，还是调用了上层的processSingleRequest，那我们就先分析简单情况，跟进去看下实现，如下： 123456789private boolean processSingleRequest(@NotNull PsiSearchRequest single, @NotNull Processor&lt;? super PsiReference&gt; consumer) &#123; final EnumSet&lt;Options&gt; options = EnumSet.of(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE); if (single.caseSensitive) options.add(Options.CASE_SENSITIVE_SEARCH); if (shouldProcessInjectedPsi(single.searchScope)) options.add(Options.PROCESS_INJECTED_PSI); return bulkProcessElementsWithWord(single.searchScope, single.word, single.searchContext, options, single.containerName, adaptProcessor(single, consumer) );&#125; 先配置了请求参数，然后调用了bulkProcessElementsWithWord，先看下adaptProcessor实现，如下： 123456789101112131415161718@NotNullprivate static BulkOccurrenceProcessor adaptProcessor(@NotNull PsiSearchRequest singleRequest, @NotNull Processor&lt;? super PsiReference&gt; consumer) &#123; ...... final RequestResultProcessor wrapped = singleRequest.processor; return new BulkOccurrenceProcessor() &#123; @Override public boolean execute(@NotNull PsiElement scope, @NotNull int[] offsetsInScope, @NotNull StringSearcher searcher) &#123; ...... return LowLevelSearchUtil.processElementsAtOffsets(scope, searcher, !ignoreInjectedPsi, getOrCreateIndicator(), offsetsInScope, (element, offsetInElement) -&gt; &#123; if (ignoreInjectedPsi &amp;&amp; element instanceof PsiLanguageInjectionHost) return true; return wrapped.processTextOccurrence(element, offsetInElement, consumer); &#125;); &#125; &#125;;&#125; adaptProcessor最后还是调用了wrapped.processTextOccurrence调用，先留意下这个地方，从上一层继续向下看，bulkProcessElementsWithWord的实现，如下： 1234567891011121314151617private boolean bulkProcessElementsWithWord(@NotNull SearchScope searchScope, @NotNull final String text, final short searchContext, @NotNull EnumSet&lt;Options&gt; options, @Nullable String containerName, @NotNull final BulkOccurrenceProcessor processor) &#123; ...... if (searchScope instanceof GlobalSearchScope) &#123; StringSearcher searcher = new StringSearcher(text, options.contains(Options.CASE_SENSITIVE_SEARCH), true, searchContext == UsageSearchContext.IN_STRINGS, options.contains(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE)); return processElementsWithTextInGlobalScope((GlobalSearchScope)searchScope, searcher, searchContext, options.contains(Options.CASE_SENSITIVE_SEARCH), containerName, progress, processor); &#125; ...... return JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Arrays.asList(scopeElements), progress, localProcessor);&#125; 跟进去看下processElementsWithTextInGlobalScope的实现，如下： 123456789101112131415161718192021222324252627private boolean processElementsWithTextInGlobalScope(@NotNull final GlobalSearchScope scope, @NotNull final StringSearcher searcher, final short searchContext, final boolean caseSensitively, @Nullable String containerName, @NotNull ProgressIndicator progress, @NotNull final BulkOccurrenceProcessor processor) &#123; progress.pushState(); boolean result; try &#123; progress.setText(PsiBundle.message(\"psi.scanning.files.progress\")); String text = searcher.getPattern(); Set&lt;VirtualFile&gt; fileSet = new THashSet&lt;&gt;(); getFilesWithText(scope, searchContext, caseSensitively, text, fileSet); progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text)); final Processor&lt;PsiElement&gt; localProcessor = localProcessor(progress, searcher, processor); ...... result = fileSet.isEmpty() || processPsiFileRoots(new ArrayList&lt;&gt;(fileSet), fileSet.size(), 0, progress, localProcessor); &#125; finally &#123; progress.popState(); &#125; return result;&#125; localProcessor比较可疑，跟进去看下，如下： 123456789101112private static Processor&lt;PsiElement&gt; localProcessor(@NotNull final ProgressIndicator progress, @NotNull final StringSearcher searcher, @NotNull final BulkOccurrenceProcessor processor) &#123; return new ReadActionProcessor&lt;PsiElement&gt;() &#123; @Override public boolean processInReadAction(PsiElement scopeElement) &#123; ...... return scopeElement.isValid() &amp;&amp; processor.execute(scopeElement, LowLevelSearchUtil.getTextOccurrencesInScope(scopeElement, searcher, progress), searcher); &#125; &#125;;&#125; 终于，看到了processor的execute调用的地方，这个processor就是adaptProcessor返回的，执行的就是wrapped.processTextOccurrence，wrapped指向的processor就是SingleTargetRequestResultProcessor。 那这个wrapped是什么时候注入进来的呢？还记得在新建MergeQuery时有两个Query一个是Search，另一个就是ExecutorsQuery，这个Query在执行时会根据参数通过一系列流程把wrapped指向SingleTargetRequestResultProcessor类型的Processor 所以，最后是执行的SingleTargetRequestResultProcessor的processTextOccurrence，看下实现，如下： 12345678@Overridepublic boolean processTextOccurrence(@NotNull PsiElement element, int offsetInElement, @NotNull final Processor&lt;? super PsiReference&gt; consumer) &#123; ...... final List&lt;PsiReference&gt; references = ourReferenceService.getReferences(element, new PsiReferenceService.Hints(myTarget, offsetInElement)); ...... return true;&#125; 跟进去getReferences实现，一路跳转… 123456789101112131415161718192021222324252627282930private static PsiReferenceRegistrarImpl createRegistrar(Language language) &#123; ...... List&lt;PsiReferenceProviderBean&gt; referenceProviderBeans = REFERENCE_PROVIDER_EXTENSION.allForLanguageOrAny(language); for (final PsiReferenceProviderBean providerBean : referenceProviderBeans) &#123; final ElementPattern&lt;PsiElement&gt; pattern = providerBean.createElementPattern(); if (pattern != null) &#123; registrar.registerReferenceProvider(pattern, new PsiReferenceProvider() &#123; PsiReferenceProvider myProvider; @NotNull @Override public PsiReference[] getReferencesByElement(@NotNull PsiElement element, @NotNull ProcessingContext context) &#123; if (myProvider == null) &#123; myProvider = providerBean.instantiate(); if (myProvider == null) &#123; myProvider = NULL_REFERENCE_PROVIDER; &#125; &#125; return myProvider.getReferencesByElement(element, context); &#125; &#125;); &#125; &#125; registrar.markInitialized(); return registrar;&#125; 最终调用的是PsiReferenceProvider的getReferencesByElement，myProvider又是通过PsiReferenceProviderBean转化而来的，看下这里面做了什么事情，然后发现如下注释： 12345678910111213/** * Registers a &#123;@link PsiReferenceProvider&#125; in plugin.xml */public class PsiReferenceProviderBean extends AbstractExtensionPointBean implements KeyedLazyInstance&lt;PsiReferenceProviderBean&gt; &#123; public static final ExtensionPointName&lt;PsiReferenceProviderBean&gt; EP_NAME = new ExtensionPointName&lt;&gt;(\"com.intellij.psi.referenceProvider\"); @Attribute(\"language\") public String language = Language.ANY.getID(); @Attribute(\"providerClass\") public String className; 原来是在plugin.xml 里面注册PsiReferenceProvider类型的Class，用时再去反射实例化调用，那我们现在看看有哪些类继承了PsiReferenceProvider，其中的JavaClassReferenceProvider应该是我们想要的实现，跟进getReferencesByElement，又是一路跳转到JavaClassReferenceSet的reparse，终于找到了类引用搜索最核心的东西，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120private void reparse(@NotNull String str, @NotNull PsiElement element, final boolean isStaticImport, JavaClassReferenceSet context) &#123; myElement = element; myContext = context; List&lt;JavaClassReference&gt; referencesList = new ArrayList&lt;&gt;(); int currentDot = -1; int referenceIndex = 0; boolean allowDollarInNames = isAllowDollarInNames(); boolean allowSpaces = isAllowSpaces(); boolean allowGenerics = false; boolean allowWildCards = JavaClassReferenceProvider.ALLOW_WILDCARDS.getBooleanValue(getOptions()); boolean allowGenericsCalculated = false; boolean parsingClassNames = true; while (parsingClassNames) &#123; int nextDotOrDollar = -1; for (int curIndex = currentDot + 1; curIndex &lt; str.length(); ++curIndex) &#123; char ch = str.charAt(curIndex); if (ch == DOT || ch == DOLLAR &amp;&amp; allowDollarInNames) &#123; nextDotOrDollar = curIndex; break; &#125; if (ch == LT || ch == COMMA) &#123; if (!allowGenericsCalculated) &#123; allowGenerics = !isStaticImport &amp;&amp; PsiUtil.isLanguageLevel5OrHigher(element); allowGenericsCalculated = true; &#125; if (allowGenerics) &#123; nextDotOrDollar = curIndex; break; &#125; &#125; &#125; if (nextDotOrDollar == -1) &#123; nextDotOrDollar = currentDot + 1; for (int i = nextDotOrDollar; i &lt; str.length() &amp;&amp; Character.isJavaIdentifierPart(str.charAt(i)); ++i) nextDotOrDollar++; parsingClassNames = false; int j = skipSpaces(nextDotOrDollar, str.length(), str, allowSpaces); if (j &lt; str.length()) &#123; char ch = str.charAt(j); boolean recognized = false; if (ch == '[') &#123; j = skipSpaces(j + 1, str.length(), str, allowSpaces); if (j &lt; str.length() &amp;&amp; str.charAt(j) == ']') &#123; j = skipSpaces(j + 1, str.length(), str, allowSpaces); recognized = j == str.length(); &#125; &#125; Boolean aBoolean = JavaClassReferenceProvider.JVM_FORMAT.getValue(getOptions()); if (!recognized &amp;&amp; (aBoolean == null || !aBoolean.booleanValue())) &#123; nextDotOrDollar = -1; // abort resolve &#125; &#125; &#125; if (nextDotOrDollar != -1 &amp;&amp; nextDotOrDollar &lt; str.length()) &#123; char c = str.charAt(nextDotOrDollar); if (c == LT) &#123; boolean recognized = false; int start = skipSpaces(nextDotOrDollar + 1, str.length(), str, allowSpaces); int j = str.lastIndexOf(GT); int end = skipSpacesBackward(j, 0, str, allowSpaces); if (end != -1 &amp;&amp; end &gt; start) &#123; if (myNestedGenericParameterReferences == null) myNestedGenericParameterReferences = new ArrayList&lt;&gt;(1); myNestedGenericParameterReferences.add(new JavaClassReferenceSet( str.substring(start, end), myElement, myStartInElement + start, isStaticImport, myProvider, this)); parsingClassNames = false; j = skipSpaces(j + 1, str.length(), str, allowSpaces); recognized = j == str.length(); &#125; if (!recognized) &#123; nextDotOrDollar = -1; // abort resolve &#125; &#125; else if (c == COMMA &amp;&amp; myContext != null) &#123; if (myContext.myNestedGenericParameterReferences == null) myContext.myNestedGenericParameterReferences = new ArrayList&lt;&gt;(1); int start = skipSpaces(nextDotOrDollar + 1, str.length(), str, allowSpaces); myContext.myNestedGenericParameterReferences.add(new JavaClassReferenceSet( str.substring(start), myElement, myStartInElement + start, isStaticImport, myProvider, this)); parsingClassNames = false; &#125; &#125; int maxIndex = nextDotOrDollar &gt; 0 ? nextDotOrDollar : str.length(); int beginIndex = skipSpaces(currentDot + 1, maxIndex, str, allowSpaces); int endIndex = skipSpacesBackward(maxIndex, beginIndex, str, allowSpaces); boolean skipReference = false; if (allowWildCards &amp;&amp; str.charAt(beginIndex) == QUESTION) &#123; int next = skipSpaces(beginIndex + 1, endIndex, str, allowSpaces); if (next != beginIndex + 1) &#123; String keyword = str.startsWith(EXTENDS, next) ? EXTENDS : str.startsWith(SUPER, next) ? SUPER : null; if (keyword != null) &#123; next = skipSpaces(next + keyword.length(), endIndex, str, allowSpaces); beginIndex = next; &#125; &#125; else if (endIndex == beginIndex + 1) &#123; skipReference = true; &#125; &#125; if (!skipReference) &#123; TextRange textRange = TextRange.create(myStartInElement + beginIndex, myStartInElement + endIndex); JavaClassReference currentContextRef = createReference( referenceIndex, str.substring(beginIndex, endIndex), textRange, isStaticImport); referenceIndex++; referencesList.add(currentContextRef); &#125; if ((currentDot = nextDotOrDollar) &lt; 0) &#123; break; &#125; &#125; myReferences = referencesList.toArray(new JavaClassReference[0]);&#125; 很长，但是基本可以理解为就是一个简单的语言Parser，和我最初的猜想也是相符的，就是基于源文件字符解析，引用相关的信息都包含在返回的PsiReference列表里面。 IDEA 确实有一个优秀的架构，虽然也有槽点:-D","categories":[],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/源码分析/"}]},{"title":"Linux 文件I/O","slug":"Linux 文件","date":"2018-05-16T13:11:41.000Z","updated":"2019-02-01T09:31:48.737Z","comments":true,"path":"2018/05/16/Linux 文件/","link":"","permalink":"http://yoursite.com/2018/05/16/Linux 文件/","excerpt":"文件如何进行读写？","text":"文件如何进行读写？ 读书笔记，Linux 系统编程 第二章 文件I/O Unix 系统主要是通过文件表示的，因此这些章节会设计Unix系统的核心。 在对文件进行读写操作之前，首先需要打开文件。内核会为每个进程维护一个打开文件的列表，该列表就是文件表。文件表示由一些非负整数进行索引，这些非负整数称为文件描述符。列表的每一项是一个打开文件的信息，包括指向该文件索引节点内存拷贝的指针以及关联的元数据，如文件位置指针和访问模式。用户空间和内核空间都使用文件描述符作为唯一cookies，打开文件会返回文件描述符，后续操作都把文件描述符作为基本参数。 文件描述符使用C 语言的int类型表示。每个Linux 进程能开发的文件数是有上限的，文件描述符的范围从0开始，到上限值减一，默认情况下，上限值为1024，也可以对它进行配置，最大为1048576。因为负数不是合法的文件描述符，所以当函数出错不能返回有效的文件描述符时，通常会返回-1。 通常，每个进程至少包含三个文件描述符：0、1、2，除非显式关闭这些描述符。0表示标准输入、1表示标准输出、2表示标准错误。一般而言，stdin是连接到终端的输入设备（通常是键盘），而stdout和stderr是终端的屏幕。用户可以重定向这些文件描述符，甚至可以通过管道把一个程序的输出作为另一个程序的输入。shell正是通过这种方式实现重定向和管道的。 实际上，文件描述符也可以访问设备文件、管道、快速用户空间互斥、先进先出缓冲区和套接字。遵循一切皆文件的理念，几乎任何能够读写的东西都可以通过文件描述符来访问。 默认情况下，子进程会维护一份父进程的文件表副本。在副本中，打开文件列表和其访问模式、当前文件位置以及其他元数据，都和父进程维护的文件表相同，但是存在一点区别：当子进程关闭一个文件时，不会影响到父进程的文件表。虽然一般情况下子进程会自己持有一份文件表，但是子进程和父进程也可以共享文件表。 打开文件系统调用open如果系统调用open执行成功，会返回文件描述符，指向路径名 name 所指定的文件。文件位置即文件的起始位置（0），文件打开方式是根据参数flags值来确定。 flags 参数是由一个或多个标志位的按位或组合。支持三种访问模式：O_RDONLY、O_WRONLY 或 O_RDWR，这三种模式分别表示为只读、只写或读写。 flags 参数还可以和以下的值进行按位或运算，修改打开文件的行为； O_APPEND 文件以追加模式打开。也就是说，在每次写操作之前，将会更新文件位置指针，指向文件末尾。即使有另一个进程也在向该文件写数据，以追加模式打开的进程在最后一次写操作时，还是会更新文件位置指针，指向文件末尾。 O_ASYNC 这个标志位只适用于FIFO、管道、socket和终端，不适用于普通文件。 O_CLOEXEC 执行时关闭 标志位。在执行新的进程时，文件会自动关闭。 O_CREAT 当参数name指定的文件不存在时，内核自动创建。 O_DIRECT 打开文件用于直接I/O O_DIRECTORY 如果参数name不是目录，open调用会失败。 O_EXCL 当和标志位O_CREAT一起使用时，如果参数name指定的文件已经存在，会导致open调用失败，用于防止创建文件时出现竞争。 O_LARGEFILE 文件偏移使用64位整数表示，可以支持大于2GB文件。 O_NOATIME 在读文件时，不会更新该文件的最后访问时间。可以避免为了更新每个文件的索引节点而导致的大量写操作。等等… 新建文件所有者 确定新建文件的所有者很简单：文件所有者的uid即创建该文件的进程的有效uid。 creat函数 因为有些参数组合经常使用，因为专门有个系统调用提供这个功能：int creat(const char *name, mode_t mode); 这个函数名creat少了个e。UNIX之父Ken Thompson开玩笑说他在UNIX设计中感到最遗憾的就是漏掉了这个字母。 返回值和错误码 系统调用open和creat在成功时都会返回文件描述符。出错时，返回-1，并把errno设置成相应的错误值。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Android Pins 工程结构","slug":"Android Pins 工程结构","date":"2018-05-06T01:47:21.000Z","updated":"2019-05-10T12:01:16.925Z","comments":true,"path":"2018/05/06/Android Pins 工程结构/","link":"","permalink":"http://yoursite.com/2018/05/06/Android Pins 工程结构/","excerpt":"Pins 工程结构能解决什么问题？","text":"Pins 工程结构能解决什么问题？ 近期我们听到一些团队在做工程化方面的事情，其中都提到了Pins 工程结构，最先提出这个概念的是微信团队：微信Android模块化架构重构实践，在后来看到美团外卖也做了这个事情：美团外卖Android平台化架构演进实践。 那Pins工程结构是什么？ 上面这张图就是Pins工程结构。 那有什么用？或者能解决什么问题？ 如果你的产品有多条业务线，每一期产品有上百个需求，各个业务线业务之间有非常多的交集。比如，一个业务线引用了五个业务线，其他业务线也是类似的引用，依次类推，相互引用不重复的话为5的5次方等于3125，如果业务线增长这个复杂度也是呈几何数增长，那我们在现有的工程环境下如何做呢？简单的方法就是都放在同一个Gradle Module 里面相互引用，各个业务线之间用包名做区分，但是各个包之间也是可以相互引用，久而久之就会发现，代码变成了一锅粥…变成一锅粥的后果也是显然的，不能独立拆分，代码合并非常容易冲突浪费时间等等，各种后果。下图是微信业务之间的引用情况，实际情况可能比这更糟糕。 Pins结构就较好的解决了上面的问题，各个业务线之间都是一个Pins模块，模块之间根据规定引用该引用的，这样业务线之间的代码边界就会比较清楚。 接下来我们看下如何实现，这里只提供下简单思路。 业务构建改造 123456789101112sourceSets &#123; main &#123; def dirs = ['p_widget', 'p_theme', 'p_shop', 'p_shopcart', 'p_submit_order','p_multperson','p_again_order', 'p_location', 'p_log','p_ugc','p_im','p_share'] dirs.each &#123; dir -&gt; java.srcDir(\"src/$dir/java\") res.srcDir(\"src/$dir/res\") &#125; &#125;&#125; 上面的示例就简单实现了Pins结构，指定各模块到路径到srcDir，p_shop、p_shopcart等Pins模块构建时会合并到主工程。上面只是一个简单示例，实际情况可以做很多动态化控制，比如动态生成以及扫描当前路径下的Pins模块、根据配置动态合成Pins模块等等。下面是一个稍微复杂的例子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def src_dir = new File(projectDir, 'src')// 扫描当前模块下的Pins模块，并生成Listdef p_module_names = src_dir .list() .toList() .stream() .filter( new Predicate&lt;String&gt;() &#123; @Override boolean test(String name) &#123; return name == 'main' || (name.startsWith('p_') &amp;&amp; new File(src_dir, name).isDirectory()) &#125; &#125;) .collect(Collectors.toList())// 把生成的List合成为srcDir格式def p_src_dirs = p_module_names .stream() .map( new Function() &#123; @Override Object apply(Object module) &#123; return ['src', module, 'java'].join('/') &#125; &#125;) .collect(Collectors.toList())def p_res_dirs = p_module_names .stream() .map( new Function() &#123; @Override Object apply(Object module) &#123; return ['src', module, 'res'].join('/') &#125; &#125;) .collect(Collectors.toList())// 指定路径sourceSets &#123; main &#123; manifest.srcFile \"src/main/AndroidManifest.xml\" java.srcDirs = p_src_dirs res.srcDirs = p_res_dirs &#125; &#125; 代码边界检查 上面只是表面上把代码进行了分割，但是各Pins模块还是可以引用到其他模块的代码，一般的操作是根据模块的配置，在编译期做代码检查，检查是否引用了不该引用的模块。 那如何定义项目的配置，这个配置可以是文本文件、DSL等等，微信通过project.properties来指定编译依赖关系。 这里简单用groovy格式文件举例： 123456789101112131415161718192021222324252627282930313233343536373839task code_check &#123; doLast &#123; // 加载pins模块依赖文件 def dependenciesFile = new File(projectDir, 'src/p_module1/dependencies.groovy') def ref = null dependenciesFile.readLines().each &#123; ref = it &#125; // 扫描pins模块内部源文件 File javaDir = new File(projectDir, 'src/p_module1/java') Files.walkFileTree(javaDir.toPath(), new FileVisitor&lt;Path&gt;() &#123; @Override FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123; return FileVisitResult.CONTINUE &#125; @Override FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; file.readLines().each &#123; if (it.endsWith(ref)) &#123; System.err.println(\"p_module1模块引用了不能引用的模块！\") return FileVisitResult.TERMINATE &#125; &#125; return FileVisitResult.CONTINUE &#125; @Override FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException &#123; return FileVisitResult.CONTINUE &#125; @Override FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123; return FileVisitResult.CONTINUE &#125; &#125;) &#125;&#125; 定义一个任务，先从p_module1的dependencies文件里读出不能包含的模块，然后检索p_module1里面的文件是不是引用了这个模块，如果检查到就终止或抛出异常。 这里只是列举了一个思路，实现也比较粗暴，直接匹配的字符串。 当然，也可以做的比较完善，这些逻辑可以做在一个插件里，插件每次读取各个Pins模块的DSL配置（根据DSL的扩展性做更细粒度的依赖关系，比如只依赖另一个模块的某个包、某个类、某个资源等等），插件根据配置可以动态合成Pins，合成完Pins再做代码边界检查，边界检查可以用字符流匹配也可以用其他方式，提高字符流匹配准确性也可以做很多事情，比如匹配import行、类定义行、以及代码内的匹配（是真的字符串还是真的引用等等）。 Pins 工程的基本思路就是这样。","categories":[],"tags":[{"name":"工程化","slug":"工程化","permalink":"http://yoursite.com/tags/工程化/"}]},{"title":"仓库源码依赖管理器（三）","slug":"仓库源码依赖管理器（三）","date":"2018-05-04T03:34:06.000Z","updated":"2019-02-01T09:31:48.744Z","comments":true,"path":"2018/05/04/仓库源码依赖管理器（三）/","link":"","permalink":"http://yoursite.com/2018/05/04/仓库源码依赖管理器（三）/","excerpt":"如何动态替换依赖？","text":"如何动态替换依赖？ 前两篇我们说了下如何定义依赖描述文件，如何动态生成描述文件，那有了这些信息，我们该怎么去动态替换依赖？ 如果要把线上依赖替换为本地Project依赖，先要把本地Project include进当前业务工程。在这之前先加载依赖描述文件进内存，如下： 12def shell = new GroovyShell(this.getClass().getClassLoader())shell.evaluate(new File(\"依赖描述文件路径\")) 注：在依赖描述文件里，记得引用DSL使用的类，例： 12import xxx.Module@groovy.transform.BaseScript Module module 然后循环迭代依赖描述 List，根据描述信息include相应的工程，如下： 123def projectName = \":模块名字\"settings.include(projectName)settings.project(projectName).projectDir = new File(\"模块本地路径\") 到这一步，需要包含的Project已经包含了进来，在AS工程栏就可以看到包括进来的模块了。 需要替换的模块已经包含进来了，下一步就是根据依赖描述配置信息替换线上依赖，基本思路如下： 123456789101112131415161718192021222324252627project.afterEvaluate &#123; //寻找当前节点 def currentItem = modules.find &#123; project.name == it.name &#125; if (currentItem == null) return // 寻找子节点 List&lt;String&gt; seeds = currentItem.seeds if (seeds == null) return // 迭代子节点 seeds.each &#123; seedName -&gt; // 寻找子节点对象 def seed = modules.find &#123; it.name == seedName &#125; if (seed == null) return if (seed.on_off) &#123; // 根据模块名字和group去除线上依赖 Map&lt;String, String&gt; map = new HashMap&lt;&gt;() map.put(\"module\", seed.name) map.put(\"group\", \"xxx\") project.configurations.compile.exclude(map) // 添加本地Project依赖 project.dependencies.add(\"api\", project.dependencies.project([path: \":\" + seed.name])) &#125; &#125;&#125; 现在线上依赖已经替换为本地模块，在代码里点击相应模块的引用已经自动跳转到本地。 仓库源码依赖管理器基本的功能已经完成了，如果需要调试模块的本地代码，只需要在源码依赖描述里把相应模块开关打开即可，是不是很方便？ 仓库源码依赖管理器大概就是这些内容。","categories":[],"tags":[{"name":"依赖管理器","slug":"依赖管理器","permalink":"http://yoursite.com/tags/依赖管理器/"}]},{"title":"仓库源码依赖管理器（二）","slug":"仓库源码依赖管理器（二）","date":"2018-05-04T02:47:50.000Z","updated":"2019-02-01T09:31:48.682Z","comments":true,"path":"2018/05/04/仓库源码依赖管理器（二）/","link":"","permalink":"http://yoursite.com/2018/05/04/仓库源码依赖管理器（二）/","excerpt":"如何动态生成依赖描述？","text":"如何动态生成依赖描述？ 上一篇我们定义了依赖描述的基本格式，如下： 12345module &#123; on_off true name &quot;我是名字&quot; path &quot;/path&quot;&#125; 如果我们想做的更通用，能让其他业务工程方便的接入仓库源码依赖，那每一次接入的时候都要编写大量的依赖描述，而且每一次依赖变了，都需要手动修改描述文件。那可不可以动态生成依赖描述？ 我们都知道有一个androidDependencies任务，执行任务会把工程的依赖在控制台输出，如果我们实现类似的任务，可以扫描出当前的依赖关系，然后根据我们的依赖描述定义输出为DSL文件就可以解决了。 我们在任务执行期间可以拿到project config 信息，然后根据第一级的依赖信息生成节点依赖信息，然后递归查找当前节点的子节点，最后就可以生成类似树状的依赖关系，基本思路如下： 12345678910111213141516project.configurations.each &#123; config -&gt; // 这里可以添加些异常检查 config.resolvedConfiguration.firstLevelModuleDependencies.each &#123; dep -&gt; def generateModuleDep generateModuleDep = &#123; resolvedDep -&gt; // 这里可以根据 resolvedDep moduleGroup moduleName 等信息生成当前依赖信息 resolvedDep.children.each &#123; childResolvedDep -&gt; if (resolvedDep in childResolvedDep.getParents()) &#123; // 子节点递归扫描依赖 generateModuleDep(childResolvedDep) &#125; &#125; &#125; generateModuleDep(dep) &#125;&#125; 节点的信息可以按照实际情况存储到相应的数据结构中，我这里是把节点的对象直接存到List中。 现在我们已经获取到各个节点的信息了，那我们怎么把节点信息导出为文件呢？ groovy 支持使用模板生成字符串，生成文件当然也是可以的。 先定义一个依赖描述模板，如下： 12345module &#123; on_off $&#123;on_off&#125; name $&#123;name&#125; path $&#123;path&#125;&#125; 下一步定义一个节点信息Map，如下： 12345def binding = [ on_off : true, // 节点信息的开关值 name : &quot;节点信息的名字&quot;, path : &quot;节点的路径&quot;,] 最后根据上面定义的模板和节点信息Map，输出格式化的字符串。 12def template = new StreamingTemplateEngine().createTemplate(&quot;描述依赖模板&quot;)String response = template.make(&quot;节点信息Map&quot;) 模板引擎的make函数返回就是已经填好内容的格式化字符串，根据输出的字符串就可以输出到依赖描述文件。 现在在业务工程执行当前的任务，就可以动态生成依赖描述文件。 下一篇我们将结合这两篇的内容说下如何动态替换依赖。 仓库源码依赖管理器（三）","categories":[],"tags":[{"name":"依赖管理器","slug":"依赖管理器","permalink":"http://yoursite.com/tags/依赖管理器/"}]},{"title":"仓库源码依赖管理器（一）","slug":"源码依赖管理器（一）","date":"2018-05-03T04:18:36.000Z","updated":"2019-02-01T09:31:48.738Z","comments":true,"path":"2018/05/03/源码依赖管理器（一）/","link":"","permalink":"http://yoursite.com/2018/05/03/源码依赖管理器（一）/","excerpt":"这一篇我们先看下如何定义依赖描述。","text":"这一篇我们先看下如何定义依赖描述。 如果我们平常经常维护主工程的基础仓库，经常会遇到修改仓库后无法很好的验证修改的效果，要么是把仓库工程作为单独的git submodule嵌入到业务工程，或者是简单粗暴，直接把线上依赖注释掉，添加本地仓库的路径。 那么有没有一种好的方法，可以做到本地源码依赖和线上依赖无缝切换。 了解过iOS开发的都知道，iOS依赖是直接下载依赖仓库的源码，本地依赖直接编译，依赖管理器叫CocoaPods，Android 平台是通过Gradle 从 Maven 或者JCenter 下载二进制文件。那在Android 平台上如何实现依赖仓库源码文件？ 依赖管理器大概由几部分组成，依赖描述文件、发布规范等。依赖描述文件各个依赖管理器采用的格式都有所不同，Json 、 XML 、DSL 等等。各种表达方式各有各的优点，Json XML 结构工程表达比较丰富，但是可读性较差，当工程有几十个依赖项Json XML 简直无法直视，DSL虽然在工程结构表达上较弱，但在可读性理解上优点非常明显，cocoapods 就采用了这种表达方式，非常优美，如下。 12345678platform :ios, '8.0'use_frameworks!target 'MyApp' do pod 'AFNetworking', '~&gt; 2.6' pod 'ORStackView', '~&gt; 3.0' pod 'SwiftyJSON', '~&gt; 2.3'end 看着这种依赖关系描述，心情也会舒畅好多。 那么在Android 平台能不能实现类似的效果？Android 构建使用的是groovy语言，而且groovy对DSL支持的还不错，所以利用groovy DSL特性描述依赖关系就可以了，你以为它是一段描述，其实它是一个可执行脚本。 我们需要一个模块的描述，包括开关、名字、路径等等，类似如下： 12345module &#123; on_off true name \"我是名字\" path \"/path\"&#125; ok，有了定义怎么实现？ 我们看上面的依赖描述，其实都是一个个函数调用，比如 module 就可以是一个函数，函数的参数是一个闭包，同理on_off、name等等也是函数调用，在函数后面的即为函数的参数。 是不是很有意思？一句话就可以作为一个脚本执行。 所以，我们需要定义我们依赖描述中要用到的函数，如下： 12345678910111213141516171819202122232425262728class Module &#123; boolean on_off String name String path void on_off(boolean on_off) &#123; this.on_off = on_off println(\"module on_off:\" + on_off) &#125; void name(String name) &#123; this.name = name println(\"module name:\" + name) &#125; void path(String path) &#123; this.path = path println(\"module path:\" + path) &#125;&#125;Module module(@DelegatesTo(strategy = Closure.DELEGATE_FIRST, value = Module) Closure script) &#123; script.resolveStrategy = Closure.DELEGATE_FIRST Module module = new Module() script.delegate = module script() return script.delegate&#125; 名为module的函数接收一个闭包，闭包代理为Module类，闭包内的函数自动执行代理类函数调用，类和函数定义完成后，然后在控制台试验下（Android Studio -&gt; Tools -&gt; Groovy Console），在定义的类和函数下面写上如下的DSL生命，执行。 12345module &#123; on_off true name &quot;我是名字&quot; path &quot;我是路径&quot;&#125; 结果如下：module on_off:truemodule name:我是名字module path:我是路径 看来我们定义的DSL已经成功被解析。 依赖描述已经定义完成，下一篇会说下如何动态生成依赖描述文件。 仓库源码依赖管理器（二）","categories":[],"tags":[{"name":"依赖管理器","slug":"依赖管理器","permalink":"http://yoursite.com/tags/依赖管理器/"}]},{"title":"善变的架构","slug":"善变的架构","date":"2018-03-08T12:14:49.000Z","updated":"2019-05-10T11:57:39.743Z","comments":true,"path":"2018/03/08/善变的架构/","link":"","permalink":"http://yoursite.com/2018/03/08/善变的架构/","excerpt":"架构会有多善变？","text":"架构会有多善变？ 上图是一个常见的App分层架构，之后随着业务发展，架构会如何变化呢？ 再看微信在两个阶段结构图： 阶段1： 阶段2： 可以看到微信在阶段1架构类似于常见的App分层架构，但是随着业务不断膨胀，发展到阶段2某些模块发生了劣化。为什么会出现这种问题？架构随着业务不断发展，最上层业务模块横向进行扩展，某一个业务并不会劣化，同理，最底层的组件，也不会出现较大的劣化。随着平行的业务模块交互越来越多，依赖的业务功能按照普通做法只能下沉到中间模块，这时劣化就渐渐的开始。 明确了问题，那该如何解决？Gradle Module 只能一个模块依赖另一个模块，而不能再细化模块的依赖，那我们只能自定义依赖关系。在Module 里面划分小模块，分离Java Res Manifest 等资源，在property文件中定义该依赖哪些东西，在编译期检查依赖的合理性。如下图： 这样就可以细化模块之间的依赖范围，模块之间也可以相互依赖。依赖并保持克制。 良好的架构除了要保持代码和规范的良好性，还应该做到哪些事情？ 单端单产品按业务复杂度大概分为三种规模，十人之下、三十人左右、百人团队。十人左右团队考虑的更多是怎么快速的迭代业务，架构考虑更多的是如何辅助业务发展。三十人团队考虑的更多的是怎么样保持业务的并行进展，架构考虑更多的是如何使各业务线耦合度更低、沟通更顺畅、业务性能可控，取决于架构的复用、解耦、稳定及监控能力，如果架构做不到上述几点，将会拖累业务的发展，甚至导致业务失控。百人团队考虑的更多是业务并行及可控性，架构考虑更多的会是产品整个生命周期的并行及支撑体系，例如，研发支撑：在线定位用户操作的链路，测试支撑：自动化测试脚本，运维支撑：稳定性分析、舆情监控，发布支撑：更精确的灰度验证、实时发布。 完整的产品生命周期包括，工程期、运行期、运维期，良好的架构应该有解决上述各个时期问题的能力。比如在工程编码期，编码规范及代码风格检查的工具。在工程编译期，检查模块之间依赖、生成辅助代码的能力。在运行期，监控App性能、压测模块的能力。在运维期，包大小预警、打包平台、在线提取用户异常业务日志、实时修复能力。 架构，善变。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/架构/"}]},{"title":"容器框架Atlas原理解析","slug":"容器框架Atlas原理解析","date":"2017-12-17T10:03:03.000Z","updated":"2019-02-01T09:31:48.661Z","comments":true,"path":"2017/12/17/容器框架Atlas原理解析/","link":"","permalink":"http://yoursite.com/2017/12/17/容器框架Atlas原理解析/","excerpt":"优秀的架构在于解决产品编码期、运行期、测试期及后期运维的各种问题。","text":"优秀的架构在于解决产品编码期、运行期、测试期及后期运维的各种问题。 一个产品，当只有一两个工程师，这时没什么问题。当达到10人左右，沟通成本、协作效率、软件质量问题开始显现。当达到30+人，多业务线并行，开发效率、线上事故、代码合板等问题已经开始成为了产品瓶颈。那我们该怎么解决？ Atlas是在手淘架构不断发展演化出来的一个解决方案，比较适用于多业务线产品。Atlas把各个业务线分为多个bundle，bundle之间共享资源放在Host中，这样在编码编译期做到了天然隔离。在工程期，各bundle和host独立编译开发。运行期，按需加载bundle。运维期，动态部署业务需求、灵活精确灰度测试。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/架构/"}]},{"title":"Android业务中间层该如何设计？","slug":"Android业务中间层该如何设计？","date":"2017-10-11T11:04:45.000Z","updated":"2019-05-10T12:04:30.809Z","comments":true,"path":"2017/10/11/Android业务中间层该如何设计？/","link":"","permalink":"http://yoursite.com/2017/10/11/Android业务中间层该如何设计？/","excerpt":"如果一个产品需要有多个业务线，各业务线之间如何协作才是最高效的？","text":"如果一个产品需要有多个业务线，各业务线之间如何协作才是最高效的？ 上图是比较常见的业务组装方式，如果需要添加某个业务，把相应的View直接写在Layout里，然后处理业务逻辑。但是如果业务模块多达几十个，散落的逻辑有几千行，这时该如何设计才能保证各业务的稳定和可扩展性？ 公共业务应该是各个业务积木堆积组成，各个积木之间是黑盒状态，只能通过“窗口”向外提供服务，以及发布需求。中间层委托、代理信息的传递。 中间层在Android平台该如何设计？ Android平台起点及终点都是和界面的生命周期息息相关，中间层作为业务/界面的承载模型，所以应该继承自View。 各个业务积木之间是独立、隔离、和动态的，业务积木通过中间承载模型加载/卸载也应该是动态的。 中间层作为界面承载模型，所以也是有生命周期的，且依赖于外部。 中间层除了承载、通信职责，也应该随着外部环境变化，去影响业务积木的改变。 对外协议 123456789101112131415161718192021222324252627282930313233/** * 委托协议 * * @author jacky * @version v1.0 * @description 对外暴露的协议 * @since 2017/9/14 */public interface IBusinessDelegate &#123; IBusinessDelegate setup(); IBusinessDelegate setupBusiness1(); IBusinessDelegate setupBusiness2(); IBusinessDelegate setupBusiness3(); IBusinessDelegate setupBusiness4(); void event1(); void event2(); void onCreate(); void onResume(); void onPause(); void onDestroy();&#125; 中间层实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * 委托 * * @author jacky * @version v1.0 * @description 委托，隔离各业务间的耦合 * @since 2017/9/14 */public class BusinessDelegate extends RelativeLayout implements IBusinessDelegate &#123; private WeakReference&lt;Context&gt; mContextReference; private TimingChestContract.Presenter mTimingChestPresenter; public BusinessDelegate(Context context) &#123; super(context); &#125; public BusinessDelegate(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public BusinessDelegate(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public IBusinessDelegate setup() &#123; mContextReference = new WeakReference&lt;&gt;(getContext()); removeAllViews(); return this; &#125; // ---- 动态加载挂件 Start ---- @Override public IBusinessDelegate setupBusiness1() &#123; TimingChestView chestView = new TimingChestView(mContextReference.get()); mTimingChestPresenter = new TimingChestPresenter(chestView, new TimingChestModel()); chestView.setPresenter(mTimingChestPresenter); LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT); params.addRule(RelativeLayout.ALIGN_PARENT_RIGHT); addView(chestView, params); return this; &#125; @Override public IBusinessDelegate setupBusiness2() &#123; return this; &#125; @Override public IBusinessDelegate setupBusiness3() &#123; return this; &#125; @Override public IBusinessDelegate setupBusiness4() &#123; return this; &#125; // ---- 动态加载挂件 End ---- // ---- 接收事件 Start ---- @Override public void event1() &#123; if (mTimingChestPresenter != null) &#123; mTimingChestPresenter.notify(); &#125; &#125; @Override public void event2() &#123; &#125; // ---- 接收事件 End ---- // ---- 生命周期 Start ---- @Override public void onCreate() &#123; if (!EventBus.getDefault().isRegistered(this)) &#123; EventBus.getDefault().register(this); &#125; if (mTimingChestPresenter != null) &#123; mTimingChestPresenter.onCreate(); &#125; &#125; @Override public void onResume() &#123; if (mTimingChestPresenter != null) &#123; mTimingChestPresenter.onResume(); &#125; &#125; @Override public void onPause() &#123; if (mTimingChestPresenter != null) &#123; mTimingChestPresenter.onPause(); &#125; &#125; @Override public void onDestroy() &#123; EventBus.getDefault().unregister(this); if (mTimingChestPresenter != null) &#123; mTimingChestPresenter.onDestroy(); &#125; &#125; // ---- 生命周期 End ----&#125; 委托作为中间层的呈现方式，动态加载业务积木，并感应外部环境变化反应到业务积木。通过这种方式，业务积木就有了很好的稳定性和扩展性。并辅以辅助手段，使委托变得异常强大。","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/架构/"}]},{"title":"关于Dalvik，我们该知道些什么？","slug":"关于Dalvik，我们该知道些什么？","date":"2017-08-21T12:51:54.000Z","updated":"2019-05-10T11:51:49.246Z","comments":true,"path":"2017/08/21/关于Dalvik，我们该知道些什么？/","link":"","permalink":"http://yoursite.com/2017/08/21/关于Dalvik，我们该知道些什么？/","excerpt":"Dalvik和JVM的区别Dex文件的结构Dalvik如何加载Class","text":"Dalvik和JVM的区别Dex文件的结构Dalvik如何加载Class Dalvik和JVM的区别Dalvik和JVM最主要区别是它们分别具有不同的类文件格式和指令集。Dalvik使用的是dex（Dalvik Executable）格式的类文件，而Java虚拟机使用的是class格式的类文件。 Dalvik的指令是基于寄存器的，而JVM的指令是基于堆栈的，因此Dalvik需要更多的指令空间。这样的区别其实各有优劣，JVM需要占用更多的CPU时间，而Dalvik的数据缓冲更容易失效。 Dex文件结构先看一张Class文件和Dex文件对比图： Dex这么设计可以使文件更紧凑，减少拢余，还可以共享资源，进而减少文件大小。 各个字段含义如下： 数据名称 解释 header Dex文件头部，记录整个Dex文件的相关属性 string_ids 字符串数据索引，记录了每个字符串在数据区的偏移量 type_ids 类似数据索引，记录了每个类型的字符串索引 proto_ids 原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表 field_ids 字段数据索引，记录了所属类、类型以及方法名 method_ids 类方法索引，记录方法所属类名、方法声明以及方法名等信息 class_defs 类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量 data 数据区，保存了各个类的真实数据 link_data 链接数据区 Dalvik如何加载Class解析Dex加载之前需要有一个解析过程，Dex文件大体可以分为三大部分：头部、索引、数据。通过头部可以找到索引的数目、位置和数据的起始位置。然后，Dalvik会调用dexFileParse函数对它进行分析，分析的结果放到DexFile数据结构中。 加载Dex存储的数据结构如下： 1234typedef struct Object &#123; ClassObject* clazz; // 类型对象 Lock lock; // 锁对象&#125; Object; clazz指向ClassObject对象，里面还包含一个Lock对象。如果其它线程想要获取它的锁，只有等当前线程释放掉才可以。 从Dex数据区读取过程中，会在内存中分配几个内存区域，用于存放directMethod、virtualMethod、sfield、ifield。等得到索引后，加载实际是由loadClassFromDex完成，它首先会先读取class的具体信息，再加载directMethod、virtualMethod、sfield、ifield，然后会为ClassObject数据结构分配内存，并读取Dex文件相关信息。等加载完成后，将加载的class放入哈希表中方便下次快速查找。","categories":[],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/虚拟机/"}]},{"title":"Too many classes in --main-dex-list, main dex capacity exceeded | 主Dex引用太多怎么办？","slug":"Too-many-classes-in-main-dex-list-main-dex-capacity-exceeded-主Dex引用太多怎么办？","date":"2017-06-14T10:27:59.000Z","updated":"2019-05-10T12:07:31.840Z","comments":true,"path":"2017/06/14/Too-many-classes-in-main-dex-list-main-dex-capacity-exceeded-主Dex引用太多怎么办？/","link":"","permalink":"http://yoursite.com/2017/06/14/Too-many-classes-in-main-dex-list-main-dex-capacity-exceeded-主Dex引用太多怎么办？/","excerpt":"主 dex 里面会有 Application、Activity、Service、Receiver、Provider、Instrumentation、BackupAgent 和 Annotation。当这些类以及直接引用类比较多的时候，都要塞进主 dex ，就会引发 main dex capacity exceeded build error 。","text":"主 dex 里面会有 Application、Activity、Service、Receiver、Provider、Instrumentation、BackupAgent 和 Annotation。当这些类以及直接引用类比较多的时候，都要塞进主 dex ，就会引发 main dex capacity exceeded build error 。 在Lollipop之前的设备上，主Dex仅仅被Framework加载。为了支持multi-dex，应用必须明确的让类加载器去加载二级Dex文件（这就是为什么要调用MultiDex#install） 那就是说应用的主Dex应该包含所有的即将被加载器访问的类，如果你的应用的代码试着在类加载器加载之前，去引用二级Dex里面的class就会抛出Class Not Found异常。 那什么样的类会被包含在主Dex里面？ 会有三个顺序执行的任务将会决定哪个类应该被包含在主Dex里。 collect{variant}MultiDexComponents task，这个任务会根据manifest把所有应用组件（application, activities, services, receivers, providers）的名字写到一个文本文件。因此，如果你没有把其中的组件注册到manifest，那就不会被包含到主Dex里，也会有一些不注册的class也会被包含进去，比如注解。查看下CreateManifestKeepList.groovy 的源码就可以看到完整的包含列表。这个任务输出的文件是 manifest_keep.txt，路径为：app/build/intermediates/multi-dex。 shrink{variant}MultiDexComponents task，这个任务会掉起ProGuard程序创建一个压缩过的Jar文件，这个文件里只包含manifest_keep.txt里的class，这个任务输出的文件是componentClasses.jar create{variant}MainDexClassList task，这个任务会解析componentClasses.jar文件，为每一个类文件计算直接的引用层级，具体实现请查看链接。因此，如果你应用有一个注册的组件包含类X的变量，类X也会被包含进主Dex里面。这个任务输出的文件为：maindexlist.txt，包含主Dex里面所有的类。 如果最低版本是21会发生什么？如果最低版本是21上面所有的任务都不会执行，也不会有主Dex列表的计算。这是因为在应用安装期间所有的dex文件都会被ART转换为一个.oat文件。 所以如果这些类的引用超过了65536，构建的时候就会抛出这个Too many classes in --main-dex-list, main dex capacity exceeded 错误 那到底解决方案是什么？升级Gradle plugin的版本到2.2.0-alpha4以上，例：classpath &#39;com.android.tools.build:gradle:2.2.0&#39;，可以查看关于这个问题的Google Issue Tracker 参考：Too many classes in –main-dex-list, main dex capacity exceeded","categories":[],"tags":[{"name":"疑难杂症","slug":"疑难杂症","permalink":"http://yoursite.com/tags/疑难杂症/"}]},{"title":"Hello Kotlin","slug":"Hello Kotlin","date":"2017-06-12T06:16:18.000Z","updated":"2019-05-10T12:04:56.180Z","comments":true,"path":"2017/06/12/Hello Kotlin/","link":"","permalink":"http://yoursite.com/2017/06/12/Hello Kotlin/","excerpt":"前世今生有什么样的语法？语法是怎么实现的？如何编译的？迁移成本为我们带来什么改变？","text":"前世今生有什么样的语法？语法是怎么实现的？如何编译的？迁移成本为我们带来什么改变？ 前世今生设计出发点 Concise — 简洁 Safe — 安全 Interoperable — 协作 目标Statically typed programming language for modern multiplatform applications静态类型编程语言用于现代多平台应用 有什么样的语法？语法对比 Kotlin vs Java kotlin Java 函数 fun sum(a: Int, b: Int): Int { return a + b } public int sum(int a, int b) {return a + b;} 变量 var a: Int = 1 int a = 1; 非空判断 text?.let { val length = text.length } if (text != null) { int length = text.length(); } 开关 var grade = when (score) {1, 2 -&gt; “Excellent” } String grade; switch (score) { case 1: case 2: grade = “Excellent”; break; } 基础数字 数字没有隐式拓宽转换，如 Java 中 int可以隐式转换为long 使数字常量更易，val oneMillion = 1_000_000 对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如:val x = (1 shl 2) and 0x000FF000，shl:有符号左移 and:位与 字符 字符用 Char 类型表示，它们不能直接当作数字，但可以显示转换 模板：val i = 10 val s = “i = $i” // 求值结果为 “i = 10” 控制流 If：是一个表达式，即它会返回一个值，没有三元运算符，使用if表达：val max = if (a &gt; b) a else b When：取代了类 C 语言的 switch 操作符，简单形式如下： 1234567when (x) &#123; 1 -&gt; print(\"x == 1\") 2 -&gt; print(\"x == 2\") else -&gt; &#123; // 注意这个块 print(\"x is neither 1 nor 2\") &#125;&#125; when 既可以被当做表达式使用也可以被当做语句使用。可以用任意表达式（而不只是常量）作为分支条件： 1234when (x) &#123; parseInt(s) -&gt; print(\"s encodes x\") else -&gt; print(\"s does not encode x\")&#125; 返回和跳转 跳转表达式都可以用作更大表达式的一部分：val s = person.name ?: return 标签：我们可以用标签限制 break 或者continue： 12345loop@ for (i in 1..100) &#123; for (j in 1..100) &#123; if (……) break@loop &#125;&#125; 类和对象类 类声明：Kotlin 中所有的类默认都是 final，由类名、类头（指定其类型参数、主 构造函数等）和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。通常如下： 12class Invoice &#123;&#125; 实例：val invoice = Invoice()，Kotlin 并没有 new 关键字。 覆盖：Kotlin力求清晰显式。与 Java 不同，Kotlin 需要显式 标注可覆盖的成员。如：override、open 静态方法：Kotlin 中类没有静态方法。建议简单地使用包级函数。 属性和字段 声明一个属性的完整语法是： 123var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;] [&lt;getter&gt;] [&lt;setter&gt;] 例： 12345var stringRepresentation: String get() = this.toString() set(value) &#123; setDataFromString(value) // 解析字符串并赋值给其他属性 &#125; 接口 Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有 属性但必须声明为抽象或提供访问器实现。 使用关键字 interface 来定义接口 123456interface MyInterface &#123; fun bar() fun foo() &#123; // 可选的方法体 &#125;&#125; 可见性修饰符 Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public， 默认可见性是 public。 可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件： 一个 IntelliJ IDEA 模块； 一个 Maven 或者 Gradle 项目； 一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。 扩展 Kotlin 同 C# 和 Gosu 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。 这通过叫做 扩展 的特殊声明完成。Kotlin 支持 扩展函数 和 扩展属性。 声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面代码为 MutableList 添加一个swap 函数： 12345fun MutableList&lt;Int&gt;.swap(index1: Int, index2: Int) &#123; val tmp = this[index1] // “this”对应该列表 this[index1] = this[index2] this[index2] = tmp&#125; 数据类 我们经常创建一些只保存数据的类。在这些类中，一些标准函数往往是从 数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为data：data class User(val name: String, val age: Int) 语法实现原理Null Safe Operator实现原理示例函数如下： 123fun testNullSafeOperator(string: String?) &#123; System.out.println(string?.toCharArray())&#125; 生成的字节码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final testNullSafeOperator(Ljava/lang/String;)V @Lorg/jetbrains/annotations/Nullable;() // invisible, parameter 0 L0 LINENUMBER 15 L0 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; ALOAD 1 DUP IFNULL L1 ASTORE 2 ASTORE 3 L2 ALOAD 2 DUP IFNONNULL L3 //非空判断 NEW kotlin/TypeCastException DUP LDC &quot;null cannot be cast to non-null type java.lang.String&quot; INVOKESPECIAL kotlin/TypeCastException.&lt;init&gt; (Ljava/lang/String;)V ATHROW L3 INVOKEVIRTUAL java/lang/String.toCharArray ()[C DUP LDC &quot;(this as java.lang.String).toCharArray()&quot; INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkExpressionValueIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V L4 ASTORE 4 ALOAD 3 ALOAD 4 L5 LINENUMBER 15 L5 GOTO L6 L1 POP ACONST_NULL L6 INVOKEVIRTUAL java/io/PrintStream.println ([C)V L7 LINENUMBER 16 L7 RETURN L8 LOCALVARIABLE this Ltech/jackywang/kotlindemo/Test; L0 L8 0 LOCALVARIABLE string Ljava/lang/String; L0 L8 1 MAXSTACK = 5 MAXLOCALS = 5 反编译为Java代码如下： 1234567891011121314151617181920public final void testNullSafeOperator(@Nullable String string) &#123; PrintStream var10000 = System.out; char[] var10001; if(string != null) &#123; PrintStream var3 = var10000; if(string == null) &#123; throw new TypeCastException(\"null cannot be cast to non-null type java.lang.String\"); &#125; char[] var5 = string.toCharArray(); Intrinsics.checkExpressionValueIsNotNull(var5, \"(this as java.lang.String).toCharArray()\"); char[] var4 = var5; var10000 = var3; var10001 = var4; &#125; else &#123; var10001 = null; &#125; var10000.println(var10001); &#125; 由此可见kotlin实现的非空 ？ 语法，内部就是利用非空判断实现。 与Java互操作Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以很顺利地调用 Kotlin 代码。 空安全和平台类型Java 中的任何引用都可能是 null，这使得 Kotlin 对来自 Java 的对象要求严格空安全是不现实的。 Java 声明的类型在 Kotlin 中会被特别对待并称为平台类型。对这种类型的空检查会放宽， 因此它们的安全保证与在 Java 中相同 12345val list = ArrayList&lt;String&gt;() // 非空（构造函数结果）list.add(\"Item\")val size = list.size() // 非空（原生 int）val item = list[0] // 推断为平台类型（普通 Java 对象）item.substring(1) // 允许，如果 item == null 可能会抛出异常 受检异常在 Kotlin 中，所有异常都是非受检的，这意味着编译器不会强迫你捕获其中的任何一个。 因此，当你调用一个声明受检异常的 Java 方法时，Kotlin 不会强迫你做任何事情： 12345fun render(list: List&lt;*&gt;, to: Appendable) &#123; for (item in list) &#123; to.append(item.toString()) // Java 会要求我们在这里捕获 IOException &#125;&#125; 如何编译？编译入口从kotlinc Hello.kt 开始分析 12345678910111213141516171819202122cygwin=false;case &quot;`uname`&quot; in CYGWIN*) cygwin=true ;;esac...declare -a kotlin_app//运行入口if [ -n &quot;$KOTLIN_RUNNER&quot; ];then java_args=(&quot;$&#123;java_args[@]&#125;&quot; &quot;-Dkotlin.home=$&#123;KOTLIN_HOME&#125;&quot;) kotlin_app=(&quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-runner.jar&quot; &quot;org.jetbrains.kotlin.runner.Main&quot;)else//编译入口 [ -n &quot;$KOTLIN_COMPILER&quot; ] || KOTLIN_COMPILER=org.jetbrains.kotlin.cli.jvm.K2JVMCompiler java_args=(&quot;$&#123;java_args[@]&#125;&quot; &quot;-noverify&quot;) kotlin_app=(&quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-preloader.jar&quot; &quot;org.jetbrains.kotlin.preloading.Preloader&quot; &quot;-cp&quot; &quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-compiler.jar&quot; $KOTLIN_COMPILER)fi&quot;$&#123;JAVACMD:=java&#125;&quot; $JAVA_OPTS &quot;$&#123;java_args[@]&#125;&quot; -cp &quot;$&#123;kotlin_app[@]&#125;&quot; &quot;$&#123;kotlin_args[@]&#125;&quot; 12345678910111213141516171819202122232425fun compileBunchOfSources(environment: KotlinCoreEnvironment): Boolean &#123; val moduleVisibilityManager = ModuleVisibilityManager.SERVICE.getInstance(environment.project) val friendPaths = environment.configuration.getList(JVMConfigurationKeys.FRIEND_PATHS) for (path in friendPaths) &#123; moduleVisibilityManager.addFriendPath(path) &#125; if (!checkKotlinPackageUsage(environment, environment.getSourceFiles())) return false //词法、语法分析、语义分析、目标代码生成等过程 val generationState = analyzeAndGenerate(environment) ?: return false // 找到运行主类 val mainClass = findMainClass(generationState, environment.getSourceFiles()) try &#123; //写入文件 writeOutput(environment.configuration, generationState.factory, mainClass) return true &#125; finally &#123; generationState.destroy() &#125; &#125; 目标代码的生成在代码类生成的过程中，又包括生成类名、类体、字段、函数方法等环节，相关的生成类有ClassBodyCodegen、ClassFunctionCodegen、MemberCodegen、ExpressionCodegen、PropertyCodegen等。 12345678910111213141516171819202122232425262728public class KotlinCodegenFacade &#123; public static void doGenerateFiles( @NotNull Collection&lt;KtFile&gt; files, @NotNull GenerationState state, @NotNull CompilationErrorHandler errorHandler ) &#123; ... for (KtFile file : files) &#123; ... Set&lt;FqName&gt; obsoleteMultifileClasses = new HashSet&lt;FqName&gt;(state.getObsoleteMultifileClasses()); for (FqName multifileClassFqName : Sets.union(filesInMultifileClasses.keySet(), obsoleteMultifileClasses)) &#123; doCheckCancelled(state); //目标代码类生成 generateMultifileClass(state, multifileClassFqName, filesInMultifileClasses.get(multifileClassFqName), errorHandler); &#125; Set&lt;FqName&gt; packagesWithObsoleteParts = new HashSet&lt;FqName&gt;(state.getPackagesWithObsoleteParts()); for (FqName packageFqName : Sets.union(packagesWithObsoleteParts, filesInPackages.keySet())) &#123; doCheckCancelled(state); //目标代码类包生成 generatePackage(state, packageFqName, filesInPackages.get(packageFqName), errorHandler); &#125; doCheckCancelled(state); //生成结束 state.getFactory().done(); &#125;&#125; Kotlin在目标代码生成环节做了更多的处理，在该环节实现了自动生成Getter、Setter的代码。 12345678910111213141516171819202122public class PropertyCodegen &#123; private void gen( @Nullable KtProperty declaration, // 属性声明 @NotNull PropertyDescriptor descriptor, //描述，包括权限修饰符、注解、类型等。 @Nullable KtPropertyAccessor getter, // 决定是否生成getter @Nullable KtPropertyAccessor setter //决定是否生成setter ) &#123; assert kind == OwnerKind.PACKAGE || kind == OwnerKind.IMPLEMENTATION || kind == OwnerKind.DEFAULT_IMPLS : \"Generating property with a wrong kind (\" + kind + \"): \" + descriptor; //生成注解信息 genBackingFieldAndAnnotations(declaration, descriptor, false); //根据注解和权限修饰符等信息判断是否自动生成Getter代码 if (isAccessorNeeded(declaration, descriptor, getter)) &#123; generateGetter(declaration, descriptor, getter); &#125; //根据注解和权限修饰符等信息判断是否自动生成Setter代码 if (isAccessorNeeded(declaration, descriptor, setter)) &#123; generateSetter(declaration, descriptor, setter); &#125; &#125;&#125; Kotlin到Java的迁移成本 文件自动转换，点击菜单栏 Code | Convert Java File to Kotlin File 语法兼容性 第三方库兼容性 Kotlin为Android开发者带来什么改变？ 效率 多平台 参考：Kotlin编译过程分析、研究学习Kotlin的一些方法","categories":[],"tags":[{"name":"kotlin","slug":"kotlin","permalink":"http://yoursite.com/tags/kotlin/"}]},{"title":"JVM 答疑解惑","slug":"JVM-答疑解惑","date":"2017-05-11T09:40:00.000Z","updated":"2019-05-10T12:06:12.533Z","comments":true,"path":"2017/05/11/JVM-答疑解惑/","link":"","permalink":"http://yoursite.com/2017/05/11/JVM-答疑解惑/","excerpt":"JVM是什么？平常接触的东西都存在哪里？类如何加载？怎么运行？清洁工怎么工作？","text":"JVM是什么？平常接触的东西都存在哪里？类如何加载？怎么运行？清洁工怎么工作？ JVM是什么？Java 虚拟机屏蔽了与具体操作系统平台相关的信息,使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码),就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时,实际上最终还是把字节码解释成具体平台上的机器指令执行。 Java 虚拟机就像一个熟悉多个国家语言的导游，你只要向他说出自己的语言，他就能带着你在多个国家无障碍的玩耍。比如说，你说“我要吃肉夹馍”，无论到了哪个国家，你只需要和导游说这句话就可以，寻找和本地人交流导游就会帮你办好，最后结果是相同的：吃的都是肉夹馍。 可以参考如下Java技术体系图： 平常接触的东西都存在哪里？先看一下Java虚拟机运行时数据区： 程序计数器程序计数器：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每个线程都有自己的独立的程序计数器。 如果线程正在执行的是Java方法，那么这个计数器的值就是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值为空（undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 Java虚拟机栈线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余的数据类型占1个。局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。如果线程请求栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；无法申请到内存抛出OutOfMemoryError异常。 本地方法栈本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地栈则为虚拟机使用到的Native方法服务。 Java堆Java堆是线程共享的，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 方法区（永久代）线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载！ 运行时常量池他是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 直接内存直接内存不是虚拟机运行时数据区的一部分。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK1.4中新加入了NIO类，引入了一种基于通道与缓存区（buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。 类如何加载？在加载阶段，虚拟机需要完成以下 3 件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java. lang. Class 对象，作为方法区这个类的各种数据的访问入口。 Class文件的获取方式： 从 ZIP 包中读取，这很常见，最终成为日后 JAR、 EAR、 WAR 格式的基础。 从网络中获取，这种场景最典型的应用就是 Applet。 运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为*$Proxy 的代理类的二进制字节流。由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。 从数据库中读取。 一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的。开发人员可以通过自定义的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass方法），这里以后可以找一些比较重要的类，分析里面所有的函数，从而知道这些东西怎么用。 对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ Element Type， 指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为 C） 创建过程就遵循以下规则： 如果数组的组件类型（ Component Type， 指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，在 7. 4 节会介绍到，一个类必须与类加载器一起确定唯一性）。 如果数组的组件类型不是引用类型（例如 int[] 数组）， Java 虚拟机将会把数组 C 标记为与引导类加载器关联。 数组类的可见性与它的组件可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认设置为public 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区怎么存储由JVM自己定义。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面）。 加载阶段和连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。 怎么运行？解析解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在 Class 类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。 对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info 四种常量类型。 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 初始化初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 清洁工怎么工作？GC要完成3件事： 哪些内存需要回收？引用计数算法、根搜索算法 什么时候回收？标记—清除算法、标记—整理算法 如何回收？分代收集、垃圾收集器（不同厂商有不同实现）","categories":[],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/虚拟机/"}]},{"title":"数据库到底哪家强？","slug":"数据库到底哪家强？","date":"2017-04-15T06:24:26.000Z","updated":"2019-05-10T11:59:41.132Z","comments":true,"path":"2017/04/15/数据库到底哪家强？/","link":"","permalink":"http://yoursite.com/2017/04/15/数据库到底哪家强？/","excerpt":"目前大部分开源数据库都是基于SQLite发展而来，如SQLBrite、OrmLite、DBFlow、GreenDao等等，还有一个是Realm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎。那这么多框架到底有什么区别，那种更适合自己的产品呢？","text":"目前大部分开源数据库都是基于SQLite发展而来，如SQLBrite、OrmLite、DBFlow、GreenDao等等，还有一个是Realm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎。那这么多框架到底有什么区别，那种更适合自己的产品呢？ 我们先看基于SQLite发展而来的框架，这方面主要分成两条发展路线，一条是Rx或者叫做对象映射（OM）路线，一条是对象关系映射（ORM）路线。 Rx/对象映射路线代表数据库有sqlbrite、sqldelight，这两个都是Square出品。 SqlBrite和SqlDelight都是对象映射（OM，Object Mappers）而不是对象关系映射（ORM，Object/Relational Mappers）。 ORM 其实并不是一个优秀的框架。很多平台的 ORM 实现都有性能和内存的问题。我们也不会编写ORM。 – JakeWharton 上面这句话很好的说明了这两个框架的出发点，知道这些我们就容易理解了。 SqlBrite SqlBrite是对 Android 系统的 SQLiteOpenHelper 的封装，对SQL操作引入了响应式语义 （Rx）（用来在 RxJava 中使用） 基本用法 创建一个SqlBrite对象，该对象是该库的入口：SqlBrite sqlBrite = SqlBrite.create(); 提供一个 SQLiteOpenHelper实例和一个Scheduler实例来创建一个 BriteDatabase 对象：BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper, Schedulers.io());，Scheduler 是指定执行查询的操作的线程，由于查询数据库是不建议在 UI 线程中执行的，所以一般指定 Schedulers.io() 。 BriteDatabase.createQuery方法和SQLiteDatabase.rawQuery方法相比，多了一个table(s)表参数，用于监听数据变更。当我们订阅subscribe返回的Observable的时候，立刻执行需要的查询语句。 1234567Observable users = db.createQuery(\"users\", \"SELECT * FROM users\");users.subscribe(new Action1() &#123; @Override public void call(Query query) &#123; Cursor cursor = query.run(); // TODO parse data... &#125;&#125;); 优点在保证性能和复杂扩展性的同时，利用Rxjava操作Sql在易用性上有部分提高。 缺点还需要编写Sql语句，复杂性还是较高。 SqlDelight SqlDelight通过从 SQL 语句来生成 JAVA 模型代码。这样的好处是，所有 SQL 语句都位于同一个位置，通过查看 SQL 语句可以清楚的了解需要实现的功能和数据库的结构,也便于管理以及java类访问。 基本用法需要把 SQL 语句放到对应的 .sq 文件中，默认目录为和 main 目录下的 java 代码同级，例如src/main/sqldelight/com/example/HockeyPlayer.sq ，其中 com/example/ 为对应 java 对象的包名字。 在该 .sq 文件中一般第一个语句是创建表的语句： 123456789101112CREATE TABLE hockey_player ( _id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, number INTEGER NOT NULL, name TEXT NOT NULL);-- 其他的语句通过标识符来引用。在生成的 Java 对象中会包含-- 一个该标识符的常亮引用这个语句。select_by_name:SELECT *FROM hockey_playerWHERE name = ?; 上面的 SQL 语句会生成一个 HockeyPlayerModel Java 接口。该接口内有两个嵌套类分别把 Cursor 映射为 Java 对象以及把 Java 对象转换为 ContentValues 好插入数据库 优点 所有的SQL statement都存在.sq文件中，便于管理 可以自由的使用普通SQLite的同时帮助你处理了程式化的代码 缺点需要编写原生sql 总结SqlBrite方便在 RxJava 中使用 Sql 操作，并且额外添加了对数据库表数据更新通知的机制，当你对数据表进行操作的时候，其他订阅者可以在数据发生变化的时候收到通知。然后可以用 RxJava 的方式来操作数据。只是一个 SQLiteOpenHelper 的轻量级封装，并不关心你的对象是如何实现的，也不关心你的数据库。SqlBrite也不支持对象映射和类型安全的查询，SqlBrite 不是一个 ORM 框架，也不是一个类型安全的查询框架。不会提供类似Gson中对象序列化的功能，也不会提供数据库迁移的功能。 SqlDelight 的做法是从 SQL 语句来生成 JAVA 模型代码。 这样的好处是，所有 SQL 语句都位于同一个位置。SqlDelight 添加了对 SQL 语句的编译时验证、表名字和列名字的代码自动完成功能。让编写 SQL 语句更加快捷。在编译的时候，根据 SQL 语句生成 Java 模型接口和 builder 来把数据行和 Java 对象实现转换。SqlDelight 不会做很重的功能（比如数据懒加载、缓存 、级联删除 等 ORM 框架内常见的功能）。 对象关系映射（ORM）路线这部分框架在易用性上和性能上都做了很多工作，易用性上基本达到极致，在性能上接近原生Sql，这里举几个有代表性的项目。 OrmLite OrmLite - Lightweight Object Relational Mapping (ORM) Java Package 基本原理 使用注解方式标示字段，如数据库、表等 运行时使用反射获取相应字段拼接sql去执行 优点在易用性上相比原生sql有较大提高 缺点性能上有损失 greenDAO greenDAO is an open source Android ORM making development for SQLite databases fun again. 基本原理、特点 使用注解方式标示字段 在编译期生成本地sql greenDAO 支持 protocol buffer(protobuf) 协议数据的直接存储，如果你通过 protobuf 协议与服务器交互，将不需要任何的映射。 数据加密 解析 DaoMaster保存了sqlitedatebase对象以及操作DAO classes。其提供了一些创建和删除table的静态方法，其内部类OpenHelper和DevOpenHelper实现了SQLiteOpenHelper并创建数据库的框架。 DaoMaster除了具有创建表和删除表的两个功能外，还有两个内部类，分别为OpenHelper和DevOpenHelper，而DevOpenHelper继承自OpenHelper，而OpenHelper继承自SQLiteOpenHelper，而重写的onCreate()方法中调用了createAllTables(db,false)；方法来创建数据表，而createAllTables()方法中是通过调用UserDao静态方法来创建表的UserDao.createTable(db, ifNotExists)； 123456789101112131415/** Creates the underlying database table. */ public static void createTable(SQLiteDatabase db, boolean ifNotExists) &#123; String constraint = ifNotExists? \"IF NOT EXISTS \": \"\"; db.execSQL(\"CREATE TABLE \" + constraint + \"\\\\\"NOTE\\\\\" (\" + // \"\\\\\"_id\\\\\" INTEGER PRIMARY KEY AUTOINCREMENT ,\" + // 0: id \"\\\\\"TEXT\\\\\" TEXT NOT NULL ,\" + // 1: text \"\\\\\"COMMENT\\\\\" TEXT,\" + // 2: comment \"\\\\\"DATE\\\\\" INTEGER);\"); // 3: date&#125;/** Drops the underlying database table. */public static void dropTable(SQLiteDatabase db, boolean ifExists) &#123; String sql = \"DROP TABLE \" + (ifExists ? \"IF EXISTS \" : \"\") + \"\\\\\"NOTE\\\\\"\"; db.execSQL(sql);&#125; greenDAO的增删改查方法有一些是在Android原生的操作方法上进行了封装，对于链式查询的最终执行也是调用了Android原生的查询操作。 12345public List&lt;T&gt; list() &#123; checkThread(); Cursor cursor = dao.getDatabase().rawQuery(sql, parameters); return daoAccess.loadAllAndCloseCursor(cursor);&#125; 同时还有一些方法是基于SQLiteStatement实现的，SQLiteStatement相比原生的execSQL方法还要快一些，并且最终执行时也开启了事务，性能又提升了很多。下面是插入数据的最终实现方法： 1234567891011121314151617181920212223private long executeInsert(T entity, SQLiteStatement stmt) &#123; long rowId; if (db.isDbLockedByCurrentThread()) &#123; synchronized (stmt) &#123; bindValues(stmt, entity); rowId = stmt.executeInsert(); &#125; &#125; else &#123; // Do TX to acquire a connection before locking the stmt to avoid deadlocks db.beginTransaction(); try &#123; synchronized (stmt) &#123; bindValues(stmt, entity); rowId = stmt.executeInsert(); &#125; db.setTransactionSuccessful(); &#125; finally &#123; db.endTransaction(); &#125; &#125; updateKeyAfterInsertAndAttach(entity, rowId, true); return rowId;&#125; 可以看到先执行bindValues方法，该方法是一个抽象方法，需要业务方在DAO文件中实现，跟踪至NoteDao文件查看该方法代码如下： 1234567891011121314151617181920@Overrideprotected void bindValues(SQLiteStatement stmt, Note entity) &#123; stmt.clearBindings(); Long id = entity.getId(); if (id != null) &#123; stmt.bindLong(1, id); // 1为索引值，id为入库的值 &#125; stmt.bindString(2, entity.getText()); String comment = entity.getComment(); if (comment != null) &#123; stmt.bindString(3, comment); &#125; java.util.Date date = entity.getDate(); if (date != null) &#123; stmt.bindLong(4, date.getTime()); &#125;&#125; 这样就将SQLiteStatement需要的数据都进行了封装，然后执行stmt.executeInsert()方法即可完成数据库的插入操作。整个数据插入流程，greenDAO借助SQLiteStatement完成了数据的插入，避免了其他框架利用反射拼装sql语句而造成的执行效率低下的问题。 其他优化： 避免使用注解和反射拼装sql语句 最终执行时开启了事务 支持异步查询和回调 查询缓存机制，使用了弱引用WeakReference，第一次查询时将数据加入SparseArray&gt;的集合中 优点在易用性和性能上做到了很好的平衡 缺点上手成本 总结ORM类型框架在易用性上面做的比原生Sql提升了很多，而且在性能上GreenDao在某些方面甚至比原生的还要出色，比较适合大部分项目的开发工作。 RealmRealm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎，在某些方面有自己独特的优势。 GreenDao vs Realm 基本用法增： 1234567Realm realm=Realm.getDefaultInstance();realm.beginTransaction();User user = realm.createObject(User.class); // Create a new objectuser.setName(\"John\");user.setEmail(\"john@corporation.com\");realm.commitTransaction(); 删： 1234567891011121314151617181920Realm mRealm=Realm.getDefaultInstance(); final RealmResults&lt;Dog&gt; dogs= mRealm.where(Dog.class).findAll(); mRealm.executeTransaction(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; Dog dog=dogs.get(5); dog.deleteFromRealm(); //删除第一个数据 dogs.deleteFirstFromRealm(); //删除最后一个数据 dogs.deleteLastFromRealm(); //删除位置为1的数据 dogs.deleteFromRealm(1); //删除所有数据 dogs.deleteAllFromRealm(); &#125; &#125;); 优点 易用 快速 跨平台 可视化 缺点 显著增加安装包大小，增加大概4、5兆 数据类型限制，必须继承RealmObject、不支持内部类、修改了部分类型、不支持键值自增长。 线程限制，如果在UI线程获取到了当前Realm对象，在异步线程中使用当前Realm对象进行操作，就会抛出异常。 总结如果数据量没有达到SQLite的性能瓶颈的话，建议选择基于SQLite的数据库，如果不喜欢编写原生Sql语句就牺牲一点性能去适应业务快速迭代。这些框架同时存在都有其道理，性能有优势兼容性和稳定性不能保证，易用性很好必然就不能做太多的定制化操作，各取所需，对于一般的业务GreenDao便是一个比较好的方案。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"Android模块化与组件化--多模块区分编译","slug":"Android模块化与组件化-多模块区分编译","date":"2017-02-03T10:28:18.000Z","updated":"2019-05-10T12:03:29.893Z","comments":true,"path":"2017/02/03/Android模块化与组件化-多模块区分编译/","link":"","permalink":"http://yoursite.com/2017/02/03/Android模块化与组件化-多模块区分编译/","excerpt":"有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？","text":"有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？ 模块化与组件化–多模块区分编译 示例地址：https://github.com/JackyAndroid/Android-Architecture-Fairy/tree/master/multi-variants-libraryAndroid-Architecture-Fairy开源项目重点分析主流技术与架构设计，欢迎star 有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？先看下官方文档如下： By default a library only publishes its release variant. This variant will be used by all projects referencing the library, no matter which variant they build themselves. This is a temporary limitation due to Gradle limitations that we are working towards removing. You can control which variant gets published: 123android &#123; defaultPublishConfig \"debug\"&#125; Note that this publishing configuration name references the full variant name. Release and debug are only applicable when there are no flavors. If you wanted to change the default published variant while using flavors, you would write: 123android &#123; defaultPublishConfig \"flavor1Debug\"&#125; It is also possible to publish all variants of a library. We are planning to allow this while using a normal project-to-project dependency (like shown above), but this is not possible right now due to limitations in Gradle (we are working toward fixing those as well).Publishing of all variants are not enabled by default. The snippet below enables this feature: 123android &#123; publishNonDefault true&#125; It is important to realize that publishing multiple variants means publishing multiple aar files, instead of a single aar containing multiple variants. Each aar packaging contains a single variant. Publishing a variant means making this aar available as an output artifact of the Gradle project. This can then be used either when publishing to a maven repository, or when another project creates a dependency on the library project. Gradle has a concept of default” artifact. This is the one that is used when writing: 123dependencies &#123; compile project(':libraries:lib2')&#125; To create a dependency on another published artifact, you need to specify which one to use: 1234dependencies &#123; flavor1Compile project(path: ':lib1', configuration: 'flavor1Release') flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')&#125; Important: Note that the published configuration is a full variant, including the build type, and needs to be referenced as such.Important: When enabling publishing of non default, the Maven publishing plugin will publish these additional variants as extra packages (with classifier). This means that this is not really compatible with publishing to a maven repository. You should either publish a single variant to a repository OR enable all config publishing for inter-project dependencies. 默认Library只发布Release版本，这个是Gradle官方的限制，Google官方正在试图解决这个问题。可以使用defaultPublishConfig去设置发布的版本，通过设置publishNonDefault true可以让Library发布多个产品版本。下面的这种平常书写的方式是依赖的默认发布版本： 123dependencies &#123; compile project(':libraries:lib2')&#125; 如果想要分渠道编译多种形态的Library，需要修改如下的方式： 1234dependencies &#123; flavor1Compile project(path: ':lib1', configuration: 'flavor1Release') flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')&#125; 注意事项： 编译的配置是产品名称的全称加编译类型，如：flavor1Release 如果Library是Maven的公开库最好不要使用这种特性 产品名称首字母要小写，否则会有语法问题 如果Gradle里面有使用MultiDex选项会生成多个aar","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/架构/"}]},{"title":"谷歌安卓浏览器项目","slug":"谷歌安卓浏览器开源项目","date":"2017-02-03T09:49:37.000Z","updated":"2019-05-10T11:49:39.254Z","comments":true,"path":"2017/02/03/谷歌安卓浏览器开源项目/","link":"","permalink":"http://yoursite.com/2017/02/03/谷歌安卓浏览器开源项目/","excerpt":"谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star","text":"谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star 欢迎在GitHub或者CSDN上关注我GitHub: https://github.com/JackyAndroid CSDN: http://blog.csdn.net/rain_butterfly AndroidChromiumAndroidChromium源码地址如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash） 简介 谷歌浏览器安卓版源码项目 本项目是世界级的安卓架构 理清本项目业务逻辑完全可以胜任国内一线公司工程师 本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star 效果图 以下是升级chrome内核注意事项，如不是相关人员可以忽略 准备参考官方及其他教程编译通过chromium源码，并能生成chrome.apk 目的使用AndroidStudio开发环境调试Chromium Android UI层。 构建思路 采用Android Studio作为开发环境，从Chromium for Android抽取chrome模块的源码，加入Android project。 native代码在chromium环境中build，作为so加入Android project 基础模块(base, content, net等)在chromium环境build为jar包，加入Android project content, chrome, ui等模块的资源文件加入Android library project 资源文件为什么不能直接都添加到Android project呢？因为命名空间的原因，比如content模块的资源的命名空间为org.chromium.content, chrome模块的资源的命名空间为 org.chromium.chrome，所以需要建立不同的Android library project, 指定不同的包名。 本项目和源码目录对应关系app/libs ———– chromium/src/out/Release/lib.java app/src/main/aidl ———– chromium/src/chrome/android/java/src/android/support/customtabs/*.aidl app/src/main/assets ———– chromium/src/out/Release/assets/chrome_public_apk app/src/main/java ———— chromium/src/chrome/android/java/src app/src/main/jniLibs ———– chromium/src/out/Release/chrome_public_apk/libs app/src/main/res（app module 初始化资源） libraries/androidmedia_res ———– chromium/src/third_party/android_media/java/res libraries/chrome_res ———– chromium/src/chrome/android/java/res &amp; chromium/src/chrome/android/java/res_chromium libraries/content_res ———– chromium/src/content/public/android/java/res libraries/datausagechart_res ——— chromium/src/third_party/android_data_chart/java/res libraries/ui_res ———- chromium/src/ui/android/java/res 建议&amp;注意事项 pak和dat等文件需要加入到assets目录，而且不能压缩 aidl文件加入到main/aidl下，android studio会自动处理 目前构建的chromium版本是48.0.2554.0，内核为官方版本 因为某些java文件是通过C文件编译生成，只存在chromium/src/out 目录下。如果按以上对应关系升级版本缺失文件，请到out/目录下去搜索，根据命名空间添加相应文件。还有一些临时生成的xml资源文件也需要从out/目录下去拷贝到相应的资源模块。 如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash） 感谢本项目灵感来自于365browser LicenseCopyright 2016 Jacky Wang&lt;jacky.android@foxmail.com&gt; Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","categories":[],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://yoursite.com/tags/开源项目/"}]},{"title":"Android Framework是怎么启动的？","slug":"Android-Framework是怎么启动的？","date":"2017-02-03T09:47:48.000Z","updated":"2019-05-10T12:03:14.225Z","comments":true,"path":"2017/02/03/Android-Framework是怎么启动的？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-Framework是怎么启动的？/","excerpt":"安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。","text":"安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。 Android Framework运行环境是怎样的？安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。 Framework运行环境如下图： 安卓系统中运行的第一个Dalvik虚拟机叫做zygote，这个的意思是“卵”，那有什么卵用呢？听这个词的意思就知道是孵化的意思，接下来所有的Dalvik虚拟机进程都是这个“卵”孵化出来的。 zygote进程中包含两个主要模块，分别如下： Socket服务端。任务是用于接收启动新的Dalvik进程的命令。 Framework共享类及共享资源。当zygote进程启动后会加载一些共享的类及资源，就像营养液一样，供其他的细胞吸收。其中共享类是在preload-classes文件中被定义的，共享资源是在preload-resources中被定义的。其他Dalvik进程是被zygote卵进程孵化出来的，所以这些类和资源加载后，新的Dalvik进程就可以直接使用这些类和资源就达到了共享目的，就像一个细胞分裂成两个，共享一些基因和营养。 zygote进程对应的程序是app_process,该程序在system/bin目录下。 zygote孵化出的第一个Dalvik进程是SystemServer，该进程对应的程序依然是app_process,因为该进程是从app_process中孵化出来的。 SystemServer中创建了一个Socket客户端（生产线经理），之后所有的Dalvik进程都将通过该Socket客户端间接被启动，Ams负责管理这个客户端。如果需要启动新的APK进程时，Ams会通过该Socket客户端向zygote进程的Socket服务端（生产线工人）发送一个启动命令，然后zygote会孵化出新的进程（产品生产成型）。 这样的架构有两个特点： 每一个进程都是一个Dalvik虚拟机，Dalvik虚拟机是一种类似于java虚拟机的程序。 zygote进程会预先装载共享类和共享资源，提供营养液和基因，这些类和资源其实就是SDK中定义的大部分类和资源。当通过zygote孵化出新进程后，新的APK只需要去加载APK自身包含的类和资源，这样多个APK就可以共享Framework资源了。 和Dalvik虚拟机关系比较好的可执行程序有哪些？1.dalvikvmjava程序运行时都是由一个虚拟机来解释java字节码，将这些字节码翻译成本地CPU指令码然后执行。dalvikvm的作用就是创建一个虚拟机并执行参数中指定的java类。 2.dvzdvz的作用是从zygote进程中孵化出一个新的进程，新进程其实就是一个Dalvik虚拟机。该进程与dalvikvm启动的虚拟机相比，区别是该进程中已经预装了Framework的大部分类和资源。 3.app_processFramework在启动时需要加载运行两个特定java类，一个是ZygoteInit.java，一个是SystemServer.java。为了方便使用，系统才提供了一个app_process进程，该进程会自动运行这两个类，app_process其实就是使用dalvikvm启动ZygoteInit.java，启动后会加载Framework中得大部分类和资源。 Zygote是如何启动的？1.在init.rc中配置Zygote启动参数2.启动Socket服务端口当Zygote服务从app_process开始启动后，会启动一个Dalvik虚拟机，虚拟机第一个执行的java类就是ZygoteInit.java，该类第一个重要的工作就是启动一个Socket服务端口，该Socket端口用于接收启动新进程的命令。 3.加载preload-classes在Zygote类的main（）函数中，创建完Socket服务端后还不能立即孵化出新的进程，因为这个“卵”还没有必须的“基因”，这个“基因”就是指预装的Framework大部分类及资源。 4.加载preload-resourcespreload-resources包含两类资源，一类是drawable资源，一类是color资源。加载这些资源是在preloadResource（）函数中完成的，该函数调用preloadDrawable（）和preloadColorStateLists（）加载这两类资源，原理就是把这些资源读出来放到一个全局变量中，只要该类对象不被销毁，这些全局变量就会一直保存。 5.使用fork启动新的进程fork是Linux系统的一个系统调用，作用就是复制当前进程产生一个新的进程，相当于生物的克隆。除了进程id不同，新进程将拥有和原始进程完全相同的进程信息。进程的信息包括该进程所打开的文件描述符列表、所分配的内存等。当新进程被创建后，两个进程将共享已经分配的内存空间，如果其中一个需要向内存中写入数据时，操作系统才复制一份目标地址空间，并将要写的数据写入到新的地址中。这种“仅当写的时候才复制”的机制可以最大限度的在多个进程中共享物理内存。 举个栗子：去乌镇见一下习大大和去乌镇吃一次丁磊的猪肉，这是两个进程，但是两个进程中的很多任务是相同的，先订机票，做地铁到机场，做几小时飞机过去。到了之后不同的就是见习大大和吃猪肉。如果可以先雇一个秘书进程让它订机票、做地铁、做飞机，到乌镇。然后秘书在复制出两个秘书，一个去见习大大，一个去吃猪肉，好处是节省了大量内存。 Zygote进程就是本例中的“秘书进程”，那些“订机票、做地铁、乘飞机”就是Zygote进程中加载的preload-classes类的功能。 这样新的进程就脱离的Zygote进程的孵化成为一个真正的应用进程。 SystemServer 进程是如何启动的？SystemServer进程是Zygote孵化出的第一个进程，然后再配置SystemServer进程的环境。 1.启动各种系统服务线程SystemServer进程在Android运行环境中扮演了“神经中枢”的作用，APK应用中能够直接交互的大部分系统服务都在该进程中运行，常见的有WindowManagerServer（Wms）、ActivityManagerService（Ams）、PackageManagerServer（Pms），这些系统服务都是以一个线程的方式存在于SystemServer进程中。 2.启动第一个Activity当以上服务线程都启动后，其中Ams服务是systemReady（）调用完成最后启动的，在Ams的systemReady（）函数的最后一段代码则发出了启动任务队列中最上面一个Activity消息。 在Ams的startHomeActivityLocked（）中，系统发出了一个category字段包含CATEGORY_HOME的intent，代码如下： 1234intent.setComponent(mTopComponent);if(mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL)&#123;intent.addCategory(Intent.CATEGORY_HOME);&#125; 只要应用声明自己能够响应该Intent，那么就可以被认为是Home程序。当系统中有多个程序能够响应该Intent时，系统会弹出一个对话框，让用户选择启动哪个程序，也允许用户记住该选择。 到此第一个Activity就启动了。 如有问题请留言，转载请注明出处。 备注：以上部分思想来自于《Android内核剖析》","categories":[],"tags":[{"name":"Android Framework","slug":"Android-Framework","permalink":"http://yoursite.com/tags/Android-Framework/"}]},{"title":"Android 一个窗口是怎么创建出来的？","slug":"Android-一个窗口是怎么创建出来的？","date":"2017-02-03T09:46:19.000Z","updated":"2019-05-10T12:01:58.918Z","comments":true,"path":"2017/02/03/Android-一个窗口是怎么创建出来的？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-一个窗口是怎么创建出来的？/","excerpt":"在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。","text":"在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。 前言在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。 WmS并不在意该窗口是哪个应用程序的，关心的是活跃窗口，WmS按一定得规则判断哪个窗口处于活动状态，然后把用户消息给W类，W类再把用户消息传递给内部View变量，然后再由View对象完成剩下的消息处理。 窗户有几种类型？Framework定义了三种窗口类型，三种窗口类型的定义在WindowManager类里面。 应用窗口。应用窗口一般指该窗口对应一个Activity，由于加载Activity是由Ams完成的，所以对于应用程序创建应用类窗口只能在Activity内部完成。 子窗口。子窗口是指该窗口必须要有一个父窗口，父窗口可以是一个应用类窗口也可以是任何其他的窗口。 系统窗口。系统窗口不需要对应任何Activity，也不需要有父窗口。应用程序是没有办法创建系统窗口的，只有系统进程可以创建系统窗口。 那么该怎么创建应用窗口呢？1.每个应用类窗口都对应一个Activity对象，所以创建应用类窗口需要创建Activity对象。当AmS要启动某个Activity时就会通知客户端进程，每个客户端进程都对应一个ActivityThread类，所以需要ActivityThread启动Activity。 启动某个Activity实际是构造一个Activity对象，使用ClassLoader从程序文件中装载指定的Activity对应的Class文件。 2.创建完成Activity对象后调用Activity的attach（）方法，attach（）的作用就是为刚刚创造好的Activity设置内部变量。 3.为该Activity创建Window对象。 4.给Window对象中的mWindowManager变量赋值。 5.然后就需要给该窗口添加真正的View或者ViewGroup。从performLaunchActivity（）调用callActivityOnCreate（）开始，然后经一系列调用到Activity的onCreate（）方法，在onCreate（）方法中调用setContentView（）方法实际是调用了其对应的Window对象的setContentView（）方法。 6.接着会调用到PhoneWindow的setContentView，首先调用installDecor（）为Window类添加窗口装饰，其实就是标题栏，程序中设置的layout.xml界面被包含在窗口装饰中，就是窗口内容。窗口装饰也是ViewGroup，窗口装饰和它内部的内容加起来就是我们所说的窗口，或者叫做Window界面。 7.把创建的窗口通知WmS，让WmS把窗口显示在屏幕上。当Activity准备好后会通知Ams，然后Ams经过一系列调用到Activity的makeVisible（），该方法将真正完成把窗口添加进Wms中。 8.在makeVisible方法中，首先获得该Activity内部的WindowManager对象，然后调用该对象的addView（）方法。 9.调用WindowManagerImpl的addView（）方法，流程如下： 检查添加的窗口是否已经添加过，不能重复添加。 如果添加的窗口是子窗口类型，找到父窗口并保存在临时变量panelParentView中，该变量作为后面调用ViewRoot的setView（）参数。 创建一个新的ViewRoot 调用ViewRoot的setView（）。 10.完成新建一个ViewRoot对象后，需要把新建的ViewRoot对象添加到mRoots对象中。 11.调用ViewRoot对象的setView方法。流程如下： 给ViewRoot的重要变量赋值。 调用requestLayout（），发出界面重绘请求。 调用sWindowSession.add（），通知Wms添加窗口。 创建子窗口或系统窗口过程和上面的类似。 备注：以上部分思想来自于《Android内核剖析》","categories":[],"tags":[{"name":"Android Framework","slug":"Android-Framework","permalink":"http://yoursite.com/tags/Android-Framework/"}]},{"title":"Android Context 到底是什么？","slug":"Android-Context-到底是什么？","date":"2017-02-03T09:44:37.000Z","updated":"2019-05-10T12:02:37.214Z","comments":true,"path":"2017/02/03/Android-Context-到底是什么？/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-Context-到底是什么？/","excerpt":"一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。","text":"一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。 什么是Android Context？一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。 那么从安卓程序的角度来看，Context是什么？其实一个Activity就是一个Context，一个Service也是一个Context。 一个应用程序可以认为是一个约会环境，用户在这个环境中会切换到不同的场景，比如先去有情调的饭店吃饭，再去电影院看个电影，然后再去xxx（此处省略一万字…）。 Activity类的确是基于Context，而Service类也是基于Context。Activity除了基于Context类外，还实现了一些其他重要的接口，从架构设计的角度看，interface仅仅是某些功能，而extends才是类的本质，即Activity的本质是一个Context，其所实现的其他接口只是为了扩充Context的功能而已，扩充后的类称之为一个Activity或Service。 一个应用程序中应该有多少个Context对象我们在应用程序开发中经常会调用Context的一些方法，这些方法看起来似乎会返回一些全局的对象，而不仅仅是某个Activity，可能会有点疑问，一个应用程序到底有多少个Context对象呢？比如，Context.getResources（）返回该应用程序所对应的Resource类对象，无论从哪个Activity中调用，都会返回同一个Resource对象。 一个Activity就是一个场景（Context），一个Service也是一个场景，所以，应用程序中有多少个Activity或者Service就会有多少个Context对象，也就是有多少个场景。 getResource（）等方法返回的是同一个全局对象。 Context 继承关系是怎么样的呢？ Context类本身是一个纯abstract类。为了使用方便又定义了Context包装类-ContextWrapper，穿上了一身装备显得也比较强大，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中有attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象。 ContextThemeWrapper内部包含了与主题相关的接口，这里的主题就是指在AndroidManifest.xml中通过android：theme为Application或者Activity指定的主题。 只有Activity才需要主题，Service默默的后台工作者不需要穿的那么鲜艳，所以Service直接继承于ContextWrapper。 ContextImpl类真正实现了Context中所有的函数，真正的八块腹肌，我们所调用的各种Context类的方法其实实现均来自于该类。 什么时候创建的Context?每一个应用程序在客户端都是从ActivityThread类开始的，创建Context对象也是在该类中完成，具体创建ContextImpl类的地方一共有6处： PackageInfo.makeApplication（） performLaunchActivity（） handleCreateBackupAgent（） handleCreateService（） handleBindApplication（） attach（） 其中attach（）方法仅在Framework进程启动时调用，应用程序运行时不会调用到该方法。 Application对应的Context程序第一次启动时，会辗转调用到makeApplication（）方法。具体代码如下： 1234ContextImpl appContext = new ContextImpl();appContext.init(this,null,mActivityThread);....appContext.setOuterContext(app); Activity对应的Context启动Activity时，Ams会通过IPC调用到ActivityThread的scheduleLaunchActivity（）方法，该方法包含两种参数。一种是ActivityInfo，这是一个实现了Parcelable接口的数据类，意味着该对象是Ams创建的，并通过IPC传递到ActivityThread；另一种是其他的一些参数。 scheduleLaunchActivity（）方法中会根据以上两种参数构造一个本地ActivityRecord数据类，ActivityThread内部会为每一个Activity创建一个ActivityRecord对象，并使用这些数据对象来管理Activity。 然后会调用handleLaunchActivity（），再调用performLaunchActivity（），该方法中创建ContextImpl的代码如下： 123ContextImpl appContext = new ContextImpl();appContext.init(r.packageInfo,r.token,this);appContext.setOuterContext(activity); 在performLaunchActivity（）开始执行时，会为r.packageInfo变量赋值。r.packageInfo对象的PackageInfo对象和Application对应的packageInfo对象是同一个。 Service对应的Context启动Service时，Ams会通过IPC调用到ActivityThread的scheduleCreateService（）方法，该方法也包含两种参数。第一种是ServiceInfo，这是实现了一个Parcelable接口的数据类，该对象由AmS创建，并通过IPC传递到ActivityThread内部；第二种是其他参数。 在scheduleCreateService（）方法中，会使用以上两种参数构造一个CreateServiceData的数据对象，ActivityThread会为其所包含的每一个Service创建该数据对象，并通过这些对象来管理Service。 然后在执行handleCreateService（）方法，创建ContextImpl对象代码如下： 1234ContextImpl appContext = new ContextImpl();appContext.init(packageInfo,null,this);...appContext.setOuterContext(service); Service对应的Context对象内部的mPackageInfo与Activity、Application中是完全相同的。 这几个Context之间的关系从以上可以看出，创建Context对象的过程基本上是相同的，不同的仅仅是针对Application、Activity、Service使用了不同的数据对象。 一个应用程序包含的Context个数应该为：Context个数 = Service个数+Activity个数+1，最后的1是Application类本身也会对应一个Context对象。 应用程序中包含多个ContextImpl对象，而内部变量mPackageInfo却指向同一个PackageInfo对象，这种设计结构一般意味着ContextImpl是一种轻量级类，而PackageInfo是一个重量级类。事实上确实是这样，ContextImpl中的大多数进行包操作的重量级函数实际上都是转向了mPackageInfo对象相应的方法，也就是事实上调用了同一个PackageInfo对象。 备注：以上部分思想来自于《Android内核剖析》","categories":[],"tags":[{"name":"Android Framework","slug":"Android-Framework","permalink":"http://yoursite.com/tags/Android-Framework/"}]},{"title":"我眼中的Android Framework","slug":"我眼中的Android-Framework","date":"2017-02-03T09:40:58.000Z","updated":"2019-05-10T11:59:59.034Z","comments":true,"path":"2017/02/03/我眼中的Android-Framework/","link":"","permalink":"http://yoursite.com/2017/02/03/我眼中的Android-Framework/","excerpt":"在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言","text":"在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言 我眼中的Android Framework在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—前言 任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。Android framework包含三个小伙伴：服务端、客户端、linux驱动。 服务端 服务端主要包含两个狠重要的类：WindowManagerService（WMS）和ActivityManagerService（AMS） 客户端客户端包含以下类： ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是UI线程或者称为主线程。 Activity：ActivityThread会根据用户的操作选择让哪个Activity对象上它的船。 PhoneWindow：富二代，继承于牛气的Window类，自己屋里住着一个DecorView对象，像它老爸喜欢制定规则提供了一些通用窗口操作API。 Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作API。它不喜欢被人管所以呢，注意：WindowManagerService管理的窗口不是Window类，其实是View和ViewGroup。 DecorView：很能干的家伙，家产来自FrameLayout，比较注重外在喜欢打扮，DecorView是对FrameLayout进行了一些修饰，从名字就可以看出来。 ViewRoot：小管家继承于Handler，主要作用是把WMS的IPC调用转换为本地的一个异步调用。 W类：ViewRoot小助手，继承于binder，是ViewRoot内部类。主要帮助ViewRoot实现把WMS的IPC调用转换为本地的一个异步调用。 WindowManager：客户端如果想创建一个窗口得先告诉WindowManager一声，然后它再和WindowManagerService交流一下看看能不能创建，客户端不能直接和WMS交互。 Linux驱动 Linux驱动和Framework相关的主要是两个部分：画家SurfaceFlingger和快递员Binder。 每一个窗口都对应一个画Surface，SF主要是把各个Surface显示到同一屏幕上。Binder是提供跨进程的消息传递。 从apk程序的运行过程去看看上面各个组件在啥时候干啥活的ActivityThread从main()函数中就开始动起来，然后调用prepareMainLooper()为UI线程创建一个消息快递通道即MessageQueue。 接着创建ActivityThread对象，创建过程会创建一个消息装卸工Handler对象和一个快递员Binder对象，其中Binder负责接收远程Ams的IPC调用，接收到调用后让Handler把消息装到消息快递队列，UI线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。 然后UI线程让队列调用Looper.loop()方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。 当ActivityThread接收到Ams发送start某个Activity的快递后就会创建指定的Activity对象。Activity会先按窗户再去按玻璃和贴窗花，所以先创建PhoneWindow-&gt;DecorView-&gt;创建相应的View或ViewGroup。创建完成后就可以让大家欣赏了，调用WindowManager把界面显示到屏幕上，然后创建ViewRoot，然后调用Wms提供的远程接口添加一个窗口并显示到屏幕上。 接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用Wms中的相应函数处理该消息。 很多线程是不是很晕？ 安卓程序中都有哪些线程？ 客户端小伙伴至少包含三个线程小弟，Activity启动后会创建一个ViewRoot.W对象，同时ActivityThread会创建一个ApplicationThread对象，这两个对象继承消息总管Binder，每个Binder对应一个线程，负责接收Linux Binder驱动发送的IPC调用。还有一个是UI线程呗。 UI线程是什么？ 一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。 自定义的线程和UI线程有什么区别？ UI线程是从ActivityThread运行的，在该类的main()方法中已经使用了Looper.prepareMainLooper()为该线程添加了Looper对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在Activity中去定义Handler对象，因为创建Handler对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的Thread则没有默认创建消息队列，所以不能直接在Thread中直接定义Handler，这个就是我们不懂程序运行原理导致的困惑。 备注：以上部分思想来自于《Android内核剖析》","categories":[],"tags":[{"name":"Android Framework","slug":"Android-Framework","permalink":"http://yoursite.com/tags/Android-Framework/"}]},{"title":"Android 设计模式-单例模式","slug":"Android-设计模式-单例模式","date":"2017-02-03T09:35:12.000Z","updated":"2019-05-10T12:01:40.580Z","comments":true,"path":"2017/02/03/Android-设计模式-单例模式/","link":"","permalink":"http://yoursite.com/2017/02/03/Android-设计模式-单例模式/","excerpt":"什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用","text":"什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用 Android 设计模式-单例模式什么情况下需要单例模式？ 一些类提供公共功能供别人调用，本身不会处理业务逻辑 类会被许多类和线程调用 设计单例模式1234567891011public class Singleton&#123;private static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123;if(mSingleton == null)&#123; mSingleton = new Singleton();\\\\A &#125; return mSingleton; &#125;&#125; 上面的做法在多线程的时候会出现问题，比如有两个线程同时调用getInstance(),这时会new两个对象出来。 单例模式改进112345678910111213public class Singleton&#123;private static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; synchronized(Singleton.class)&#123; if(mSingleton == null)&#123; mSingleton = new Singleton();\\\\A &#125; return mSingleton; &#125; &#125;&#125; 这种方式还是会有问题，就是高并发情况下多线程去抢夺锁，假如有几百个线程，其中有一个运气比较差，这个线程就会出现一直去getInstance，资源一直返回不回去，UI也不会得到更新。 单例模式改进21234567891011121314public class Singleton&#123;private volatile static Singleton mSingleton;private Singleton()&#123;&#125;public static Singleton getInstance()&#123; if(mSingleton == null)&#123;\\\\A synchronized(Singleton.class)&#123;\\\\C if(mSingleton == null) mSingleton = new Singleton();\\\\B &#125; &#125; return mSingleton; &#125;&#125; 注：volatile是防止cpu进行指令重排序，防止代码顺序被更改。这种方式比较好的地方在于第一次创建实例时候就会同步所有的线程，以后再获取实例就会直接返回。 但是看代码好像还是有人会有疑问，为什么需要两次判断为null？其实这个意义在于防止多个线程同时进入第一个if内，比如说线程A执行到A行，线程B执行到B行，线程B还没有返回。当线程A执行到C行，这时线程B初始化实例完毕，如果没有里面的再一次判断就会生成两个实例！所以两次的判断null还是有意义的。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"国内优秀的TV桌面开源项目","slug":"国内优秀的TV桌面开源项目","date":"2017-02-03T09:14:46.000Z","updated":"2019-05-10T11:53:39.846Z","comments":true,"path":"2017/02/03/国内优秀的TV桌面开源项目/","link":"","permalink":"http://yoursite.com/2017/02/03/国内优秀的TV桌面开源项目/","excerpt":"这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。","text":"这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。 欢迎在GitHub或者CSDN上关注我GitHub: https://github.com/JackyAndroid CSDN: http://blog.csdn.net/rain_butterfly AndroidTVLauncher这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。 注意CatLauncher(Leanback风格) 目前功能已基本稳定，后续会跟进官方Leanback库的进展，Compatible桌面理论上不再维护 特性 Leanback风格 图片展示 视频直播（节操播放器-基于ijkplayer） 媒体详情 第三方应用列表 桌面特殊功能 效果图 下一步的改进 跟进官方Leanback库新功能 LicenseApache License, Version 2.0","categories":[],"tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://yoursite.com/tags/开源项目/"}]}]}