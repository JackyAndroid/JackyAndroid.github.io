<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>墨镜猫</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-04T06:18:53.551Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jacky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>仓库源码依赖管理器（三）</title>
    <link href="http://yoursite.com/2018/05/04/%E4%BB%93%E5%BA%93%E6%BA%90%E7%A0%81%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/04/仓库源码依赖管理器（三）/</id>
    <published>2018-05-04T03:34:06.000Z</published>
    <updated>2018-05-04T06:18:53.551Z</updated>
    
    <content type="html"><![CDATA[<p>如何动态替换依赖？<br><a id="more"></a><br>前两篇我们说了下如何定义依赖描述文件，如何动态生成描述文件，那有了这些信息，我们该怎么去动态替换依赖？</p><p>如果要把线上依赖替换为本地Project依赖，先要把本地Project include进当前业务工程。在这之前先加载依赖描述文件进内存，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> shell = <span class="keyword">new</span> GroovyShell(<span class="keyword">this</span>.getClass().getClassLoader())</span><br><span class="line">shell.evaluate(<span class="keyword">new</span> File(<span class="string">"依赖描述文件路径"</span>))</span><br></pre></td></tr></table></figure><p><strong>注：在依赖描述文件里，记得引用DSL使用的类，例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import xxx.Module</span><br><span class="line">@groovy.transform.BaseScript Module module</span><br></pre></td></tr></table></figure><p>然后循环迭代依赖描述 List，根据描述信息include相应的工程，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> projectName = <span class="string">":模块名字"</span></span><br><span class="line">settings.include(projectName)</span><br><span class="line">settings.project(projectName).projectDir = <span class="keyword">new</span> File(<span class="string">"模块本地路径"</span>)</span><br></pre></td></tr></table></figure><p>到这一步，需要包含的Project已经包含了进来，在AS工程栏就可以看到包括进来的模块了。</p><p>需要替换的模块已经包含进来了，下一步就是根据依赖描述配置信息替换线上依赖，基本思路如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">project.afterEvaluate &#123;</span><br><span class="line">    <span class="comment">//寻找当前节点</span></span><br><span class="line">    <span class="keyword">def</span> currentItem = modules.find &#123;</span><br><span class="line">        project.name == it.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentItem == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 寻找子节点</span></span><br><span class="line">    List&lt;String&gt; seeds = currentItem.seeds</span><br><span class="line">    <span class="keyword">if</span> (seeds == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 迭代子节点</span></span><br><span class="line">    seeds.each &#123; seedName -&gt;</span><br><span class="line">        <span class="comment">// 寻找子节点对象</span></span><br><span class="line">        <span class="keyword">def</span> seed = modules.find &#123;</span><br><span class="line">            it.name == seedName</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (seed == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> (seed.on_off) &#123;</span><br><span class="line">            <span class="comment">// 根据模块名字和group去除线上依赖</span></span><br><span class="line">            Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;()</span><br><span class="line">            map.put(<span class="string">"module"</span>, seed.name)</span><br><span class="line">            map.put(<span class="string">"group"</span>, <span class="string">"xxx"</span>)</span><br><span class="line">            project.configurations.compile.exclude(map)</span><br><span class="line">            <span class="comment">// 添加本地Project依赖</span></span><br><span class="line">            project.dependencies.add(<span class="string">"api"</span>, project.dependencies.project([<span class="string">path:</span> <span class="string">":"</span> + seed.name]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在线上依赖已经替换为本地模块，在代码里点击相应模块的引用已经自动跳转到本地。</p><p>仓库源码依赖管理器基本的功能已经完成了，如果需要调试模块的本地代码，只需要在源码依赖描述里把相应模块开关打开即可，是不是很方便？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何动态替换依赖？&lt;br&gt;
    
    </summary>
    
    
      <category term="依赖管理器" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>仓库源码依赖管理器（二）</title>
    <link href="http://yoursite.com/2018/05/04/%E4%BB%93%E5%BA%93%E6%BA%90%E7%A0%81%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/04/仓库源码依赖管理器（二）/</id>
    <published>2018-05-04T02:47:50.000Z</published>
    <updated>2018-05-04T06:18:59.606Z</updated>
    
    <content type="html"><![CDATA[<p>如何动态生成依赖描述？<br><a id="more"></a></p><p>上一篇我们定义了依赖描述的基本格式，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">    on_off true</span><br><span class="line">    name &quot;我是名字&quot;</span><br><span class="line">    path &quot;/path&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想做的更通用，能让其他业务工程方便的接入仓库源码依赖，那每一次接入的时候都要编写大量的依赖描述，而且每一次依赖变了，都需要手动修改描述文件。那可不可以动态生成依赖描述？</p><p>我们都知道有一个androidDependencies任务，执行任务会把工程的依赖在控制台输出，如果我们实现类似的任务，可以扫描出当前的依赖关系，然后根据我们的依赖描述定义输出为DSL文件就可以解决了。</p><p>我们在任务执行期间可以拿到project config 信息，然后根据第一级的依赖信息生成节点依赖信息，然后递归查找当前节点的子节点，最后就可以生成类似树状的依赖关系，基本思路如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">project.configurations.each &#123; config -&gt;</span><br><span class="line">    // 这里可以添加些异常检查</span><br><span class="line">    config.resolvedConfiguration.firstLevelModuleDependencies.each &#123; dep -&gt;</span><br><span class="line">        def generateModuleDep</span><br><span class="line">        generateModuleDep = &#123; resolvedDep -&gt;</span><br><span class="line">            // 这里可以根据 resolvedDep moduleGroup moduleName 等信息生成当前依赖信息</span><br><span class="line">            resolvedDep.children.each &#123; childResolvedDep -&gt;</span><br><span class="line">                if (resolvedDep in childResolvedDep.getParents()) &#123;</span><br><span class="line">                    // 子节点递归扫描依赖</span><br><span class="line">                    generateModuleDep(childResolvedDep)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        generateModuleDep(dep)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点的信息可以按照实际情况存储到相应的数据结构中，我这里是把节点的对象直接存到List中。</p><p>现在我们已经获取到各个节点的信息了，那我们怎么把节点信息导出为文件呢？</p><p>groovy 支持使用模板生成字符串，生成文件当然也是可以的。</p><p>先定义一个依赖描述模板，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">    on_off $&#123;on_off&#125;</span><br><span class="line">    name $&#123;name&#125;</span><br><span class="line">    path $&#123;path&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步定义一个节点信息Map，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def binding = [</span><br><span class="line">        on_off    : true, // 节点信息的开关值</span><br><span class="line">        name      : &quot;节点信息的名字&quot;,</span><br><span class="line">        path      : &quot;节点的路径&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最后根据上面定义的模板和节点信息Map，输出格式化的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def template = new StreamingTemplateEngine().createTemplate(&quot;描述依赖模板&quot;)</span><br><span class="line">String response = template.make(&quot;节点信息Map&quot;)</span><br></pre></td></tr></table></figure><p>模板引擎的make函数返回就是已经填好内容的格式化字符串，根据输出的字符串就可以输出到依赖描述文件。</p><p>现在在业务工程执行当前的任务，就可以动态生成依赖描述文件。</p><p>下一篇我们将结合这两篇的内容做一个仓库源码依赖插件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何动态生成依赖描述？&lt;br&gt;
    
    </summary>
    
    
      <category term="依赖管理器" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>仓库源码依赖管理器（一）</title>
    <link href="http://yoursite.com/2018/05/03/%E6%BA%90%E7%A0%81%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/03/源码依赖管理器（一）/</id>
    <published>2018-05-03T04:18:36.000Z</published>
    <updated>2018-05-04T06:19:23.555Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇我们先看下如何定义依赖描述。<br><a id="more"></a><br>如果我们平常经常维护主工程的基础仓库，经常会遇到修改仓库后无法很好的验证修改的效果，要么是把仓库工程作为单独的git submodule嵌入到业务工程，或者是简单粗暴，直接把线上依赖注释掉，添加本地仓库的路径。</p><p>那么有没有一种好的方法，可以做到本地源码依赖和线上依赖无缝切换。</p><p>了解过iOS开发的都知道，iOS依赖是直接下载依赖仓库的源码，本地依赖直接编译，依赖管理器叫CocoaPods，Android 平台是通过Gradle 从 Maven 或者JCenter 下载二进制文件。那在Android 平台上如何实现依赖仓库源码文件？</p><p>依赖管理器大概由几部分组成，依赖描述文件、发布规范等。依赖描述文件各个依赖管理器采用的格式都有所不同，Json 、 XML 、DSL 等等。各种表达方式各有各的优点，Json XML 结构工程表达比较丰富，但是可读性较差，当工程有几十个依赖项Json XML 简直无法直视，DSL虽然在工程结构表达上较弱，但在可读性理解上优点非常明显，cocoapods 就采用了这种表达方式，非常优美，如下。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">'MyApp'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'AFNetworking'</span>, <span class="string">'~&gt; 2.6'</span></span><br><span class="line">  pod <span class="string">'ORStackView'</span>, <span class="string">'~&gt; 3.0'</span></span><br><span class="line">  pod <span class="string">'SwiftyJSON'</span>, <span class="string">'~&gt; 2.3'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>看着这种依赖关系描述，心情也会舒畅好多。</p><p>那么在Android 平台能不能实现类似的效果？Android 构建使用的是groovy语言，而且groovy对DSL支持的还不错，所以利用groovy DSL特性描述依赖关系就可以了，你以为它是一段描述，其实它是一个可执行脚本。</p><p>我们需要一个模块的描述，包括开关、名字、路径等等，类似如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">    on_off <span class="literal">true</span></span><br><span class="line">    name <span class="string">"我是名字"</span></span><br><span class="line">    path <span class="string">"/path"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，有了定义怎么实现？</p><p>我们看上面的依赖描述，其实都是一个个函数调用，比如 module 就可以是一个函数，函数的参数是一个闭包，同理on_off、name等等也是函数调用，在函数后面的即为函数的参数。</p><p>是不是很有意思？一句话就可以作为一个脚本执行。</p><p>所以，我们需要定义我们依赖描述中要用到的函数，如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span> &#123;</span></span><br><span class="line">    <span class="keyword">boolean</span> on_off</span><br><span class="line">    String name</span><br><span class="line">    String path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> on_off(<span class="keyword">boolean</span> on_off) &#123;</span><br><span class="line">        <span class="keyword">this</span>.on_off = on_off</span><br><span class="line">        println(<span class="string">"module on_off:"</span> + on_off)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> name(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        println(<span class="string">"module name:"</span> + name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> path(String path) &#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path</span><br><span class="line">        println(<span class="string">"module path:"</span> + path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Module module(<span class="meta">@DelegatesTo</span>(strategy = Closure.DELEGATE_FIRST, value = Module) Closure script) &#123;</span><br><span class="line">    script.resolveStrategy = Closure.DELEGATE_FIRST</span><br><span class="line">    Module module = <span class="keyword">new</span> Module()</span><br><span class="line">    script.delegate = module</span><br><span class="line">    script()</span><br><span class="line">    <span class="keyword">return</span> script.delegate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>名为module的函数接收一个闭包，闭包代理为Module类，闭包内的函数自动执行代理类函数调用，类和函数定义完成后，然后在控制台试验下（Android Studio -&gt; Tools -&gt; Groovy Console），在定义的类和函数下面写上如下的DSL生命，执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module &#123;</span><br><span class="line">    on_off true</span><br><span class="line">    name &quot;我是名字&quot;</span><br><span class="line">    path &quot;我是路径&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：<br>module on_off:true<br>module name:我是名字<br>module path:我是路径</p><p>看来我们定义的DSL已经成功被解析。</p><p>依赖描述已经定义完成，下一篇会说下如何动态生成依赖描述文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇我们先看下如何定义依赖描述。&lt;br&gt;
    
    </summary>
    
    
      <category term="依赖管理器" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>善变的架构</title>
    <link href="http://yoursite.com/2018/03/08/%E5%96%84%E5%8F%98%E7%9A%84%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2018/03/08/善变的架构/</id>
    <published>2018-03-08T12:14:49.000Z</published>
    <updated>2018-05-04T02:48:29.565Z</updated>
    
    <content type="html"><![CDATA[<p>架构会有多善变？<br><a id="more"></a></p><p><img src="/images/mercurial_arch1.jpg" alt=""><br>上图是一个常见的App分层架构，之后随着业务发展，架构会如何变化呢？</p><p>再看微信在两个阶段结构图：</p><p>阶段1：<br><img src="http://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsEtkaaicsI8wgxa1JYjMPgKk4YHEQ68H0k8nvBdde3HRtyiaLPPQQo6s50hWG7YgE1BLcaxAQUbVGQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>阶段2：<br><img src="http://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9McsEtkaaicsI8wgxa1JYjMPgKBUF2WRGbhm7wnIaYf0EPxqqhj6V8defhW7htOzcuDSG2fZo6g97o6w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>可以看到微信在阶段1架构类似于常见的App分层架构，但是随着业务不断膨胀，发展到阶段2某些模块发生了劣化。为什么会出现这种问题？架构随着业务不断发展，最上层业务模块横向进行扩展，某一个业务并不会劣化，同理，最底层的组件，也不会出现较大的劣化。随着平行的业务模块交互越来越多，依赖的业务功能按照普通做法只能下沉到中间模块，这时劣化就渐渐的开始。</p><p>明确了问题，那该如何解决？Gradle Module 只能一个模块依赖另一个模块，而不能再细化模块的依赖，那我们只能自定义依赖关系。<br>在Module 里面划分小模块，分离Java Res Manifest 等资源，在property文件中定义该依赖哪些东西，在编译期检查依赖的合理性。如下图：</p><p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/csvJ6rH9McsEtkaaicsI8wgxa1JYjMPgKPnRJbICic24yJaW7LhARLdaIHZvDmK0Sr5LHRJVgvDZc5ytbf1w90DQ/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>这样就可以细化模块之间的依赖范围，模块之间也可以相互依赖。依赖并保持克制。</p><p>良好的架构除了要保持代码和规范的良好性，还应该做到哪些事情？</p><p>单端单产品按业务复杂度大概分为三种规模，十人之下、三十人左右、百人团队。十人左右团队考虑的更多是怎么快速的迭代业务，架构考虑更多的是如何辅助业务发展。三十人团队考虑的更多的是怎么样保持业务的并行进展，架构考虑更多的是如何使各业务线耦合度更低、沟通更顺畅、业务性能可控，取决于架构的复用、解耦、稳定及监控能力，如果架构做不到上述几点，将会拖累业务的发展，甚至导致业务失控。百人团队考虑的更多是业务并行及可控性，架构考虑更多的会是产品整个生命周期的并行及支撑体系，例如，研发支撑：在线定位用户操作的链路，测试支撑：自动化测试脚本，运维支撑：稳定性分析、舆情监控，发布支撑：更精确的灰度验证、实时发布。</p><p>完整的产品生命周期包括，工程期、运行期、运维期，良好的架构应该有解决上述各个时期问题的能力。比如在工程编码期，编码规范及代码风格检查的工具。在工程编译期，检查模块之间依赖、生成辅助代码的能力。在运行期，监控App性能、压测模块的能力。在运维期，包大小预警、打包平台、在线提取用户异常业务日志、实时修复能力。</p><p>架构，善变。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;架构会有多善变？&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>容器框架Atlas原理解析</title>
    <link href="http://yoursite.com/2017/12/17/%E5%AE%B9%E5%99%A8%E6%A1%86%E6%9E%B6Atlas%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/12/17/容器框架Atlas原理解析/</id>
    <published>2017-12-17T10:03:03.000Z</published>
    <updated>2018-05-04T02:48:35.001Z</updated>
    
    <content type="html"><![CDATA[<p>优秀的架构在于解决产品编码期、运行期、测试期及后期运维的各种问题。<br><a id="more"></a></p><p>一个产品，当只有一两个工程师，这时没什么问题。当达到10人左右，沟通成本、协作效率、软件质量问题开始显现。当达到30+人，多业务线并行，开发效率、线上事故、代码合板等问题已经开始成为了产品瓶颈。那我们该怎么解决？</p><p>Atlas是在手淘架构不断发展演化出来的一个解决方案，比较适用于多业务线产品。Atlas把各个业务线分为多个bundle，bundle之间共享资源放在Host中，这样在编码编译期做到了天然隔离。在工程期，各bundle和host独立编译开发。运行期，按需加载bundle。运维期，动态部署业务需求、灵活精确灰度测试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;优秀的架构在于解决产品编码期、运行期、测试期及后期运维的各种问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Android业务中间层该如何设计？</title>
    <link href="http://yoursite.com/2017/10/11/Android%E4%B8%9A%E5%8A%A1%E4%B8%AD%E9%97%B4%E5%B1%82%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/10/11/Android业务中间层该如何设计？/</id>
    <published>2017-10-11T11:04:45.000Z</published>
    <updated>2018-05-04T03:35:02.668Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个产品需要有多个业务线，各业务线之间如何协作才是最高效的？<br><a id="more"></a></p><p><img src="/images/Android业务中间层1.png" alt=""></p><p>上图是比较常见的业务组装方式，如果需要添加某个业务，把相应的View直接写在Layout里，然后处理业务逻辑。但是如果业务模块多达几十个，散落的逻辑有几千行，这时该如何设计才能保证各业务的稳定和可扩展性？</p><p><img src="/images/Android业务中间层2.png" alt=""></p><p>公共业务应该是各个业务积木堆积组成，各个积木之间是黑盒状态，只能通过“窗口”向外提供服务，以及发布需求。中间层委托、代理信息的传递。</p><p>中间层在Android平台该如何设计？</p><ul><li>Android平台起点及终点都是和界面的生命周期息息相关，中间层作为业务/界面的承载模型，所以应该继承自View。</li><li>各个业务积木之间是独立、隔离、和动态的，业务积木通过中间承载模型加载/卸载也应该是动态的。</li><li>中间层作为界面承载模型，所以也是有生命周期的，且依赖于外部。</li><li>中间层除了承载、通信职责，也应该随着外部环境变化，去影响业务积木的改变。</li></ul><p><strong>对外协议</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托协议</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jacky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 对外暴露的协议</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/9/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBusinessDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">IBusinessDelegate <span class="title">setup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IBusinessDelegate <span class="title">setupBusiness1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IBusinessDelegate <span class="title">setupBusiness2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IBusinessDelegate <span class="title">setupBusiness3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IBusinessDelegate <span class="title">setupBusiness4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">event1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">event2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中间层实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jacky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 委托，隔离各业务间的耦合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2017/9/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessDelegate</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> <span class="keyword">implements</span> <span class="title">IBusinessDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;Context&gt; mContextReference;</span><br><span class="line">    <span class="keyword">private</span> TimingChestContract.Presenter mTimingChestPresenter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessDelegate</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessDelegate</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessDelegate</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBusinessDelegate <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mContextReference = <span class="keyword">new</span> WeakReference&lt;&gt;(getContext());</span><br><span class="line">        removeAllViews();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- 动态加载挂件 Start ----</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBusinessDelegate <span class="title">setupBusiness1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TimingChestView chestView = <span class="keyword">new</span> TimingChestView(mContextReference.get());</span><br><span class="line">        mTimingChestPresenter = <span class="keyword">new</span> TimingChestPresenter(chestView, <span class="keyword">new</span> TimingChestModel());</span><br><span class="line">        chestView.setPresenter(mTimingChestPresenter);</span><br><span class="line">        LayoutParams params = <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">        params.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);</span><br><span class="line">        addView(chestView, params);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBusinessDelegate <span class="title">setupBusiness2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBusinessDelegate <span class="title">setupBusiness3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBusinessDelegate <span class="title">setupBusiness4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ---- 动态加载挂件 End ----</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- 接收事件 Start ----</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">event1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTimingChestPresenter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTimingChestPresenter.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">event2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ---- 接收事件 End ----</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- 生命周期 Start ----</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!EventBus.getDefault().isRegistered(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mTimingChestPresenter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTimingChestPresenter.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTimingChestPresenter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTimingChestPresenter.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTimingChestPresenter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTimingChestPresenter.onPause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mTimingChestPresenter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTimingChestPresenter.onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ---- 生命周期 End ----</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托作为中间层的呈现方式，动态加载业务积木，并感应外部环境变化反应到业务积木。通过这种方式，业务积木就有了很好的稳定性和扩展性。并辅以辅助手段，使委托变得异常强大。</p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果一个产品需要有多个业务线，各业务线之间如何协作才是最高效的？&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>关于Dalvik，我们该知道些什么？</title>
    <link href="http://yoursite.com/2017/08/21/%E5%85%B3%E4%BA%8EDalvik%EF%BC%8C%E6%88%91%E4%BB%AC%E8%AF%A5%E7%9F%A5%E9%81%93%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/08/21/关于Dalvik，我们该知道些什么？/</id>
    <published>2017-08-21T12:51:54.000Z</published>
    <updated>2018-05-04T03:34:53.557Z</updated>
    
    <content type="html"><![CDATA[<p>Dalvik和JVM的区别<br>Dex文件的结构<br>Dalvik如何加载Class<br><a id="more"></a></p><h2 id="Dalvik和JVM的区别"><a href="#Dalvik和JVM的区别" class="headerlink" title="Dalvik和JVM的区别"></a>Dalvik和JVM的区别</h2><p>Dalvik和JVM最主要区别是它们分别具有不同的类文件格式和指令集。Dalvik使用的是dex（Dalvik Executable）格式的类文件，而Java虚拟机使用的是class格式的类文件。</p><p>Dalvik的指令是基于寄存器的，而JVM的指令是基于堆栈的，因此Dalvik需要更多的指令空间。这样的区别其实各有优劣，JVM需要占用更多的CPU时间，而Dalvik的数据缓冲更容易失效。</p><h2 id="Dex文件结构"><a href="#Dex文件结构" class="headerlink" title="Dex文件结构"></a>Dex文件结构</h2><p>先看一张Class文件和Dex文件对比图：<br><img src="https://i.stack.imgur.com/1kLrB.png" alt=""></p><p>Dex这么设计可以使文件更紧凑，减少拢余，还可以共享资源，进而减少文件大小。</p><p>各个字段含义如下：</p><table><thead><tr><th style="text-align:left">数据名称</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">header</td><td style="text-align:left">Dex文件头部，记录整个Dex文件的相关属性</td></tr><tr><td style="text-align:left">string_ids</td><td style="text-align:left">字符串数据索引，记录了每个字符串在数据区的偏移量</td></tr><tr><td style="text-align:left">type_ids</td><td style="text-align:left">类似数据索引，记录了每个类型的字符串索引</td></tr><tr><td style="text-align:left">proto_ids</td><td style="text-align:left">原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表</td></tr><tr><td style="text-align:left">field_ids</td><td style="text-align:left">字段数据索引，记录了所属类、类型以及方法名</td></tr><tr><td style="text-align:left">method_ids</td><td style="text-align:left">类方法索引，记录方法所属类名、方法声明以及方法名等信息</td></tr><tr><td style="text-align:left">class_defs</td><td style="text-align:left">类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量</td></tr><tr><td style="text-align:left">data</td><td style="text-align:left">数据区，保存了各个类的真实数据</td></tr><tr><td style="text-align:left">link_data</td><td style="text-align:left">链接数据区</td></tr></tbody></table><h2 id="Dalvik如何加载Class"><a href="#Dalvik如何加载Class" class="headerlink" title="Dalvik如何加载Class"></a>Dalvik如何加载Class</h2><h3 id="解析Dex"><a href="#解析Dex" class="headerlink" title="解析Dex"></a>解析Dex</h3><p>加载之前需要有一个解析过程，Dex文件大体可以分为三大部分：头部、索引、数据。通过头部可以找到索引的数目、位置和数据的起始位置。然后，Dalvik会调用dexFileParse函数对它进行分析，分析的结果放到DexFile数据结构中。</p><h3 id="加载Dex"><a href="#加载Dex" class="headerlink" title="加载Dex"></a>加载Dex</h3><p>存储的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Object &#123;</span><br><span class="line">    ClassObject* clazz;  <span class="comment">// 类型对象</span></span><br><span class="line">    Lock lock;           <span class="comment">// 锁对象</span></span><br><span class="line">&#125; Object;</span><br></pre></td></tr></table></figure><p>clazz指向ClassObject对象，里面还包含一个Lock对象。如果其它线程想要获取它的锁，只有等当前线程释放掉才可以。</p><p>从Dex数据区读取过程中，会在内存中分配几个内存区域，用于存放directMethod、virtualMethod、sfield、ifield。等得到索引后，加载实际是由loadClassFromDex完成，它首先会先读取class的具体信息，再加载directMethod、virtualMethod、sfield、ifield，然后会为ClassObject数据结构分配内存，并读取Dex文件相关信息。等加载完成后，将加载的class放入哈希表中方便下次快速查找。</p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dalvik和JVM的区别&lt;br&gt;Dex文件的结构&lt;br&gt;Dalvik如何加载Class&lt;br&gt;
    
    </summary>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Too many classes in --main-dex-list, main dex capacity exceeded | 主Dex引用太多怎么办？</title>
    <link href="http://yoursite.com/2017/06/14/Too-many-classes-in-main-dex-list-main-dex-capacity-exceeded-%E4%B8%BBDex%E5%BC%95%E7%94%A8%E5%A4%AA%E5%A4%9A%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/06/14/Too-many-classes-in-main-dex-list-main-dex-capacity-exceeded-主Dex引用太多怎么办？/</id>
    <published>2017-06-14T10:27:59.000Z</published>
    <updated>2018-05-04T03:35:13.162Z</updated>
    
    <content type="html"><![CDATA[<p>主 dex 里面会有 Application、Activity、Service、Receiver、Provider、Instrumentation、BackupAgent 和 Annotation。当这些类以及直接引用类比较多的时候，都要塞进主 dex ，就会引发 main dex capacity exceeded build error 。</p><a id="more"></a><p>在Lollipop之前的设备上，主Dex仅仅被Framework加载。为了支持multi-dex，应用必须明确的让类加载器去加载二级Dex文件（这就是为什么要调用MultiDex#install）</p><p>那就是说应用的主Dex应该包含所有的即将被加载器访问的类，如果你的应用的代码试着在类加载器加载之前，去引用二级Dex里面的class就会抛出Class Not Found异常。</p><p><strong>那什么样的类会被包含在主Dex里面？</strong></p><p>会有三个顺序执行的任务将会决定哪个类应该被包含在主Dex里。</p><ol><li><code>collect{variant}MultiDexComponents task</code>，这个任务会根据manifest把所有应用组件（application, activities, services, receivers, providers）的名字写到一个文本文件。因此，如果你没有把其中的组件注册到manifest，那就不会被包含到主Dex里，也会有一些不注册的class也会被包含进去，比如注解。查看下CreateManifestKeepList.groovy 的源码就可以看到完整的包含列表。这个任务输出的文件是 manifest_keep.txt，路径为：app/build/intermediates/multi-dex。</li><li><code>shrink{variant}MultiDexComponents task</code>，这个任务会掉起ProGuard程序创建一个压缩过的Jar文件，这个文件里只包含manifest_keep.txt里的class，这个任务输出的文件是componentClasses.jar</li><li><code>create{variant}MainDexClassList task</code>，这个任务会解析componentClasses.jar文件，为每一个类文件计算直接的引用层级，具体实现请查看<a href="https://android.googlesource.com/platform/dalvik/+/master/dx/src/com/android/multidex/ClassReferenceListBuilder.java" target="_blank" rel="noopener">链接</a>。因此，如果你应用有一个注册的组件包含类X的变量，类X也会被包含进主Dex里面。这个任务输出的文件为：maindexlist.txt，包含主Dex里面所有的类。</li></ol><p><strong>如果最低版本是21会发生什么？</strong><br>如果最低版本是21上面所有的任务都不会执行，也不会有主Dex列表的计算。这是因为在应用安装期间所有的dex文件都会被ART转换为一个.oat文件。</p><p>所以如果这些类的引用超过了65536，构建的时候就会抛出这个<code>Too many classes in --main-dex-list, main dex capacity exceeded</code> 错误</p><p><strong>那到底解决方案是什么？</strong><br>升级Gradle plugin的版本到2.2.0-alpha4以上，例：<code>classpath &#39;com.android.tools.build:gradle:2.2.0&#39;</code>，可以查看关于这个问题的<a href="https://issuetracker.google.com/issues/37097145#c8" target="_blank" rel="noopener">Google Issue Tracker</a></p><p><strong>参考：</strong><a href="https://stackoverflow.com/questions/32721083/too-many-classes-in-main-dex-list-main-dex-capacity-exceeded" target="_blank" rel="noopener">Too many classes in –main-dex-list, main dex capacity exceeded</a></p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主 dex 里面会有 Application、Activity、Service、Receiver、Provider、Instrumentation、BackupAgent 和 Annotation。当这些类以及直接引用类比较多的时候，都要塞进主 dex ，就会引发 main dex capacity exceeded build error 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="疑难杂症" scheme="http://yoursite.com/tags/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
  </entry>
  
  <entry>
    <title>Hello Kotlin</title>
    <link href="http://yoursite.com/2017/06/12/Hello%20Kotlin/"/>
    <id>http://yoursite.com/2017/06/12/Hello Kotlin/</id>
    <published>2017-06-12T06:16:18.000Z</published>
    <updated>2018-05-04T03:37:41.569Z</updated>
    
    <content type="html"><![CDATA[<p>前世今生<br>有什么样的语法？<br>语法是怎么实现的？<br>如何编译的？<br>迁移成本<br>为我们带来什么改变？<br><a id="more"></a></p><h2 id="前世今生"><a href="#前世今生" class="headerlink" title="前世今生"></a>前世今生</h2><h3 id="设计出发点"><a href="#设计出发点" class="headerlink" title="设计出发点"></a>设计出发点</h3><ol><li>Concise — 简洁</li><li>Safe — 安全</li><li>Interoperable — 协作</li></ol><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>Statically typed programming language for modern multiplatform applications<br>静态类型编程语言用于现代多平台应用</p><h2 id="有什么样的语法？"><a href="#有什么样的语法？" class="headerlink" title="有什么样的语法？"></a>有什么样的语法？</h2><h3 id="语法对比"><a href="#语法对比" class="headerlink" title="语法对比"></a>语法对比</h3><table><thead><tr><th>Kotlin vs Java</th><th>kotlin</th><th>Java</th></tr></thead><tbody><tr><td>函数</td><td>fun sum(a: Int, b: Int): Int { return a + b }</td><td>public int sum(int a, int b) {return a + b;}</td></tr><tr><td>变量</td><td>var a: Int = 1</td><td>int a = 1;</td></tr><tr><td>非空判断</td><td>text?.let { val length = text.length }</td><td>if (text != null) { int length = text.length(); }</td></tr><tr><td>开关</td><td>var grade = when (score) {1, 2 -&gt; “Excellent” }</td><td>String grade; switch (score) { case 1: case 2: grade = “Excellent”; break; }</td></tr></tbody></table><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p><strong>数字</strong></p><ol><li>数字没有隐式拓宽转换，如 Java 中 int可以隐式转换为long</li><li>使数字常量更易，val oneMillion = 1_000_000</li><li>对于位运算，没有特殊字符来表示，而只可用中缀方式调用命名函数，例如:val x = (1 shl 2) and 0x000FF000，shl:有符号左移 and:位与</li></ol><p><strong>字符</strong></p><ol><li>字符用 Char 类型表示，它们不能直接当作数字，但可以显示转换</li><li>模板：val i = 10  val s = “i = $i” // 求值结果为 “i = 10”</li></ol><p><strong>控制流</strong></p><p><strong>If</strong>：是一个表达式，即它会返回一个值，没有三元运算符，使用if表达：<code>val max = if (a &gt; b) a else b</code></p><p><strong>When</strong>：取代了类 C 语言的 switch 操作符，简单形式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">"x is neither 1 nor 2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>when 既可以被当做表达式使用也可以被当做语句使用。可以用任意表达式（而不只是常量）作为分支条件：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    parseInt(s) -&gt; print(<span class="string">"s encodes x"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"s does not encode x"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>返回和跳转</strong></p><p>跳转表达式都可以用作更大表达式的一部分：<br><code>val s = person.name ?: return</code></p><p>标签：我们可以用标签限制 break 或者continue：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop@ for (i in 1..100) &#123;</span><br><span class="line">    for (j in 1..100) &#123;</span><br><span class="line">        if (……) break@loop</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p><strong>类</strong></p><p>类声明：<br>Kotlin 中所有的类默认都是 final，由类名、类头（指定其类型参数、主 构造函数等）和由大括号包围的类体构成。类头和类体都是可选的； 如果一个类没有类体，可以省略花括号。通常如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoice</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例：<br><code>val invoice = Invoice()</code>，Kotlin 并没有 new 关键字。</p><p>覆盖：<br>Kotlin力求清晰显式。与 Java 不同，Kotlin 需要显式 标注可覆盖的成员。如：override、open</p><p>静态方法：<br>Kotlin 中类没有静态方法。建议简单地使用包级函数。</p><p><strong>属性和字段</strong></p><p>声明一个属性的完整语法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringRepresentation: String</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.toString()</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        setDataFromString(value) <span class="comment">// 解析字符串并赋值给其他属性</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>接口</strong></p><p>Kotlin 的接口与 Java 8 类似，既包含抽象方法的声明，也包含实现。与抽象类不同的是，接口无法保存状态。它可以有 属性但必须声明为抽象或提供访问器实现。</p><p>使用关键字 interface 来定义接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// 可选的方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可见性修饰符</strong></p><p>Kotlin 中有这四个可见性修饰符：private、 protected、 internal 和 public， 默认可见性是 public。</p><p>可见性修饰符 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件：<br>        一个 IntelliJ IDEA 模块；<br>        一个 Maven 或者 Gradle 项目；<br>        一次 ＜kotlinc＞ Ant 任务执行所编译的一套文件。</p><p><strong>扩展</strong>        </p><p>Kotlin 同 C# 和 Gosu 类似，能够扩展一个类的新功能而无需继承该类或使用像装饰者这样的任何类型的设计模式。 这通过叫做 扩展 的特殊声明完成。Kotlin 支持 扩展函数 和 扩展属性。</p><p>声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面代码为 MutableList<int> 添加一个swap 函数：</int></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">swap</span><span class="params">(index1: <span class="type">Int</span>, index2: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> tmp = <span class="keyword">this</span>[index1] <span class="comment">// “this”对应该列表</span></span><br><span class="line">    <span class="keyword">this</span>[index1] = <span class="keyword">this</span>[index2]</span><br><span class="line">    <span class="keyword">this</span>[index2] = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据类</strong></p><p>我们经常创建一些只保存数据的类。在这些类中，一些标准函数往往是从 数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为<br><code>data：data class User(val name: String, val age: Int)</code></p><h3 id="语法实现原理"><a href="#语法实现原理" class="headerlink" title="语法实现原理"></a>语法实现原理</h3><p><strong>Null Safe Operator实现原理</strong><br>示例函数如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testNullSafeOperator</span><span class="params">(string: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(string?.toCharArray())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的字节码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public final testNullSafeOperator(Ljava/lang/String;)V</span><br><span class="line">    @Lorg/jetbrains/annotations/Nullable;() // invisible, parameter 0</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER 15 L0</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    ALOAD 1</span><br><span class="line">    DUP</span><br><span class="line">    IFNULL L1</span><br><span class="line">    ASTORE 2</span><br><span class="line">    ASTORE 3</span><br><span class="line">   L2</span><br><span class="line">    ALOAD 2</span><br><span class="line">    DUP</span><br><span class="line">    IFNONNULL L3 //非空判断</span><br><span class="line">    NEW kotlin/TypeCastException</span><br><span class="line">    DUP</span><br><span class="line">    LDC &quot;null cannot be cast to non-null type java.lang.String&quot;</span><br><span class="line">    INVOKESPECIAL kotlin/TypeCastException.&lt;init&gt; (Ljava/lang/String;)V</span><br><span class="line">    ATHROW</span><br><span class="line">   L3</span><br><span class="line">    INVOKEVIRTUAL java/lang/String.toCharArray ()[C</span><br><span class="line">    DUP</span><br><span class="line">    LDC &quot;(this as java.lang.String).toCharArray()&quot;</span><br><span class="line">    INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkExpressionValueIsNotNull (Ljava/lang/Object;Ljava/lang/String;)V</span><br><span class="line">   L4</span><br><span class="line">    ASTORE 4</span><br><span class="line">    ALOAD 3</span><br><span class="line">    ALOAD 4</span><br><span class="line">   L5</span><br><span class="line">    LINENUMBER 15 L5</span><br><span class="line">    GOTO L6</span><br><span class="line">   L1</span><br><span class="line">    POP</span><br><span class="line">    ACONST_NULL</span><br><span class="line">   L6</span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println ([C)V</span><br><span class="line">   L7</span><br><span class="line">    LINENUMBER 16 L7</span><br><span class="line">    RETURN</span><br><span class="line">   L8</span><br><span class="line">    LOCALVARIABLE this Ltech/jackywang/kotlindemo/Test; L0 L8 0</span><br><span class="line">    LOCALVARIABLE string Ljava/lang/String; L0 L8 1</span><br><span class="line">    MAXSTACK = 5</span><br><span class="line">    MAXLOCALS = 5</span><br></pre></td></tr></table></figure><p>反编译为Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">testNullSafeOperator</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">      PrintStream var10000 = System.out;</span><br><span class="line">      <span class="keyword">char</span>[] var10001;</span><br><span class="line">      <span class="keyword">if</span>(string != <span class="keyword">null</span>) &#123;</span><br><span class="line">         PrintStream var3 = var10000;</span><br><span class="line">         <span class="keyword">if</span>(string == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TypeCastException(<span class="string">"null cannot be cast to non-null type java.lang.String"</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">char</span>[] var5 = string.toCharArray();</span><br><span class="line">         Intrinsics.checkExpressionValueIsNotNull(var5, <span class="string">"(this as java.lang.String).toCharArray()"</span>);</span><br><span class="line">         <span class="keyword">char</span>[] var4 = var5;</span><br><span class="line">         var10000 = var3;</span><br><span class="line">         var10001 = var4;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         var10001 = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var10000.println(var10001);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由此可见kotlin实现的非空 <code>？</code> 语法，内部就是利用非空判断实现。</p><h3 id="与Java互操作"><a href="#与Java互操作" class="headerlink" title="与Java互操作"></a>与Java互操作</h3><p>Kotlin 中自然地调用现存的 Java 代码，并且在 Java 代码中也可以很顺利地调用 Kotlin 代码。</p><p><strong>空安全和平台类型</strong><br>Java 中的任何引用都可能是 null，这使得 Kotlin 对来自 Java 的对象要求严格空安全是不现实的。 Java 声明的类型在 Kotlin 中会被特别对待并称为平台类型。对这种类型的空检查会放宽， 因此它们的安全保证与在 Java 中相同</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = ArrayList&lt;String&gt;() <span class="comment">// 非空（构造函数结果）</span></span><br><span class="line">list.add(<span class="string">"Item"</span>)</span><br><span class="line"><span class="keyword">val</span> size = list.size() <span class="comment">// 非空（原生 int）</span></span><br><span class="line"><span class="keyword">val</span> item = list[<span class="number">0</span>] <span class="comment">// 推断为平台类型（普通 Java 对象）</span></span><br><span class="line">item.substring(<span class="number">1</span>) <span class="comment">// 允许，如果 item == null 可能会抛出异常</span></span><br></pre></td></tr></table></figure><p><strong>受检异常</strong><br>在 Kotlin 中，所有异常都是非受检的，这意味着编译器不会强迫你捕获其中的任何一个。 因此，当你调用一个声明受检异常的 Java 方法时，Kotlin 不会强迫你做任何事情：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">render</span><span class="params">(list: <span class="type">List</span>&lt;*&gt;, to: <span class="type">Appendable</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> list) &#123;</span><br><span class="line">        to.append(item.toString()) <span class="comment">// Java 会要求我们在这里捕获 IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何编译？"><a href="#如何编译？" class="headerlink" title="如何编译？"></a>如何编译？</h2><h3 id="编译入口"><a href="#编译入口" class="headerlink" title="编译入口"></a>编译入口</h3><p>从<code>kotlinc Hello.kt</code> 开始分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cygwin=false;</span><br><span class="line">case &quot;`uname`&quot; in</span><br><span class="line">    CYGWIN*) cygwin=true ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">declare -a kotlin_app</span><br><span class="line"></span><br><span class="line">//运行入口</span><br><span class="line">if [ -n &quot;$KOTLIN_RUNNER&quot; ];</span><br><span class="line">then</span><br><span class="line">    java_args=(&quot;$&#123;java_args[@]&#125;&quot; &quot;-Dkotlin.home=$&#123;KOTLIN_HOME&#125;&quot;)</span><br><span class="line">    kotlin_app=(&quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-runner.jar&quot; &quot;org.jetbrains.kotlin.runner.Main&quot;)</span><br><span class="line">else</span><br><span class="line">//编译入口</span><br><span class="line">    [ -n &quot;$KOTLIN_COMPILER&quot; ] || KOTLIN_COMPILER=org.jetbrains.kotlin.cli.jvm.K2JVMCompiler</span><br><span class="line">    java_args=(&quot;$&#123;java_args[@]&#125;&quot; &quot;-noverify&quot;)</span><br><span class="line">    kotlin_app=(&quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-preloader.jar&quot; &quot;org.jetbrains.kotlin.preloading.Preloader&quot; &quot;-cp&quot; &quot;$&#123;KOTLIN_HOME&#125;/lib/kotlin-compiler.jar&quot; $KOTLIN_COMPILER)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">&quot;$&#123;JAVACMD:=java&#125;&quot; $JAVA_OPTS &quot;$&#123;java_args[@]&#125;&quot; -cp &quot;$&#123;kotlin_app[@]&#125;&quot; &quot;$&#123;kotlin_args[@]&#125;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fun compileBunchOfSources(environment: KotlinCoreEnvironment): Boolean &#123;</span><br><span class="line">        val moduleVisibilityManager = ModuleVisibilityManager.SERVICE.getInstance(environment.project)</span><br><span class="line"></span><br><span class="line">        val friendPaths = environment.configuration.getList(JVMConfigurationKeys.FRIEND_PATHS)</span><br><span class="line">        for (path in friendPaths) &#123;</span><br><span class="line">            moduleVisibilityManager.addFriendPath(path)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!checkKotlinPackageUsage(environment, environment.getSourceFiles())) return false</span><br><span class="line"></span><br><span class="line">        //词法、语法分析、语义分析、目标代码生成等过程</span><br><span class="line">        val generationState = analyzeAndGenerate(environment) ?: return false</span><br><span class="line"></span><br><span class="line">        // 找到运行主类</span><br><span class="line">        val mainClass = findMainClass(generationState, environment.getSourceFiles())</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //写入文件</span><br><span class="line">            writeOutput(environment.configuration, generationState.factory, mainClass)</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            generationState.destroy()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="目标代码的生成"><a href="#目标代码的生成" class="headerlink" title="目标代码的生成"></a>目标代码的生成</h3><p>在代码类生成的过程中，又包括生成类名、类体、字段、函数方法等环节，相关的生成类有ClassBodyCodegen、ClassFunctionCodegen、MemberCodegen、ExpressionCodegen、PropertyCodegen等。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinCodegenFacade</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> static void doGenerateFiles(</span><br><span class="line">            <span class="meta">@NotNull</span> Collection&lt;KtFile&gt; files,</span><br><span class="line">            <span class="meta">@NotNull</span> GenerationState state,</span><br><span class="line">            <span class="meta">@NotNull</span> CompilationErrorHandler errorHandler</span><br><span class="line">    ) &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">for</span> (KtFile file : files) &#123;</span><br><span class="line">         ...</span><br><span class="line">        Set&lt;FqName&gt; obsoleteMultifileClasses = new HashSet&lt;FqName&gt;(state.getObsoleteMultifileClasses());</span><br><span class="line">        <span class="keyword">for</span> (FqName multifileClassFqName : Sets.union(filesInMultifileClasses.keySet(), obsoleteMultifileClasses)) &#123;</span><br><span class="line">            doCheckCancelled(state);</span><br><span class="line">            <span class="comment">//目标代码类生成</span></span><br><span class="line">            generateMultifileClass(state, multifileClassFqName, filesInMultifileClasses.<span class="keyword">get</span>(multifileClassFqName), errorHandler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;FqName&gt; packagesWithObsoleteParts = new HashSet&lt;FqName&gt;(state.getPackagesWithObsoleteParts());</span><br><span class="line">        <span class="keyword">for</span> (FqName packageFqName : Sets.union(packagesWithObsoleteParts, filesInPackages.keySet())) &#123;</span><br><span class="line">            doCheckCancelled(state);</span><br><span class="line">            <span class="comment">//目标代码类包生成</span></span><br><span class="line">            generatePackage(state, packageFqName, filesInPackages.<span class="keyword">get</span>(packageFqName), errorHandler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        doCheckCancelled(state);</span><br><span class="line">        <span class="comment">//生成结束</span></span><br><span class="line">        state.getFactory().done();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin在目标代码生成环节做了更多的处理，在该环节实现了自动生成Getter、Setter的代码。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyCodegen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> void gen(</span><br><span class="line">            <span class="meta">@Nullable</span> KtProperty declaration, <span class="comment">// 属性声明</span></span><br><span class="line">            <span class="meta">@NotNull</span> PropertyDescriptor descriptor,  <span class="comment">//描述，包括权限修饰符、注解、类型等。</span></span><br><span class="line">            <span class="meta">@Nullable</span> KtPropertyAccessor getter, <span class="comment">// 决定是否生成getter</span></span><br><span class="line">            <span class="meta">@Nullable</span> KtPropertyAccessor setter  <span class="comment">//决定是否生成setter</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        assert kind == OwnerKind.PACKAGE || kind == OwnerKind.IMPLEMENTATION || kind == OwnerKind.DEFAULT_IMPLS</span><br><span class="line">                : <span class="string">"Generating property with a wrong kind ("</span> + kind + <span class="string">"): "</span> + descriptor;</span><br><span class="line">  <span class="comment">//生成注解信息</span></span><br><span class="line">        genBackingFieldAndAnnotations(declaration, descriptor, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据注解和权限修饰符等信息判断是否自动生成Getter代码</span></span><br><span class="line">        <span class="keyword">if</span> (isAccessorNeeded(declaration, descriptor, getter)) &#123;</span><br><span class="line">            generateGetter(declaration, descriptor, getter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据注解和权限修饰符等信息判断是否自动生成Setter代码</span></span><br><span class="line">        <span class="keyword">if</span> (isAccessorNeeded(declaration, descriptor, setter)) &#123;</span><br><span class="line">            generateSetter(declaration, descriptor, setter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kotlin到Java的迁移成本"><a href="#Kotlin到Java的迁移成本" class="headerlink" title="Kotlin到Java的迁移成本"></a>Kotlin到Java的迁移成本</h2><ol><li>文件自动转换，点击菜单栏 Code | Convert Java File to Kotlin File</li><li>语法兼容性</li><li>第三方库兼容性</li></ol><h2 id="Kotlin为Android开发者带来什么改变？"><a href="#Kotlin为Android开发者带来什么改变？" class="headerlink" title="Kotlin为Android开发者带来什么改变？"></a>Kotlin为Android开发者带来什么改变？</h2><ol><li>效率</li><li>多平台</li></ol><p><strong>参考：</strong><a href="http://shinelw.com/2017/03/19/kotlin-compiler-process-analysis/" target="_blank" rel="noopener">Kotlin编译过程分析</a>、<a href="http://droidyue.com/blog/2017/05/08/how-to-study-kotlin/" target="_blank" rel="noopener">研究学习Kotlin的一些方法</a></p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前世今生&lt;br&gt;有什么样的语法？&lt;br&gt;语法是怎么实现的？&lt;br&gt;如何编译的？&lt;br&gt;迁移成本&lt;br&gt;为我们带来什么改变？&lt;br&gt;
    
    </summary>
    
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>JVM 答疑解惑</title>
    <link href="http://yoursite.com/2017/05/11/JVM-%E7%AD%94%E7%96%91%E8%A7%A3%E6%83%91/"/>
    <id>http://yoursite.com/2017/05/11/JVM-答疑解惑/</id>
    <published>2017-05-11T09:40:00.000Z</published>
    <updated>2018-05-04T03:35:32.876Z</updated>
    
    <content type="html"><![CDATA[<p>JVM是什么？<br>平常接触的东西都存在哪里？<br>类如何加载？<br>怎么运行？<br>清洁工怎么工作？</p><a id="more"></a><h2 id="JVM是什么？"><a href="#JVM是什么？" class="headerlink" title="JVM是什么？"></a>JVM是什么？</h2><p>Java 虚拟机屏蔽了与具体操作系统平台相关的信息,使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码),就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时,实际上最终还是把字节码解释成具体平台上的机器指令执行。</p><p>Java 虚拟机就像一个熟悉多个国家语言的导游，你只要向他说出自己的语言，他就能带着你在多个国家无障碍的玩耍。比如说，你说“我要吃肉夹馍”，无论到了哪个国家，你只需要和导游说这句话就可以，寻找和本地人交流导游就会帮你办好，最后结果是相同的：吃的都是肉夹馍。</p><p>可以参考如下Java技术体系图：<br><img src="http://wiki.jikexueyuan.com/project/java-vm/images/jvmstructure.gif" alt=""></p><h2 id="平常接触的东西都存在哪里？"><a href="#平常接触的东西都存在哪里？" class="headerlink" title="平常接触的东西都存在哪里？"></a>平常接触的东西都存在哪里？</h2><p>先看一下Java虚拟机运行时数据区：<br><img src="https://gavinzhang1.gitbooks.io/java-jvm-us/content/201208212311249241.png" alt=""></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每个线程都有自己的独立的程序计数器。</p><p>如果线程正在执行的是Java方法，那么这个计数器的值就是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值为空（undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<br>局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用和returnAddress类型（指向了一条字节码指令的地址）。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余的数据类型占1个。局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。<br>如果线程请求栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；无法申请到内存抛出OutOfMemoryError异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地栈则为虚拟机使用到的Native方法服务。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆是线程共享的，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。<br>在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p><h3 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h3><p>线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>这区域的内存回收目标主要是针对常量池的回收和对类型的卸载！</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>他是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是虚拟机运行时数据区的一部分。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。<br>在JDK1.4中新加入了NIO类，引入了一种基于通道与缓存区（buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><h2 id="类如何加载？"><a href="#类如何加载？" class="headerlink" title="类如何加载？"></a>类如何加载？</h2><p>在加载阶段，虚拟机需要完成以下 3 件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java. lang. Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>Class文件的获取方式：</p><ul><li>从 ZIP 包中读取，这很常见，最终成为日后 JAR、 EAR、 WAR 格式的基础。</li><li>从网络中获取，这种场景最典型的应用就是 Applet。</li><li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为*$Proxy 的代理类的二进制字节流。由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li><li>从数据库中读取。</li></ul><p>一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的。开发人员可以通过自定义的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass方法），这里以后可以找一些比较重要的类，分析里面所有的函数，从而知道这些东西怎么用。</p><p>对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（ Element Type， 指的是数组去掉所有维度的类型）最终是要靠类加载器去创建，一个数组类（下面简称为 C） 创建过程就遵循以下规则：</p><ol><li>如果数组的组件类型（ Component Type， 指的是数组去掉一个维度的类型）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（这点很重要，在 7. 4 节会介绍到，一个类必须与类加载器一起确定唯一性）。</li><li>如果数组的组件类型不是引用类型（例如 int[] 数组）， Java 虚拟机将会把数组 C 标记为与引导类加载器关联。</li><li>数组类的可见性与它的组件可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认设置为public</li></ol><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区怎么存储由JVM自己定义。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面）。</p><p>加载阶段和连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。</p><h2 id="怎么运行？"><a href="#怎么运行？" class="headerlink" title="怎么运行？"></a>怎么运行？</h2><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在 Class 类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。</p><p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info 四种常量类型。</p><ol><li>类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</li><li>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。</li></ol><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。</p><h2 id="清洁工怎么工作？"><a href="#清洁工怎么工作？" class="headerlink" title="清洁工怎么工作？"></a>清洁工怎么工作？</h2><p>GC要完成3件事：</p><p><strong>哪些内存需要回收？</strong><br>引用计数算法、根搜索算法</p><p><strong>什么时候回收？</strong><br>标记—清除算法、标记—整理算法</p><p><strong>如何回收？</strong><br>分代收集、垃圾收集器（不同厂商有不同实现）</p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JVM是什么？&lt;br&gt;平常接触的东西都存在哪里？&lt;br&gt;类如何加载？&lt;br&gt;怎么运行？&lt;br&gt;清洁工怎么工作？&lt;/p&gt;
    
    </summary>
    
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据库到底哪家强？</title>
    <link href="http://yoursite.com/2017/04/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E5%BA%95%E5%93%AA%E5%AE%B6%E5%BC%BA%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/04/15/数据库到底哪家强？/</id>
    <published>2017-04-15T06:24:26.000Z</published>
    <updated>2018-05-04T03:37:35.560Z</updated>
    
    <content type="html"><![CDATA[<p>目前大部分开源数据库都是基于SQLite发展而来，如SQLBrite、OrmLite、DBFlow、GreenDao等等，还有一个是Realm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎。那这么多框架到底有什么区别，那种更适合自己的产品呢？<br><a id="more"></a></p><p>我们先看基于SQLite发展而来的框架，这方面主要分成两条发展路线，一条是Rx或者叫做对象映射（OM）路线，一条是对象关系映射（ORM）路线。</p><h2 id="Rx-对象映射路线"><a href="#Rx-对象映射路线" class="headerlink" title="Rx/对象映射路线"></a>Rx/对象映射路线</h2><p>代表数据库有<a href="https://github.com/square/sqlbrite" target="_blank" rel="noopener">sqlbrite</a>、<a href="https://github.com/square/sqldelight" target="_blank" rel="noopener">sqldelight</a>，这两个都是Square出品。</p><blockquote><p>SqlBrite和SqlDelight都是对象映射（OM，Object Mappers）而不是对象关系映射（ORM，Object/Relational Mappers）。</p></blockquote><blockquote><p>ORM 其实并不是一个优秀的框架。很多平台的 ORM 实现都有性能和内存的问题。我们也不会编写ORM。 – JakeWharton</p></blockquote><p>上面这句话很好的说明了这两个框架的出发点，知道这些我们就容易理解了。</p><h3 id="SqlBrite"><a href="#SqlBrite" class="headerlink" title="SqlBrite"></a><a href="https://github.com/square/sqlbrite" target="_blank" rel="noopener">SqlBrite</a></h3><blockquote><p>SqlBrite是对 Android 系统的 SQLiteOpenHelper 的封装，对SQL操作引入了响应式语义 （Rx）（用来在 RxJava 中使用）</p></blockquote><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><ul><li>创建一个SqlBrite对象，该对象是该库的入口：<code>SqlBrite sqlBrite = SqlBrite.create();</code></li><li>提供一个 SQLiteOpenHelper实例和一个Scheduler实例来创建一个 BriteDatabase 对象：<code>BriteDatabase db = sqlBrite.wrapDatabaseHelper(openHelper, Schedulers.io());</code>，Scheduler 是指定执行查询的操作的线程，由于查询数据库是不建议在 UI 线程中执行的，所以一般指定 Schedulers.io() 。</li><li>BriteDatabase.createQuery方法和SQLiteDatabase.rawQuery方法相比，多了一个table(s)表参数，用于监听数据变更。当我们订阅subscribe返回的Observable的时候，立刻执行需要的查询语句。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable users = db.createQuery(<span class="string">"users"</span>, <span class="string">"SELECT * FROM users"</span>);</span><br><span class="line">users.subscribe(<span class="keyword">new</span> Action1() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Query query)</span> </span>&#123;</span><br><span class="line">    Cursor cursor = query.run();</span><br><span class="line">    <span class="comment">// TODO parse data...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>在保证性能和复杂扩展性的同时，利用Rxjava操作Sql在易用性上有部分提高。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>还需要编写Sql语句，复杂性还是较高。</p><h3 id="SqlDelight"><a href="#SqlDelight" class="headerlink" title="SqlDelight"></a><a href="https://github.com/square/sqldelight" target="_blank" rel="noopener">SqlDelight</a></h3><blockquote><p>SqlDelight通过从 SQL 语句来生成 JAVA 模型代码。这样的好处是，所有 SQL 语句都位于同一个位置，通过查看 SQL 语句可以清楚的了解需要实现的功能和数据库的结构,也便于管理以及java类访问。</p></blockquote><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>需要把 SQL 语句放到对应的 .sq 文件中，默认目录为和 main 目录下的 java 代码同级，例如<br>src/main/sqldelight/com/example/HockeyPlayer.sq ，其中 com/example/ 为对应 java 对象的包名字。 在该 .sq 文件中一般第一个语句是创建表的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hockey_player (</span><br><span class="line">  _id <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT,</span><br><span class="line">  <span class="built_in">number</span> <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其他的语句通过标识符来引用。在生成的 Java 对象中会包含</span></span><br><span class="line"><span class="comment">-- 一个该标识符的常亮引用这个语句。</span></span><br><span class="line">select_by_name:</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> hockey_player</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = ?;</span><br></pre></td></tr></table></figure><p>上面的 SQL 语句会生成一个 HockeyPlayerModel Java 接口。该接口内有两个嵌套类分别把 Cursor 映射为 Java 对象以及把 Java 对象转换为 ContentValues 好插入数据库</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>所有的SQL statement都存在.sq文件中，便于管理</li><li>可以自由的使用普通SQLite的同时帮助你处理了程式化的代码</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>需要编写原生sql</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>SqlBrite方便在 RxJava 中使用 Sql 操作，并且额外添加了对数据库表数据更新通知的机制，当你对数据表进行操作的时候，其他订阅者可以在数据发生变化的时候收到通知。然后可以用 RxJava 的方式来操作数据。只是一个 SQLiteOpenHelper 的轻量级封装，并不关心你的对象是如何实现的，也不关心你的数据库。SqlBrite也不支持对象映射和类型安全的查询，SqlBrite 不是一个 ORM 框架，也不是一个类型安全的查询框架。不会提供类似Gson中对象序列化的功能，也不会提供数据库迁移的功能。</p><p>SqlDelight 的做法是从 SQL 语句来生成 JAVA 模型代码。 这样的好处是，所有 SQL 语句都位于同一个位置。SqlDelight 添加了对 SQL 语句的编译时验证、表名字和列名字的代码自动完成功能。让编写 SQL 语句更加快捷。在编译的时候，根据 SQL 语句生成 Java 模型接口和 builder 来把数据行和 Java 对象实现转换。SqlDelight 不会做很重的功能（比如数据懒加载、缓存 、级联删除 等 ORM 框架内常见的功能）。</p><h2 id="对象关系映射（ORM）路线"><a href="#对象关系映射（ORM）路线" class="headerlink" title="对象关系映射（ORM）路线"></a>对象关系映射（ORM）路线</h2><p>这部分框架在易用性上和性能上都做了很多工作，易用性上基本达到极致，在性能上接近原生Sql，这里举几个有代表性的项目。</p><h3 id="OrmLite"><a href="#OrmLite" class="headerlink" title="OrmLite"></a><a href="https://github.com/j256/ormlite-android" target="_blank" rel="noopener">OrmLite</a></h3><blockquote><p>OrmLite - Lightweight Object Relational Mapping (ORM) Java Package</p></blockquote><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul><li>使用注解方式标示字段，如数据库、表等</li><li>运行时使用反射获取相应字段拼接sql去执行</li></ul><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>在易用性上相比原生sql有较大提高</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>性能上有损失</p><h3 id="greenDAO"><a href="#greenDAO" class="headerlink" title="greenDAO"></a><a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">greenDAO</a></h3><blockquote><p>greenDAO is an open source Android ORM making development for SQLite databases fun again.</p></blockquote><h4 id="基本原理、特点"><a href="#基本原理、特点" class="headerlink" title="基本原理、特点"></a>基本原理、特点</h4><ul><li>使用注解方式标示字段</li><li>在编译期生成本地sql</li><li>greenDAO 支持 protocol buffer(protobuf) 协议数据的直接存储，如果你通过 protobuf 协议与服务器交互，将不需要任何的映射。</li><li>数据加密</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><img src="http://www.jcodecraeer.com/uploads/20150727/1437967486139797.png" alt=""></p><p><img src="http://greenrobot.org/wordpress/wp-content/uploads/greenDAO-vs-OrmLite-vs-ActiveAndroid.png" alt=""></p><p>DaoMaster保存了sqlitedatebase对象以及操作DAO classes。其提供了一些创建和删除table的静态方法，其内部类OpenHelper和DevOpenHelper实现了SQLiteOpenHelper并创建数据库的框架。</p><p>DaoMaster除了具有创建表和删除表的两个功能外，还有两个内部类，分别为OpenHelper和DevOpenHelper，而DevOpenHelper继承自OpenHelper，而OpenHelper继承自SQLiteOpenHelper，而重写的onCreate()方法中调用了createAllTables(db,false)；方法来创建数据表，而createAllTables()方法中是通过调用UserDao静态方法来创建表的UserDao.createTable(db, ifNotExists)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates the underlying database table. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">(SQLiteDatabase db, <span class="keyword">boolean</span> ifNotExists)</span> </span>&#123;</span><br><span class="line">    String constraint = ifNotExists? <span class="string">"IF NOT EXISTS "</span>: <span class="string">""</span>;</span><br><span class="line">    db.execSQL(<span class="string">"CREATE TABLE "</span> + constraint + <span class="string">"\\"</span>NOTE\\<span class="string">" ("</span> + <span class="comment">//</span></span><br><span class="line">            <span class="string">"\\"</span>_id\\<span class="string">" INTEGER PRIMARY KEY AUTOINCREMENT ,"</span> + <span class="comment">// 0: id</span></span><br><span class="line">            <span class="string">"\\"</span>TEXT\\<span class="string">" TEXT NOT NULL ,"</span> + <span class="comment">// 1: text</span></span><br><span class="line">            <span class="string">"\\"</span>COMMENT\\<span class="string">" TEXT,"</span> + <span class="comment">// 2: comment</span></span><br><span class="line">            <span class="string">"\\"</span>DATE\\<span class="string">" INTEGER);"</span>); <span class="comment">// 3: date</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Drops the underlying database table. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dropTable</span><span class="params">(SQLiteDatabase db, <span class="keyword">boolean</span> ifExists)</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">"DROP TABLE "</span> + (ifExists ? <span class="string">"IF EXISTS "</span> : <span class="string">""</span>) + <span class="string">"\\"</span>NOTE\\<span class="string">""</span>;</span><br><span class="line">    db.execSQL(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>greenDAO的增删改查方法有一些是在Android原生的操作方法上进行了封装，对于链式查询的最终执行也是调用了Android原生的查询操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkThread();</span><br><span class="line">    Cursor cursor = dao.getDatabase().rawQuery(sql, parameters);</span><br><span class="line">    <span class="keyword">return</span> daoAccess.loadAllAndCloseCursor(cursor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 同时还有一些方法是基于SQLiteStatement实现的，SQLiteStatement相比原生的execSQL方法还要快一些，并且最终执行时也开启了事务，性能又提升了很多。下面是插入数据的最终实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">executeInsert</span><span class="params">(T entity, SQLiteStatement stmt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> rowId;</span><br><span class="line">    <span class="keyword">if</span> (db.isDbLockedByCurrentThread()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (stmt) &#123;</span><br><span class="line">            bindValues(stmt, entity);</span><br><span class="line">            rowId = stmt.executeInsert();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Do TX to acquire a connection before locking the stmt to avoid deadlocks</span></span><br><span class="line">        db.beginTransaction();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (stmt) &#123;</span><br><span class="line">                bindValues(stmt, entity);</span><br><span class="line">                rowId = stmt.executeInsert();</span><br><span class="line">            &#125;</span><br><span class="line">            db.setTransactionSuccessful();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            db.endTransaction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateKeyAfterInsertAndAttach(entity, rowId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> rowId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到先执行bindValues方法，该方法是一个抽象方法，需要业务方在DAO文件中实现，跟踪至NoteDao文件查看该方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">bindValues</span><span class="params">(SQLiteStatement stmt, Note entity)</span> </span>&#123;</span><br><span class="line">    stmt.clearBindings();</span><br><span class="line"></span><br><span class="line">    Long id = entity.getId();</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stmt.bindLong(<span class="number">1</span>, id);            <span class="comment">// 1为索引值，id为入库的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    stmt.bindString(<span class="number">2</span>, entity.getText());</span><br><span class="line"></span><br><span class="line">    String comment = entity.getComment();</span><br><span class="line">    <span class="keyword">if</span> (comment != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stmt.bindString(<span class="number">3</span>, comment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    java.util.Date date = entity.getDate();</span><br><span class="line">    <span class="keyword">if</span> (date != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stmt.bindLong(<span class="number">4</span>, date.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就将SQLiteStatement需要的数据都进行了封装，然后执行stmt.executeInsert()方法即可完成数据库的插入操作。整个数据插入流程，greenDAO借助SQLiteStatement完成了数据的插入，避免了其他框架利用反射拼装sql语句而造成的执行效率低下的问题。</p><p>其他优化：</p><ul><li>避免使用注解和反射拼装sql语句</li><li>最终执行时开启了事务</li><li>支持异步查询和回调</li><li>查询缓存机制，使用了弱引用WeakReference，第一次查询时将数据加入SparseArray&gt;的集合中</li></ul><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>在易用性和性能上做到了很好的平衡</p><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>上手成本</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>ORM类型框架在易用性上面做的比原生Sql提升了很多，而且在性能上GreenDao在某些方面甚至比原生的还要出色，比较适合大部分项目的开发工作。</p><h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a><a href="https://realm.io/news/realm-for-android/" target="_blank" rel="noopener">Realm</a></h2><p>Realm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎，在某些方面有自己独特的优势。</p><p>GreenDao vs Realm<br><img src="http://www.2cto.com/uploadfile/Collfiles/20160811/201608111004341068.png" alt=""></p><h4 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h4><p>增：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Realm realm=Realm.getDefaultInstance();</span><br><span class="line"></span><br><span class="line">realm.beginTransaction();</span><br><span class="line">User user = realm.createObject(User.class); <span class="comment">// Create a new object</span></span><br><span class="line">user.setName(<span class="string">"John"</span>);</span><br><span class="line">user.setEmail(<span class="string">"john@corporation.com"</span>);</span><br><span class="line">realm.commitTransaction();</span><br></pre></td></tr></table></figure><p>删：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Realm  mRealm=Realm.getDefaultInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RealmResults&lt;Dog&gt; dogs=  mRealm.where(Dog.class).findAll();</span><br><span class="line"></span><br><span class="line">        mRealm.executeTransaction(<span class="keyword">new</span> Realm.Transaction() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Realm realm)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                Dog dog=dogs.get(<span class="number">5</span>);</span><br><span class="line">                dog.deleteFromRealm();</span><br><span class="line">                <span class="comment">//删除第一个数据</span></span><br><span class="line">                dogs.deleteFirstFromRealm();</span><br><span class="line">                <span class="comment">//删除最后一个数据</span></span><br><span class="line">                dogs.deleteLastFromRealm();</span><br><span class="line">                <span class="comment">//删除位置为1的数据</span></span><br><span class="line">                dogs.deleteFromRealm(<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//删除所有数据</span></span><br><span class="line">                dogs.deleteAllFromRealm();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>易用</li><li>快速</li><li>跨平台</li><li>可视化</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul><li>显著增加安装包大小，增加大概4、5兆</li><li>数据类型限制，必须继承RealmObject、不支持内部类、修改了部分类型、不支持键值自增长。</li><li>线程限制，如果在UI线程获取到了当前Realm对象，在异步线程中使用当前Realm对象进行操作，就会抛出异常。</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>如果数据量没有达到SQLite的性能瓶颈的话，建议选择基于SQLite的数据库，如果不喜欢编写原生Sql语句就牺牲一点性能去适应业务快速迭代。<br>这些框架同时存在都有其道理，性能有优势兼容性和稳定性不能保证，易用性很好必然就不能做太多的定制化操作，各取所需，对于一般的业务GreenDao便是一个比较好的方案。</p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前大部分开源数据库都是基于SQLite发展而来，如SQLBrite、OrmLite、DBFlow、GreenDao等等，还有一个是Realm框架不是基于 SQLite 创建，它建立了自己独特的数据库存储引擎。那这么多框架到底有什么区别，那种更适合自己的产品呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Android模块化与组件化--多模块区分编译</title>
    <link href="http://yoursite.com/2017/02/03/Android%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%8C%BA%E5%88%86%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2017/02/03/Android模块化与组件化-多模块区分编译/</id>
    <published>2017-02-03T10:28:18.000Z</published>
    <updated>2018-05-04T03:35:17.691Z</updated>
    
    <content type="html"><![CDATA[<p>有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？<br><a id="more"></a></p><h1 id="模块化与组件化–多模块区分编译"><a href="#模块化与组件化–多模块区分编译" class="headerlink" title="模块化与组件化–多模块区分编译"></a>模块化与组件化–多模块区分编译</h1><blockquote><p><strong>示例地址：<a href="https://github.com/JackyAndroid/Android-Architecture-Fairy/tree/master/multi-variants-library" target="_blank" rel="noopener">https://github.com/JackyAndroid/Android-Architecture-Fairy/tree/master/multi-variants-library</a></strong><br>Android-Architecture-Fairy开源项目重点分析主流技术与架构设计，欢迎star</p></blockquote><p>有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？先看下<a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Library-Publication" target="_blank" rel="noopener">官方文档</a>如下：</p><p>By default a library only publishes its release variant. This variant will be used by all projects referencing the library, no matter which variant they build themselves. This is a temporary limitation due to Gradle limitations that we are working towards removing. You can control which variant gets published:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultPublishConfig <span class="string">"debug"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Note that this publishing configuration name references the full variant name. Release and debug are only applicable when there are no flavors. If you wanted to change the default published variant while using flavors, you would write:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultPublishConfig <span class="string">"flavor1Debug"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>It is also possible to publish all variants of a library. We are planning to allow this while using a normal project-to-project dependency (like shown above), but this is not possible right now due to limitations in Gradle (we are working toward fixing those as well).<br>Publishing of all variants are not enabled by default. The snippet below enables this feature:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    publishNonDefault <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>It is important to realize that publishing multiple variants means publishing multiple aar files, instead of a single aar containing multiple variants. Each aar packaging contains a single variant. Publishing a variant means making this aar available as an output artifact of the Gradle project. This can then be used either when publishing to a maven repository, or when another project creates a dependency on the library project.</p><p>Gradle has a concept of default” artifact. This is the one that is used when writing:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">project</span><span class="params">(<span class="string">':libraries:lib2'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>To create a dependency on another published artifact, you need to specify which one to use:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">flavor1Compile <span class="title">project</span><span class="params">(path: <span class="string">':lib1'</span>, configuration: <span class="string">'flavor1Release'</span>)</span></span></span><br><span class="line"><span class="function">    flavor2Compile <span class="title">project</span><span class="params">(path: <span class="string">':lib1'</span>, configuration: <span class="string">'flavor2Release'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>Important: Note that the published configuration is a full variant, including the build type, and needs to be referenced as such.<br>Important: When enabling publishing of non default, the Maven publishing plugin will publish these additional variants as extra packages (with classifier). This means that this is not really compatible with publishing to a maven repository. You should either publish a single variant to a repository OR enable all config publishing for inter-project dependencies.</p><p>默认Library只发布Release版本，这个是Gradle官方的限制，Google官方正在试图解决这个问题。可以使用defaultPublishConfig去设置发布的版本，通过设置publishNonDefault true可以让Library发布多个产品版本。<br>下面的这种平常书写的方式是依赖的默认发布版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">project</span><span class="params">(<span class="string">':libraries:lib2'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>如果想要分渠道编译多种形态的Library，需要修改如下的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">flavor1Compile <span class="title">project</span><span class="params">(path: <span class="string">':lib1'</span>, configuration: <span class="string">'flavor1Release'</span>)</span></span></span><br><span class="line"><span class="function">    flavor2Compile <span class="title">project</span><span class="params">(path: <span class="string">':lib1'</span>, configuration: <span class="string">'flavor2Release'</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><hr><p><strong>注意事项：</strong></p><ol><li>编译的配置是产品名称的全称加编译类型，如：flavor1Release</li><li>如果Library是Maven的公开库最好不要使用这种特性</li><li>产品名称首字母要小写，否则会有语法问题</li><li>如果Gradle里面有使用MultiDex选项会生成多个aar</li></ol><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时我们一个项目中存在多个产品形态，且不同产品需要不同的编译环境，这是模块化组件化的基础。最普通的情况便是在主模块里面加入渠道统计，但此时如果我们有多个Library，多种产品形态的主模块需要编译多种产品形态的Library，怎么办？&lt;br&gt;
    
    </summary>
    
    
      <category term="架构" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>来，谷歌安卓浏览器源码就在这！</title>
    <link href="http://yoursite.com/2017/02/03/%E6%9D%A5%EF%BC%8C%E8%B0%B7%E6%AD%8C%E5%AE%89%E5%8D%93%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BA%90%E7%A0%81%E5%B0%B1%E5%9C%A8%E8%BF%99%EF%BC%81/"/>
    <id>http://yoursite.com/2017/02/03/来，谷歌安卓浏览器源码就在这！/</id>
    <published>2017-02-03T09:49:37.000Z</published>
    <updated>2018-05-04T03:37:50.555Z</updated>
    
    <content type="html"><![CDATA[<ul><li>谷歌浏览器安卓版源码项目</li><li>本项目是世界级的安卓架构</li><li>理清本项目业务逻辑完全可以胜任国内一线公司工程师</li><li>本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star<a id="more"></a></li></ul><h3 id="欢迎在GitHub或者CSDN上关注我"><a href="#欢迎在GitHub或者CSDN上关注我" class="headerlink" title="欢迎在GitHub或者CSDN上关注我"></a>欢迎在GitHub或者CSDN上关注我</h3><p>GitHub: <a href="https://github.com/JackyAndroid" target="_blank" rel="noopener">https://github.com/JackyAndroid</a></p><p>CSDN: <a href="http://blog.csdn.net/rain_butterfly" target="_blank" rel="noopener">http://blog.csdn.net/rain_butterfly</a></p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p><hr><h1 id="AndroidChromium"><a href="#AndroidChromium" class="headerlink" title="AndroidChromium"></a>AndroidChromium</h1><p><img src="http://img.blog.csdn.net/20160710111931406" alt="这里写图片描述"></p><h4 id="AndroidChromium源码地址"><a href="#AndroidChromium源码地址" class="headerlink" title="AndroidChromium源码地址"></a><a href="https://github.com/JackyAndroid/AndroidChromium" target="_blank" rel="noopener">AndroidChromium源码地址</a></h4><p><strong>如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash）</strong></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>谷歌浏览器安卓版源码项目</li><li>本项目是世界级的安卓架构</li><li>理清本项目业务逻辑完全可以胜任国内一线公司工程师</li><li>本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star</li></ul><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://img.blog.csdn.net/20160710112035125" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20160710112101462" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20160710112120509" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20160710112144166" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20160710112154869" alt="这里写图片描述"><img src="http://img.blog.csdn.net/20160710112205838" alt="这里写图片描述"></p><hr><h3 id="以下是升级chrome内核注意事项，如不是相关人员可以忽略"><a href="#以下是升级chrome内核注意事项，如不是相关人员可以忽略" class="headerlink" title="以下是升级chrome内核注意事项，如不是相关人员可以忽略"></a>以下是升级chrome内核注意事项，如不是相关人员可以忽略</h3><hr><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>参考<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/android_build_instructions.md" target="_blank" rel="noopener">官方</a>及其他教程编译通过chromium源码，并能生成chrome.apk</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>使用AndroidStudio开发环境调试Chromium Android UI层。</p><h3 id="构建思路"><a href="#构建思路" class="headerlink" title="构建思路"></a>构建思路</h3><ol><li>采用Android Studio作为开发环境，从Chromium for Android抽取chrome模块的源码，加入Android project。</li><li>native代码在chromium环境中build，作为so加入Android project</li><li>基础模块(base, content, net等)在chromium环境build为jar包，加入Android project</li><li>content, chrome, ui等模块的资源文件加入Android library project</li></ol><h3 id="资源文件为什么不能直接都添加到Android-project呢？"><a href="#资源文件为什么不能直接都添加到Android-project呢？" class="headerlink" title="资源文件为什么不能直接都添加到Android project呢？"></a>资源文件为什么不能直接都添加到Android project呢？</h3><p>因为命名空间的原因，比如content模块的资源的命名空间为org.chromium.content, chrome模块的资源的命名空间为        org.chromium.chrome，所以需要建立不同的Android library project, 指定不同的包名。</p><h3 id="本项目和源码目录对应关系"><a href="#本项目和源码目录对应关系" class="headerlink" title="本项目和源码目录对应关系"></a>本项目和源码目录对应关系</h3><p>app/libs ———– chromium/src/out/Release/lib.java</p><p>app/src/main/aidl ———– chromium/src/chrome/android/java/src/android/support/customtabs/*.aidl</p><p>app/src/main/assets ———– chromium/src/out/Release/assets/chrome_public_apk</p><p>app/src/main/java ———— chromium/src/chrome/android/java/src</p><p>app/src/main/jniLibs ———– chromium/src/out/Release/chrome_public_apk/libs</p><p>app/src/main/res（app module 初始化资源）</p><p>libraries/androidmedia_res ———– chromium/src/third_party/android_media/java/res</p><p>libraries/chrome_res ———– chromium/src/chrome/android/java/res &amp; chromium/src/chrome/android/java/res_chromium</p><p>libraries/content_res ———– chromium/src/content/public/android/java/res</p><p>libraries/datausagechart_res ——— chromium/src/third_party/android_data_chart/java/res</p><p>libraries/ui_res ———- chromium/src/ui/android/java/res</p><h3 id="建议-amp-注意事项"><a href="#建议-amp-注意事项" class="headerlink" title="建议&amp;注意事项"></a>建议&amp;注意事项</h3><ol start="2"><li>pak和dat等文件需要加入到assets目录，而且不能压缩</li><li>aidl文件加入到main/aidl下，android studio会自动处理</li><li>目前构建的chromium版本是48.0.2554.0，内核为官方版本</li><li>因为某些java文件是通过C文件编译生成，只存在chromium/src/out  目录下。如果按以上对应关系升级版本缺失文件，请到out/目录下去搜索，根据命名空间添加相应文件。还有一些临时生成的xml资源文件也需要从out/目录下去拷贝到相应的资源模块。</li><li>如果使用的是AndroidStudio 2.0以上版本且开启instant run功能，建议关闭后再进行调试（instant run会修改首先启动的Application导致chrome provider context 引用错误导致crash）</li></ol><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>本项目灵感来自于365browser</p><h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><pre><code>Copyright 2016 Jacky Wang&lt;jacky.android@foxmail.com&gt;Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);you may not use this file except in compliance with the License.You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, softwaredistributed under the License is distributed on an &quot;AS IS&quot; BASIS,WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions andlimitations under the License.</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;谷歌浏览器安卓版源码项目&lt;/li&gt;
&lt;li&gt;本项目是世界级的安卓架构&lt;/li&gt;
&lt;li&gt;理清本项目业务逻辑完全可以胜任国内一线公司工程师&lt;/li&gt;
&lt;li&gt;本项目会长期跟进并升级谷歌浏览器内核版本，欢迎star
    
    </summary>
    
    
      <category term="开源项目" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Android Framework是怎么启动的？</title>
    <link href="http://yoursite.com/2017/02/03/Android-Framework%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/02/03/Android-Framework是怎么启动的？/</id>
    <published>2017-02-03T09:47:48.000Z</published>
    <updated>2018-05-04T03:34:41.561Z</updated>
    
    <content type="html"><![CDATA[<p>安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。<br><a id="more"></a></p><h2 id="Android-Framework运行环境是怎样的？"><a href="#Android-Framework运行环境是怎样的？" class="headerlink" title="Android Framework运行环境是怎样的？"></a>Android Framework运行环境是怎样的？</h2><p>安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。</p><p>Framework运行环境如下图：</p><p><img src="http://img.blog.csdn.net/20151222223320604" alt="这里写图片描述"></p><p>安卓系统中运行的第一个Dalvik虚拟机叫做zygote，这个的意思是“卵”，那有什么卵用呢？听这个词的意思就知道是孵化的意思，接下来所有的Dalvik虚拟机进程都是这个“卵”孵化出来的。</p><p>zygote进程中包含两个主要模块，分别如下：</p><ul><li>Socket服务端。任务是用于接收启动新的Dalvik进程的命令。</li><li>Framework共享类及共享资源。当zygote进程启动后会加载一些共享的类及资源，就像营养液一样，供其他的细胞吸收。其中共享类是在preload-classes文件中被定义的，共享资源是在preload-resources中被定义的。其他Dalvik进程是被zygote卵进程孵化出来的，所以这些类和资源加载后，新的Dalvik进程就可以直接使用这些类和资源就达到了共享目的，就像一个细胞分裂成两个，共享一些基因和营养。</li></ul><p>zygote进程对应的程序是app_process,该程序在system/bin目录下。</p><p>zygote孵化出的第一个Dalvik进程是SystemServer，该进程对应的程序依然是app_process,因为该进程是从app_process中孵化出来的。</p><p>SystemServer中创建了一个Socket客户端（生产线经理），之后所有的Dalvik进程都将通过该Socket客户端间接被启动，Ams负责管理这个客户端。如果需要启动新的APK进程时，Ams会通过该Socket客户端向zygote进程的Socket服务端（生产线工人）发送一个启动命令，然后zygote会孵化出新的进程（产品生产成型）。</p><p>这样的架构有两个特点：</p><ul><li>每一个进程都是一个Dalvik虚拟机，Dalvik虚拟机是一种类似于java虚拟机的程序。</li><li>zygote进程会预先装载共享类和共享资源，提供营养液和基因，这些类和资源其实就是SDK中定义的大部分类和资源。当通过zygote孵化出新进程后，新的APK只需要去加载APK自身包含的类和资源，这样多个APK就可以共享Framework资源了。</li></ul><h2 id="和Dalvik虚拟机关系比较好的可执行程序有哪些？"><a href="#和Dalvik虚拟机关系比较好的可执行程序有哪些？" class="headerlink" title="和Dalvik虚拟机关系比较好的可执行程序有哪些？"></a>和Dalvik虚拟机关系比较好的可执行程序有哪些？</h2><h3 id="1-dalvikvm"><a href="#1-dalvikvm" class="headerlink" title="1.dalvikvm"></a>1.dalvikvm</h3><p>java程序运行时都是由一个虚拟机来解释java字节码，将这些字节码翻译成本地CPU指令码然后执行。dalvikvm的作用就是创建一个虚拟机并执行参数中指定的java类。</p><h3 id="2-dvz"><a href="#2-dvz" class="headerlink" title="2.dvz"></a>2.dvz</h3><p>dvz的作用是从zygote进程中孵化出一个新的进程，新进程其实就是一个Dalvik虚拟机。该进程与dalvikvm启动的虚拟机相比，区别是该进程中已经预装了Framework的大部分类和资源。</p><h3 id="3-app-process"><a href="#3-app-process" class="headerlink" title="3.app_process"></a>3.app_process</h3><p>Framework在启动时需要加载运行两个特定java类，一个是ZygoteInit.java，一个是SystemServer.java。为了方便使用，系统才提供了一个app_process进程，该进程会自动运行这两个类，app_process其实就是使用dalvikvm启动ZygoteInit.java，启动后会加载Framework中得大部分类和资源。</p><h2 id="Zygote是如何启动的？"><a href="#Zygote是如何启动的？" class="headerlink" title="Zygote是如何启动的？"></a>Zygote是如何启动的？</h2><h3 id="1-在init-rc中配置Zygote启动参数"><a href="#1-在init-rc中配置Zygote启动参数" class="headerlink" title="1.在init.rc中配置Zygote启动参数"></a>1.在init.rc中配置Zygote启动参数</h3><h3 id="2-启动Socket服务端口"><a href="#2-启动Socket服务端口" class="headerlink" title="2.启动Socket服务端口"></a>2.启动Socket服务端口</h3><p>当Zygote服务从app_process开始启动后，会启动一个Dalvik虚拟机，虚拟机第一个执行的java类就是ZygoteInit.java，该类第一个重要的工作就是启动一个Socket服务端口，该Socket端口用于接收启动新进程的命令。</p><h3 id="3-加载preload-classes"><a href="#3-加载preload-classes" class="headerlink" title="3.加载preload-classes"></a>3.加载preload-classes</h3><p>在Zygote类的main（）函数中，创建完Socket服务端后还不能立即孵化出新的进程，因为这个“卵”还没有必须的“基因”，这个“基因”就是指预装的Framework大部分类及资源。</p><h3 id="4-加载preload-resources"><a href="#4-加载preload-resources" class="headerlink" title="4.加载preload-resources"></a>4.加载preload-resources</h3><p>preload-resources包含两类资源，一类是drawable资源，一类是color资源。加载这些资源是在preloadResource（）函数中完成的，该函数调用preloadDrawable（）和preloadColorStateLists（）加载这两类资源，原理就是把这些资源读出来放到一个全局变量中，只要该类对象不被销毁，这些全局变量就会一直保存。</p><h3 id="5-使用fork启动新的进程"><a href="#5-使用fork启动新的进程" class="headerlink" title="5.使用fork启动新的进程"></a>5.使用fork启动新的进程</h3><p>fork是Linux系统的一个系统调用，作用就是复制当前进程产生一个新的进程，相当于生物的克隆。除了进程id不同，新进程将拥有和原始进程完全相同的进程信息。进程的信息包括该进程所打开的文件描述符列表、所分配的内存等。当新进程被创建后，两个进程将共享已经分配的内存空间，如果其中一个需要向内存中写入数据时，操作系统才复制一份目标地址空间，并将要写的数据写入到新的地址中。这种“仅当写的时候才复制”的机制可以最大限度的在多个进程中共享物理内存。</p><h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4><p>去乌镇见一下习大大和去乌镇吃一次丁磊的猪肉，这是两个进程，但是两个进程中的很多任务是相同的，先订机票，做地铁到机场，做几小时飞机过去。到了之后不同的就是见习大大和吃猪肉。如果可以先雇一个秘书进程让它订机票、做地铁、做飞机，到乌镇。然后秘书在复制出两个秘书，一个去见习大大，一个去吃猪肉，好处是节省了大量内存。</p><p>Zygote进程就是本例中的“秘书进程”，那些“订机票、做地铁、乘飞机”就是Zygote进程中加载的preload-classes类的功能。</p><p>这样新的进程就脱离的Zygote进程的孵化成为一个真正的应用进程。</p><h2 id="SystemServer-进程是如何启动的？"><a href="#SystemServer-进程是如何启动的？" class="headerlink" title="SystemServer 进程是如何启动的？"></a>SystemServer 进程是如何启动的？</h2><p>SystemServer进程是Zygote孵化出的第一个进程，然后再配置SystemServer进程的环境。</p><h3 id="1-启动各种系统服务线程"><a href="#1-启动各种系统服务线程" class="headerlink" title="1.启动各种系统服务线程"></a>1.启动各种系统服务线程</h3><p>SystemServer进程在Android运行环境中扮演了“神经中枢”的作用，APK应用中能够直接交互的大部分系统服务都在该进程中运行，常见的有WindowManagerServer（Wms）、ActivityManagerService（Ams）、PackageManagerServer（Pms），这些系统服务都是以一个线程的方式存在于SystemServer进程中。</p><h3 id="2-启动第一个Activity"><a href="#2-启动第一个Activity" class="headerlink" title="2.启动第一个Activity"></a>2.启动第一个Activity</h3><p>当以上服务线程都启动后，其中Ams服务是systemReady（）调用完成最后启动的，在Ams的systemReady（）函数的最后一段代码则发出了启动任务队列中最上面一个Activity消息。</p><p>在Ams的startHomeActivityLocked（）中，系统发出了一个category字段包含CATEGORY_HOME的intent，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">intent.setComponent(mTopComponent);</span><br><span class="line"><span class="keyword">if</span>(mFactoryTest != SystemServer.FACTORY_TEST_LOW_LEVEL)&#123;</span><br><span class="line">intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要应用声明自己能够响应该Intent，那么就可以被认为是Home程序。当系统中有多个程序能够响应该Intent时，系统会弹出一个对话框，让用户选择启动哪个程序，也允许用户记住该选择。</p><p>到此第一个Activity就启动了。</p><p><strong><em>如有问题请留言，转载请注明出处。</em></strong></p><p><strong>备注：以上部分思想来自于《Android内核剖析》</strong></p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安卓系统启动过程其实是建立一套系统运行需要的环境，就像建立一个国家首先需要一些物质基础，比如公路、工厂、建筑。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Framework" scheme="http://yoursite.com/tags/Android-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Android 一个窗口是怎么创建出来的？</title>
    <link href="http://yoursite.com/2017/02/03/Android-%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/02/03/Android-一个窗口是怎么创建出来的？/</id>
    <published>2017-02-03T09:46:19.000Z</published>
    <updated>2018-05-04T03:34:47.561Z</updated>
    
    <content type="html"><![CDATA[<p>在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。</p><p>WmS并不在意该窗口是哪个应用程序的，关心的是活跃窗口，WmS按一定得规则判断哪个窗口处于活动状态，然后把用户消息给W类，W类再把用户消息传递给内部View变量，然后再由View对象完成剩下的消息处理。</p><h2 id="窗户有几种类型？"><a href="#窗户有几种类型？" class="headerlink" title="窗户有几种类型？"></a>窗户有几种类型？</h2><p>Framework定义了三种窗口类型，三种窗口类型的定义在WindowManager类里面。</p><ul><li>应用窗口。应用窗口一般指该窗口对应一个Activity，由于加载Activity是由Ams完成的，所以对于应用程序创建应用类窗口只能在Activity内部完成。</li><li>子窗口。子窗口是指该窗口必须要有一个父窗口，父窗口可以是一个应用类窗口也可以是任何其他的窗口。</li><li>系统窗口。系统窗口不需要对应任何Activity，也不需要有父窗口。应用程序是没有办法创建系统窗口的，只有系统进程可以创建系统窗口。</li></ul><h2 id="那么该怎么创建应用窗口呢？"><a href="#那么该怎么创建应用窗口呢？" class="headerlink" title="那么该怎么创建应用窗口呢？"></a>那么该怎么创建应用窗口呢？</h2><p>1.每个应用类窗口都对应一个Activity对象，所以创建应用类窗口需要创建Activity对象。当AmS要启动某个Activity时就会通知客户端进程，每个客户端进程都对应一个ActivityThread类，所以需要ActivityThread启动Activity。</p><p>启动某个Activity实际是构造一个Activity对象，使用ClassLoader从程序文件中装载指定的Activity对应的Class文件。</p><p>2.创建完成Activity对象后调用Activity的attach（）方法，attach（）的作用就是为刚刚创造好的Activity设置内部变量。</p><p>3.为该Activity创建Window对象。</p><p>4.给Window对象中的mWindowManager变量赋值。</p><p>5.然后就需要给该窗口添加真正的View或者ViewGroup。从performLaunchActivity（）调用callActivityOnCreate（）开始，然后经一系列调用到Activity的onCreate（）方法，在onCreate（）方法中调用setContentView（）方法实际是调用了其对应的Window对象的setContentView（）方法。</p><p>6.接着会调用到PhoneWindow的setContentView，首先调用installDecor（）为Window类添加窗口装饰，其实就是标题栏，程序中设置的layout.xml界面被包含在窗口装饰中，就是窗口内容。窗口装饰也是ViewGroup，窗口装饰和它内部的内容加起来就是我们所说的窗口，或者叫做Window界面。</p><p>7.把创建的窗口通知WmS，让WmS把窗口显示在屏幕上。当Activity准备好后会通知Ams，然后Ams经过一系列调用到Activity的makeVisible（），该方法将真正完成把窗口添加进Wms中。</p><p>8.在makeVisible方法中，首先获得该Activity内部的WindowManager对象，然后调用该对象的addView（）方法。</p><p>9.调用WindowManagerImpl的addView（）方法，流程如下：</p><ul><li>检查添加的窗口是否已经添加过，不能重复添加。</li><li>如果添加的窗口是子窗口类型，找到父窗口并保存在临时变量panelParentView中，该变量作为后面调用ViewRoot的setView（）参数。</li><li>创建一个新的ViewRoot</li><li>调用ViewRoot的setView（）。</li></ul><p>10.完成新建一个ViewRoot对象后，需要把新建的ViewRoot对象添加到mRoots对象中。</p><p>11.调用ViewRoot对象的setView方法。流程如下：</p><ul><li>给ViewRoot的重要变量赋值。</li><li>调用requestLayout（），发出界面重绘请求。</li><li>调用sWindowSession.add（），通知Wms添加窗口。</li></ul><p>创建子窗口或系统窗口过程和上面的类似。</p><p><strong>备注：以上部分思想来自于《Android内核剖析》</strong></p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在WmS看来窗口并不是Window类，而是一个View类。WmS收到用户消息后，需要把消息发送到窗口，View类其实并不能直接接受传递过来的消息，而接受消息的必须是IWindow类，实现IWindow类的是ViewRoot.W类，每一个W内部都包含了一个View变量。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Framework" scheme="http://yoursite.com/tags/Android-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Android Context 到底是什么？</title>
    <link href="http://yoursite.com/2017/02/03/Android-Context-%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/02/03/Android-Context-到底是什么？/</id>
    <published>2017-02-03T09:44:37.000Z</published>
    <updated>2018-05-04T03:34:44.570Z</updated>
    
    <content type="html"><![CDATA[<p>一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。<br><a id="more"></a></p><h2 id="什么是Android-Context？"><a href="#什么是Android-Context？" class="headerlink" title="什么是Android Context？"></a>什么是Android Context？</h2><p>一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。</p><p>那么从安卓程序的角度来看，Context是什么？其实一个Activity就是一个Context，一个Service也是一个Context。</p><p>一个应用程序可以认为是一个约会环境，用户在这个环境中会切换到不同的场景，比如先去有情调的饭店吃饭，再去电影院看个电影，然后再去xxx（此处省略一万字…）。</p><p>Activity类的确是基于Context，而Service类也是基于Context。Activity除了基于Context类外，还实现了一些其他重要的接口，从架构设计的角度看，interface仅仅是某些功能，而extends才是类的本质，即Activity的本质是一个Context，其所实现的其他接口只是为了扩充Context的功能而已，扩充后的类称之为一个Activity或Service。</p><h2 id="一个应用程序中应该有多少个Context对象"><a href="#一个应用程序中应该有多少个Context对象" class="headerlink" title="一个应用程序中应该有多少个Context对象"></a>一个应用程序中应该有多少个Context对象</h2><p>我们在应用程序开发中经常会调用Context的一些方法，这些方法看起来似乎会返回一些全局的对象，而不仅仅是某个Activity，可能会有点疑问，一个应用程序到底有多少个Context对象呢？比如，Context.getResources（）返回该应用程序所对应的Resource类对象，无论从哪个Activity中调用，都会返回同一个Resource对象。</p><ul><li>一个Activity就是一个场景（Context），一个Service也是一个场景，所以，应用程序中有多少个Activity或者Service就会有多少个Context对象，也就是有多少个场景。</li><li>getResource（）等方法返回的是同一个全局对象。</li></ul><h2 id="Context-继承关系是怎么样的呢？"><a href="#Context-继承关系是怎么样的呢？" class="headerlink" title="Context 继承关系是怎么样的呢？"></a>Context 继承关系是怎么样的呢？</h2><p><img src="http://hi.csdn.net/attachment/201203/1/0_1330607569Vj4c.gif" alt="Context类及其子类的继承关系"></p><p>Context类本身是一个纯abstract类。为了使用方便又定义了Context包装类-ContextWrapper，穿上了一身装备显得也比较强大，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中有attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象。</p><p>ContextThemeWrapper内部包含了与主题相关的接口，这里的主题就是指在AndroidManifest.xml中通过android：theme为Application或者Activity指定的主题。</p><p>只有Activity才需要主题，Service默默的后台工作者不需要穿的那么鲜艳，所以Service直接继承于ContextWrapper。</p><p>ContextImpl类真正实现了Context中所有的函数，真正的八块腹肌，我们所调用的各种Context类的方法其实实现均来自于该类。</p><h2 id="什么时候创建的Context"><a href="#什么时候创建的Context" class="headerlink" title="什么时候创建的Context?"></a>什么时候创建的Context?</h2><p>每一个应用程序在客户端都是从ActivityThread类开始的，创建Context对象也是在该类中完成，具体创建ContextImpl类的地方一共有6处：</p><ul><li>PackageInfo.makeApplication（）</li><li>performLaunchActivity（）</li><li>handleCreateBackupAgent（）</li><li>handleCreateService（）</li><li>handleBindApplication（）</li><li>attach（）</li></ul><p>其中attach（）方法仅在Framework进程启动时调用，应用程序运行时不会调用到该方法。</p><h3 id="Application对应的Context"><a href="#Application对应的Context" class="headerlink" title="Application对应的Context"></a>Application对应的Context</h3><p>程序第一次启动时，会辗转调用到makeApplication（）方法。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ContextImpl appContext = <span class="keyword">new</span> ContextImpl();</span><br><span class="line">appContext.init(<span class="keyword">this</span>,<span class="keyword">null</span>,mActivityThread);</span><br><span class="line">....</span><br><span class="line">appContext.setOuterContext(app);</span><br></pre></td></tr></table></figure><h3 id="Activity对应的Context"><a href="#Activity对应的Context" class="headerlink" title="Activity对应的Context"></a>Activity对应的Context</h3><p>启动Activity时，Ams会通过IPC调用到ActivityThread的scheduleLaunchActivity（）方法，该方法包含两种参数。一种是ActivityInfo，这是一个实现了Parcelable接口的数据类，意味着该对象是Ams创建的，并通过IPC传递到ActivityThread；另一种是其他的一些参数。</p><p>scheduleLaunchActivity（）方法中会根据以上两种参数构造一个本地ActivityRecord数据类，ActivityThread内部会为每一个Activity创建一个ActivityRecord对象，并使用这些数据对象来管理Activity。</p><p>然后会调用handleLaunchActivity（），再调用performLaunchActivity（），该方法中创建ContextImpl的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ContextImpl appContext = <span class="keyword">new</span> ContextImpl();</span><br><span class="line">appContext.init(r.packageInfo,r.token,<span class="keyword">this</span>);</span><br><span class="line">appContext.setOuterContext(activity);</span><br></pre></td></tr></table></figure><p>在performLaunchActivity（）开始执行时，会为r.packageInfo变量赋值。r.packageInfo对象的PackageInfo对象和Application对应的packageInfo对象是同一个。</p><h3 id="Service对应的Context"><a href="#Service对应的Context" class="headerlink" title="Service对应的Context"></a>Service对应的Context</h3><p>启动Service时，Ams会通过IPC调用到ActivityThread的scheduleCreateService（）方法，该方法也包含两种参数。第一种是ServiceInfo，这是实现了一个Parcelable接口的数据类，该对象由AmS创建，并通过IPC传递到ActivityThread内部；第二种是其他参数。</p><p>在scheduleCreateService（）方法中，会使用以上两种参数构造一个CreateServiceData的数据对象，ActivityThread会为其所包含的每一个Service创建该数据对象，并通过这些对象来管理Service。</p><p>然后在执行handleCreateService（）方法，创建ContextImpl对象代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ContextImpl appContext = <span class="keyword">new</span> ContextImpl();</span><br><span class="line">appContext.init(packageInfo,<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">...</span><br><span class="line">appContext.setOuterContext(service);</span><br></pre></td></tr></table></figure><p>Service对应的Context对象内部的mPackageInfo与Activity、Application中是完全相同的。</p><h2 id="这几个Context之间的关系"><a href="#这几个Context之间的关系" class="headerlink" title="这几个Context之间的关系"></a>这几个Context之间的关系</h2><p>从以上可以看出，创建Context对象的过程基本上是相同的，不同的仅仅是针对Application、Activity、Service使用了不同的数据对象。</p><p>一个应用程序包含的Context个数应该为：Context个数 = Service个数+Activity个数+1，最后的1是Application类本身也会对应一个Context对象。</p><p>应用程序中包含多个ContextImpl对象，而内部变量mPackageInfo却指向同一个PackageInfo对象，这种设计结构一般意味着ContextImpl是一种轻量级类，而PackageInfo是一个重量级类。事实上确实是这样，ContextImpl中的大多数进行包操作的重量级函数实际上都是转向了mPackageInfo对象相应的方法，也就是事实上调用了同一个PackageInfo对象。</p><p><strong>备注：以上部分思想来自于《Android内核剖析》</strong></p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个Context意味着一个场景，一个场景就是我们和软件进行交互的一个过程。比如和妹纸约会的月下小桥，比如当你使用微信的时候，场景包括聊天界面、通讯录、朋友圈，以及背后的一些数据。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Framework" scheme="http://yoursite.com/tags/Android-Framework/"/>
    
  </entry>
  
  <entry>
    <title>我眼中的Android Framework</title>
    <link href="http://yoursite.com/2017/02/03/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84Android-Framework/"/>
    <id>http://yoursite.com/2017/02/03/我眼中的Android-Framework/</id>
    <published>2017-02-03T09:40:58.000Z</published>
    <updated>2018-05-04T02:48:50.556Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—<strong>前言</strong><br><a id="more"></a></p><h1 id="我眼中的Android-Framework"><a href="#我眼中的Android-Framework" class="headerlink" title="我眼中的Android Framework"></a>我眼中的Android Framework</h1><p>在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—<strong>前言</strong></p><p>任何控制类程序都有一个入口，安卓应用程序肯定也是有滴。<br>Android framework包含三个小伙伴：服务端、客户端、linux驱动。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p> 服务端主要包含两个狠重要的类：WindowManagerService（WMS）和ActivityManagerService（AMS）</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端包含以下类：</p><ul><li><p>ActivityThread：是安卓应用程序的主线程类，这个小伙伴所在的线程就是UI线程或者称为主线程。</p></li><li><p>Activity：ActivityThread会根据用户的操作选择让哪个Activity对象上它的船。</p></li><li><p>PhoneWindow：富二代，继承于牛气的Window类，自己屋里住着一个DecorView对象，像它老爸喜欢制定规则提供了一些通用窗口操作API。</p></li><li><p>Window：富一代，长得比较抽象，喜欢制定规则提供了一些通用的窗口操作API。它不喜欢被人管所以呢，注意：WindowManagerService管理的窗口不是Window类，其实是View和ViewGroup。</p></li><li><p>DecorView：很能干的家伙，家产来自FrameLayout，比较注重外在喜欢打扮，DecorView是对FrameLayout进行了一些修饰，从名字就可以看出来。</p></li><li><p>ViewRoot：小管家继承于Handler，主要作用是把WMS的IPC调用转换为本地的一个异步调用。</p></li><li><p>W类：ViewRoot小助手，继承于binder，是ViewRoot内部类。主要帮助ViewRoot实现把WMS的IPC调用转换为本地的一个异步调用。</p></li><li><p>WindowManager：客户端如果想创建一个窗口得先告诉WindowManager一声，然后它再和WindowManagerService交流一下看看能不能创建，客户端不能直接和WMS交互。</p></li></ul><h2 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a>Linux驱动</h2><p> Linux驱动和Framework相关的主要是两个部分：画家SurfaceFlingger和快递员Binder。</p><p> 每一个窗口都对应一个画Surface，SF主要是把各个Surface显示到同一屏幕上。Binder是提供跨进程的消息传递。</p><h2 id="从apk程序的运行过程去看看上面各个组件在啥时候干啥活的"><a href="#从apk程序的运行过程去看看上面各个组件在啥时候干啥活的" class="headerlink" title="从apk程序的运行过程去看看上面各个组件在啥时候干啥活的"></a>从apk程序的运行过程去看看上面各个组件在啥时候干啥活的</h2><p>ActivityThread从main()函数中就开始动起来，然后调用prepareMainLooper()为UI线程创建一个消息快递通道即MessageQueue。</p><p>接着创建ActivityThread对象，创建过程会创建一个消息装卸工Handler对象和一个快递员Binder对象，其中Binder负责接收远程Ams的IPC调用，接收到调用后让Handler把消息装到消息快递队列，UI线程很忙的都是异步的从消息快递队列中取出消息并执行相应操作，比如 start、stop、pause。</p><p>然后UI线程让队列调用Looper.loop()方法进入消息循环体，进入后就会不断地从消息队列中读取并处理消息。</p><p>当ActivityThread接收到Ams发送start某个Activity的快递后就会创建指定的Activity对象。Activity会先按窗户再去按玻璃和贴窗花，所以先创建PhoneWindow-&gt;DecorView-&gt;创建相应的View或ViewGroup。创建完成后就可以让大家欣赏了，调用WindowManager把界面显示到屏幕上，然后创建ViewRoot，然后调用Wms提供的远程接口添加一个窗口并显示到屏幕上。</p><p>接下来就是用户的操作，事件线程不断的把消息快递发到事件队列中去，然后事件分发线程秘书逐个取出消息，然后调用Wms中的相应函数处理该消息。</p><h3 id="很多线程是不是很晕？"><a href="#很多线程是不是很晕？" class="headerlink" title="很多线程是不是很晕？"></a>很多线程是不是很晕？</h3><ol><li><p>安卓程序中都有哪些线程？</p><p>  客户端小伙伴至少包含三个线程小弟，Activity启动后会创建一个ViewRoot.W对象，同时ActivityThread会创建一个ApplicationThread对象，这两个对象继承消息总管Binder，每个Binder对应一个线程，负责接收Linux Binder驱动发送的IPC调用。还有一个是UI线程呗。</p></li><li><p>UI线程是什么？</p><p> 一直在倾听用户的心声，所有的处理用户消息，以及绘制页面的工作都在该线程中完成。</p></li><li><p>自定义的线程和UI线程有什么区别？</p><p> UI线程是从ActivityThread运行的，在该类的main()方法中已经使用了Looper.prepareMainLooper()为该线程添加了Looper对象，已经为该线程创建了消息队列，是自带秘书光环的。因此，我们才可以在Activity中去定义Handler对象，因为创建Handler对象时其线程必须已经创建了消息队列，装卸工得配运输带要不然没法干活。而普通的Thread则没有默认创建消息队列，所以不能直接在Thread中直接定义Handler，这个就是我们不懂程序运行原理导致的困惑。</p></li></ol><p><strong>备注：以上部分思想来自于《Android内核剖析》</strong></p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发中我们会遇到各种各样的非常奇怪的问题，有些问题是百思不得骑姐。其实这些问题大都是因为我们不了解安卓内部运行原理，知其所以然才是我们的目的。—&lt;strong&gt;前言&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Framework" scheme="http://yoursite.com/tags/Android-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Android 设计模式-单例模式</title>
    <link href="http://yoursite.com/2017/02/03/Android-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/02/03/Android-设计模式-单例模式/</id>
    <published>2017-02-03T09:35:12.000Z</published>
    <updated>2018-05-04T03:35:26.657Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么情况下需要单例模式？"><a href="#什么情况下需要单例模式？" class="headerlink" title="什么情况下需要单例模式？"></a>什么情况下需要单例模式？</h3><ul><li><strong>一些类提供公共功能供别人调用，本身不会处理业务逻辑</strong></li><li><strong>类会被许多类和线程调用</strong><a id="more"></a></li></ul><h1 id="Android-设计模式-单例模式"><a href="#Android-设计模式-单例模式" class="headerlink" title="Android 设计模式-单例模式"></a>Android 设计模式-单例模式</h1><h3 id="什么情况下需要单例模式？-1"><a href="#什么情况下需要单例模式？-1" class="headerlink" title="什么情况下需要单例模式？"></a>什么情况下需要单例模式？</h3><ul><li><strong>一些类提供公共功能供别人调用，本身不会处理业务逻辑</strong></li><li><strong>类会被许多类和线程调用</strong></li></ul><hr><h3 id="设计单例模式"><a href="#设计单例模式" class="headerlink" title="设计单例模式"></a>设计单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton mSingleton;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mSingleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">     mSingleton = <span class="keyword">new</span> Singleton();\\A</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSingleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的做法在多线程的时候会出现问题，比如有两个线程同时调用getInstance(),这时会new两个对象出来。</p><h3 id="单例模式改进1"><a href="#单例模式改进1" class="headerlink" title="单例模式改进1"></a>单例模式改进1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton mSingleton;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">    <span class="keyword">if</span>(mSingleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">     mSingleton = <span class="keyword">new</span> Singleton();\\A</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSingleton;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式还是会有问题，就是高并发情况下多线程去抢夺锁，假如有几百个线程，其中有一个运气比较差，这个线程就会出现一直去getInstance，资源一直返回不回去，UI也不会得到更新。</p><h3 id="单例模式改进2"><a href="#单例模式改进2" class="headerlink" title="单例模式改进2"></a>单例模式改进2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton mSingleton;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mSingleton == <span class="keyword">null</span>)&#123;\\A</span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class)&#123;\\C</span><br><span class="line">     <span class="keyword">if</span>(mSingleton == <span class="keyword">null</span>)</span><br><span class="line">      mSingleton = <span class="keyword">new</span> Singleton();\\B</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mSingleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：volatile是防止cpu进行指令重排序，防止代码顺序被更改。<br>这种方式比较好的地方在于第一次创建实例时候就会同步所有的线程，以后再获取实例就会直接返回。</p><h3 id="但是看代码好像还是有人会有疑问，为什么需要两次判断为null？"><a href="#但是看代码好像还是有人会有疑问，为什么需要两次判断为null？" class="headerlink" title="但是看代码好像还是有人会有疑问，为什么需要两次判断为null？"></a>但是看代码好像还是有人会有疑问，为什么需要两次判断为null？</h3><p>其实这个意义在于防止多个线程同时进入第一个if内，比如说线程A执行到A行，线程B执行到B行，线程B还没有返回。当线程A执行到C行，这时线程B初始化实例完毕，如果没有里面的再一次判断就会生成两个实例！所以两次的判断null还是有意义的。</p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么情况下需要单例模式？&quot;&gt;&lt;a href=&quot;#什么情况下需要单例模式？&quot; class=&quot;headerlink&quot; title=&quot;什么情况下需要单例模式？&quot;&gt;&lt;/a&gt;什么情况下需要单例模式？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一些类提供公共功能供别人调用，本身不会处理业务逻辑&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类会被许多类和线程调用&lt;/strong&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>东半球最好的TV桌面开源项目</title>
    <link href="http://yoursite.com/2017/02/03/%E4%B8%9C%E5%8D%8A%E7%90%83%E6%9C%80%E5%A5%BD%E7%9A%84TV%E6%A1%8C%E9%9D%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2017/02/03/东半球最好的TV桌面开源项目/</id>
    <published>2017-02-03T09:14:46.000Z</published>
    <updated>2018-05-04T03:35:44.653Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。<br><a id="more"></a></p><h3 id="欢迎在GitHub或者CSDN上关注我"><a href="#欢迎在GitHub或者CSDN上关注我" class="headerlink" title="欢迎在GitHub或者CSDN上关注我"></a>欢迎在GitHub或者CSDN上关注我</h3><p>GitHub: <a href="https://github.com/JackyAndroid" target="_blank" rel="noopener">https://github.com/JackyAndroid</a></p><p>CSDN: <a href="http://blog.csdn.net/rain_butterfly" target="_blank" rel="noopener">http://blog.csdn.net/rain_butterfly</a></p><p><img src="http://www.jackywang.tech/images/gongzh.png" alt=""></p><hr><h1 id="AndroidTVLauncher"><a href="#AndroidTVLauncher" class="headerlink" title="AndroidTVLauncher"></a>AndroidTVLauncher</h1><p><img src="http://img.blog.csdn.net/20160914141146439" alt="这里写图片描述"></p><p>这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>CatLauncher(Leanback风格) 目前功能已基本稳定，后续会跟进官方Leanback库的进展，Compatible桌面理论上不再维护</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote><ul><li>Leanback风格</li><li>图片展示</li><li>视频直播（节操播放器-基于ijkplayer）</li><li>媒体详情</li><li>第三方应用列表</li><li>桌面特殊功能</li></ul></blockquote><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://img.blog.csdn.net/20160914141236454" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160914141253290" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160914141304978" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160914141318267" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160914141351260" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160914141402120" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20160914141411939" alt="这里写图片描述"></p><h3 id="下一步的改进"><a href="#下一步的改进" class="headerlink" title="下一步的改进"></a>下一步的改进</h3><blockquote><ul><li>跟进官方Leanback库新功能</li></ul></blockquote><h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><p>Apache License, Version 2.0</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个TV 桌面，包含了一个Leanback 桌面（最低版本是17）和一个普通桌面（最低版本是15），Leanback桌面是基于Leanback库开发符合Android TV官方交互规范。&lt;br&gt;
    
    </summary>
    
    
      <category term="开源项目" scheme="http://yoursite.com/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
</feed>
